<!DOCTYPE html> 
<html lang="en" xml:lang="en" > 
<head>
  <title>Solution Methods for Microeconomic Dynamic Stochastic Optimization Problems</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="SolvingMicroDSOPs.css" /> 
<meta name="src" content="SolvingMicroDSOPs.tex"> 
</head><body 
>
<!--l. 44--><p class="noindent" >                                                                <span 
class="ecrm-0600">SolvingMicroDSOPs, November 17,</span>
<span 
class="ecrm-0600">2021</span>
  <div class="maketitle">
<h2 class="titleHead">Solution Methods for Microeconomic Dynamic
Stochastic Optimization Problems</h2>
<div class="date" >November 17, 2021</div>
<span 
class="ecrm-0600">¬†</span>
 <div class="author" ><span 
class="ecrm-1440">Christopher D. Carroll</span><sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup></div>
<br />
</div>
<!--l. 60--><p class="noindent" >Note: The code associated with this document should work (though the Matlab code may be
out of date), but has been superceded by the set of tools available in the <a 
href="https://github.com/econ-ark/HARK" >Econ-ARK</a> toolkit,
more speciÔ¨Åcally the <a 
href="https://github.com/econ-ark/HARK" >HARK Framework</a>. The SMM estination code at the end has speciÔ¨Åcally
been superceded by the <a 
href="https://github.com/econ-ark/REMARK/tree/master/REMARKs/SolvingMicroDSOPs" >SolvingMicroDSOPs</a> <a 
href="https://github.com/econ-ark/REMARK" >REMARK</a>
<!--l. 63--><p class="indent" >  <a 
 id="Abstract"></a> <div 
class="abstract" 
>
<!--l. 64--><p class="noindent" > <br 
class="newline" />_____________________________________________________________________________________
<!--l. 64--><p class="noindent" ><span 
class="ecbx-1200">Abstract</span><br 
class="newline" />   <span 
class="ecrm-1095">These notes describe tools for solving microeconomic dynamic stochastic optimization problems,</span>
<span 
class="ecrm-1095">and show how to use those tools for eÔ¨Éciently estimating a standard life cycle consumption/saving</span>
<span 
class="ecrm-1095">model using microeconomic data. No attempt is made at a systematic overview of the many possible</span>
<span 
class="ecrm-1095">technical choices; instead, I present a speciÔ¨Åc set of methods that have proven useful in my own work</span>
<span 
class="ecrm-1095">(and explain why other popular methods, such as value function iteration, are a bad idea). Paired</span>
<span 
class="ecrm-1095">with these notes is </span><span 
class="ecti-1095">Mathematica </span><span 
class="ecrm-1095">and Matlab software that solves the problems described in the text.</span>
<br 
class="newline" />
        <div class="quote">
                     <dl class="list2"><dt class="list">
<span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†Keywords</span><span 
class="ecbx-1200">¬†</span></dt><dd 
class="list">
                 <!--l. 74--><p class="noindent" >Dynamic  Stochastic  Optimization,  Method  of  Simulated
                   Moments, Structural Estimation
                                                                                     
                                                                                     
              </dd><dt class="list">
<span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†JEL codes</span><span 
class="ecbx-1200">¬†</span></dt><dd 
class="list">
              <!--l. 74--><p class="noindent" >E21, F41</dd></dl>
      </div>
</div>
<div class="center" 
>
<!--l. 77--><p class="noindent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†PDF:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs.pdf" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs.pdf</span></a>
</td></tr></table>
<!--l. 79--><p class="noindent" ><table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†Slides:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs-Slides.pdf" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs-Slides.pdf</span></a></td></tr></table>
<!--l. 80--><p class="noindent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†Web:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://llorracc.github.io/SolvingMicroDSOPs" class="url" ><span 
class="ectt-1000">https://llorracc.github.io/SolvingMicroDSOPs</span></a></td></tr></table>
<!--l. 81--><p class="noindent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†Code:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs/tree/master/Code" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs/tree/master/Code</span></a></td></tr></table>
<!--l. 82--><p class="noindent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">Archive:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs</span></a></td></tr></table>
<!--l. 83--><p class="noindent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><span 
class="ecti-1000">(Contains LaTeX code for this document and software producing Ô¨Ågures and results)</span></td></tr></table>
<!--l. 85--><p class="noindent" >
</div>
<!--l. 92--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
<!--l. 94--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
      <sup class="textsuperscript"></sup>
<!--l. 91--><p class="indent" >  <sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup><span 
class="ecrm-1000">Carroll: Department of Economics, Johns Hopkins University, Baltimore, MD,</span>
<a 
href="http://www.econ2.jhu.edu/people/ccarroll/" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/</span></a><span 
class="ecrm-1000">, </span><a 
href="mailto:ccarroll@jhu.edu" ><span 
class="ectt-1000">ccarroll@jhu.edu</span></a><span 
class="ecrm-1000">, Phone: (410) 516-7602</span><span 
class="ecrm-1000">¬†</span><span 
class="ecrm-1000">¬†</span><span 
class="ecrm-1000">¬†</span><span 
class="ecrm-1000">¬†</span>
      <sup class="textsuperscript"></sup><span 
class="ecrm-1000">The notes were originally written for my Advanced Topics in Macroeconomic Theory class at</span>
<span 
class="ecrm-1000">Johns Hopkins University; instructors elsewhere are welcome to use them for teaching purposes. Relative</span>
<span 
class="ecrm-1000">to earlier drafts, this version incorporates several improvements related to new results in the paper</span>
<a 
href="http://econ-ark.github.io/BufferStockTheory" ><span 
class="ecrm-1000">‚ÄúTheoretical Foundations of BuÔ¨Äer Stock Saving‚Äù</span></a> <span 
class="ecrm-1000">(especially tools for approximating the consumption</span>
<span 
class="ecrm-1000">and value functions). Like the last major draft, it also builds on material in ‚ÄúThe Method of Endogenous</span>
<span 
class="ecrm-1000">Gridpoints  for  Solving  Dynamic  Stochastic  Optimization  Problems‚Äù   published  in  </span><span 
class="ecti-1000">Economics</span>
<span 
class="ecti-1000">Letters</span><span 
class="ecrm-1000">,  available  at  </span><a 
href="http://www.econ2.jhu.edu/people/ccarroll/EndogenousArchive.zip" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/EndogenousArchive.zip</span></a><span 
class="ecrm-1000">,  and</span>
<span 
class="ecrm-1000">by  including  sample  code  for  a  method  of  simulated  moments  estimation  of  the  life  cycle</span>
<span 
class="ecrm-1000">model  </span><span 
class="ecti-1000">a  la  </span><a 
href="#XgpLifecycle"><span 
class="ecrm-1000">Gourinchas  and  Parker</span></a><span 
class="ecrm-1000">¬†(</span><a 
href="#XgpLifecycle"><span 
class="ecrm-1000">2002</span></a><span 
class="ecrm-1000">)  and  Cagetti</span><span 
class="ecrm-1000">¬†(</span><a 
href="#XcagettiWprofiles"><span 
class="ecrm-1000">2003</span></a><span 
class="ecrm-1000">).  Background  derivations,  notation,</span>
<span 
class="ecrm-1000">and   related   subjects   are   treated   in   my   class   notes   for   Ô¨Årst   year   macro,   available   at</span>
<a 
href="http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption</span></a><span 
class="ecrm-1000">.  I  am  grateful</span>
<span 
class="ecrm-1000">to several generations of graduate students in helping me to reÔ¨Åne these notes, to Marc Chan for help</span>
<span 
class="ecrm-1000">in updating the text and software to be consistent with </span><a 
href="#XcarrollEGM"><span 
class="ecrm-1000">Carroll</span></a><span 
class="ecrm-1000">¬†(</span><a 
href="#XcarrollEGM"><span 
class="ecrm-1000">2006</span></a><span 
class="ecrm-1000">), to Kiichi Tokuoka for drafting</span>
<span 
class="ecrm-1000">the section on structural estimation, to Damiano Sandri for exceptionally insightful help in revising and</span>
<span 
class="ecrm-1000">updating the method of simulated moments estimation section, and to Weifeng Wu and Metin Uyanik</span>
<span 
class="ecrm-1000">for revising to be consistent with the ‚Äòmethod of moderation‚Äô and other improvements. All errors are</span>
<span 
class="ecrm-1000">my own.</span>
                                                                                     
                                                                                     
<!--l. 130--><p class="indent" >  <a 
 id="Introduction"></a>
  <h3 class="sectionHead"><span class="titlemark">1  </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 133--><p class="noindent" >Calculating the mathematically optimal amount to save is a remarkably diÔ¨Écult problem.
Under well-founded assumptions about the nature of risk (and attitudes toward risk), the
problem cannot be solved analytically; computational solutions are the only option. To avoid
having to solve this hard problem, past generations of economists showed impressive ingenuity
in reformulating the question. Budding graduate students are still taught a host of tricks
whose purpose is partly to avoid the resort to numerical solutions: Quadratic or
Constant Absolute Risk Aversion utility, perfect markets, perfect insurance, perfect
foresight, the ‚Äútimeless‚Äù perspective, the restriction of uncertainty to very special
kinds,<span class="footnote-mark"><a 
href="SolvingMicroDSOPs2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-1001f1"></a>  
and more.
<!--l. 148--><p class="indent" >  The motivation is mainly to exchange an intractable general problem for a tractable speciÔ¨Åc
alternative. Unfortunately, the burgeoning literature on numerical solutions has shown that
the features that yield tractability also profoundly change the solution. These tricks are
excuses to solve a problem that has deÔ¨Åned away the central diÔ¨Éculty: Understanding the
proper role of uncertainty (and other complexities like constraints) in optimal intertemporal
choice.
<!--l. 156--><p class="indent" >  The temptation to use such tricks (and the tolerance for them in leading academic journals)
is palpably lessening, thanks to advances in mathematical analysis, increasing computing
power, and the growing capabilities of numerical computation software. Together, such tools
permit today‚Äôs laptop computers to solve problems that required supercomputers a decade ago
(and, before that, could not be solved at all).
<!--l. 164--><p class="indent" >  These points are not unique to the consumption/saving problem; the same propositions
apply to almost any question that involves both intertemporal choice and uncertainty,
including many aspects of the behavior of Ô¨Årms and governments.
<!--l. 169--><p class="indent" >  Given the ubiquity of such problems, one might expect that the use of numerical methods
for solving dynamic optimization problems would by now be nearly as common as the use of
econometric methods in empirical work.
<!--l. 174--><p class="indent" >  Of course, we remain far from that equilibrium. The most plausible explanation for the
gap is that barriers to the use of numerical methods have remained forbiddingly
high.
<!--l. 178--><p class="indent" >  These lecture notes provide a gentle introduction to a particular set of solution tools and
show how they can be used to solve some canonical problems in consumption choice and
portfolio allocation. SpeciÔ¨Åcally, the notes describe and solve optimization problems for a
consumer facing uninsurable idiosyncratic risk to nonÔ¨Ånancial income (e.g., labor or transfer
                                                                                     
                                                                                     
income),<span class="footnote-mark"><a 
href="SolvingMicroDSOPs3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-1002f2"></a>  
with detailed intuitive discussion of the various mathematical and computational techniques
that, together, speed the solution by many orders of magnitude compared to ‚Äúbrute
force‚Äù methods. The problem is solved with and without liquidity constraints, and
the inÔ¨Ånite horizon solution is obtained as the limit of the Ô¨Ånite horizon solution.
After the basic consumption/saving problem with a deterministic interest rate is
described and solved, an extension with portfolio choice between a riskless and a
risky asset is also solved. Finally, a simple example is presented of how to use these
methods (via the statistical ‚Äòmethod of simulated moments‚Äô or MSM; sometimes called
‚Äòsimulated method of moments‚Äô or SMM) to estimate structural parameters like
the coeÔ¨Écient of relative risk aversion (<span 
class="ecti-1200">a la </span>Gourinchas and Parker¬†(<a 
href="#XgpLifecycle">2002</a>) and
Cagetti¬†(<a 
href="#XcagettiWprofiles">2003</a>)).
<!--l. 209--><p class="indent" >  <a 
 id="The-Problem"></a>
  <h3 class="sectionHead"><span class="titlemark">2  </span> <a 
 id="x1-20002"></a>The Problem</h3>
<!--l. 211--><p class="noindent" >We are interested in the behavior a consumer whose goal in period <img 
src="SolvingMicroDSOPs0x.svg" alt="t  " class="math";align="absmiddle"> is to maximize expected
discounted utility from consumption over the remainder of a lifetime that ends in period <img 
src="SolvingMicroDSOPs1x.svg" alt="T  " class="math";align="absmiddle">:
  <table 
class="equation"><tr><td><a 
 id="x1-2001r1"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs2x.svg" alt="       [               ]
         T‚àë‚àí t
max  ùîºt      Œ≤nùúÉu (ct+n)  ,
         nùúÉ=0
" class="math-display" ></center></td><td class="equation-label">(1)</td></tr></table>
<!--l. 3--><p class="nopar" >
and whose circumstances evolve according to the transition
                                                                                     
                                                                                     
equations<span class="footnote-mark"><a 
href="SolvingMicroDSOPs4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-2002f3"></a>  
  <table 
class="equation"><tr><td><a 
 id="x1-2003r2"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs3x.svg" alt="  at = mt ‚àí  ct
 bt+1 = atRt+1
y    = ppp   ùúÉ
  t+1    t+1 t+1
mt+1 = bt+1 + yt+1
" class="math-display" ></center></td><td class="equation-label">(2)</td></tr></table>
<!--l. 6--><p class="nopar" >
where the variables are
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs4x.svg" alt="  Œ≤ ‚àí                                      pure time  discount factor

  at‚àí      assets after all actions have been accomplished in period t
bt+1‚àí   ‚Äòbank  balances‚Äô (nonhuman   wealth ) at the beginning of t + 1

  ct‚àí                                       consumption  in period t
 mt ‚àí  ‚Äòmarket  resources‚Äô available for consumption  (‚Äòcash-on-hand ‚Äô)

pppt+1‚àí                       ‚Äòpermanent  labor income ‚Äô in period t + 1
Rt+1‚àí                interest factor (1 + rt+1) from period t to t + 1
y   ‚àí                             noncapital income  in period t + 1.
 t+1
" class="math-display" ></center></td></tr></table>
<!--l. 10--><p class="nopar" >
<!--l. 245--><p class="indent" >  For now, we will assume that the exogenous variables evolve as follows:
  <table 
class="equation"><tr><td><a 
 id="x1-2004r3"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs5x.svg" alt="     Rt =R  ‚àÄ t                - constant interest factor = 1 + r
    pppt+1 = Œì t+1pppt           - permanent  labor income  dynamics
                 2    2
log  ùúÉt+n ‚àº  ùí© (‚àí œÉùúÉ‚àï2,œÉùúÉ)  - lognormal  transitory shocks ‚àÄ n &#x003E;  0.
" class="math-display" ><a 
 id="x1-2004r2"></a></center></td></tr></table>
<!--l. 5--><p class="nopar" >
<!--l. 256--><p class="indent" >  Using the fact about lognormally distributed variables
<a 
href="https://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/MathFactsList/ELogNorm" ><span 
class="ectt-1200">ELogNorm</span></a><span class="footnote-mark"><a 
href="SolvingMicroDSOPs5.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-2005f4"></a>  
that if <img 
src="SolvingMicroDSOPs7x.svg" alt="log Œ¶ ‚àº ùí©  (œï, œÉ2)
               œï  " class="math";align="absmiddle"> then <img 
src="SolvingMicroDSOPs8x.svg" alt="log ùîº[Œ¶ ] = œï + œÉ2 ‚àï2
                œï  " class="math";align="absmiddle">, assumption the assumption about the
distribution of shocks guarantees that <img 
src="SolvingMicroDSOPs9x.svg" alt="log ùîº[ùúÉ] = 0  " class="math";align="absmiddle"> which means that <img 
src="SolvingMicroDSOPs10x.svg" alt="ùîº [ùúÉ]  " class="math";align="absmiddle">=1 (the mean
value of the transitory shock is 1).
<!--l. 265--><p class="indent" >  Equation (<a 
href="#x1-2004r2">3<!--tex4ht:ref: eq:permincgrow --></a>) indicates that we are allowing for a predictable average proÔ¨Åle of
income growth over the lifetime <img 
src="SolvingMicroDSOPs11x.svg" alt="{Œì }T
    0   " class="math";align="absmiddle"> (allowing, for example, for typical career wage
                                                                                     
                                                                                     
paths).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs6.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-2006f5"></a>  
<!--l. 282--><p class="indent" >  Finally, the utility function is of the Constant Relative Risk Aversion (CRRA), form,
<img 
src="SolvingMicroDSOPs12x.svg" alt="u (‚àô ) = ‚àô1‚àí œÅ‚àï(1 ‚àí œÅ )  " class="math";align="absmiddle">.
<!--l. 285--><p class="indent" >  As is well known, this problem can be rewritten in recursive (Bellman equation) form
  <table 
class="equation"><tr><td><a 
 id="x1-2007r3"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs13x.svg" alt="vt(mt,pppt) = max   u(ct) + ùîºt[Œ≤vt+1(mt+1, pppt+1)]
              ct
" class="math-display" ></center></td><td class="equation-label">(3)</td></tr></table>
<!--l. 3--><p class="nopar" >
subject to the Dynamic Budget Constraint (DBC) (<a 
href="#x1-2003r2">2<!--tex4ht:ref: DBCLevelStart --></a>)-(<span 
class="ecbx-1200">??</span>) given above, where <img 
src="SolvingMicroDSOPs14x.svg" alt="vt  " class="math";align="absmiddle"> measures
total expected discounted utility from behaving optimally now and henceforth.
<!--l. 296--><p class="indent" >  <a 
 id="Normalization"></a>
  <h3 class="sectionHead"><span class="titlemark">3  </span> <a 
 id="x1-30003"></a>Normalization</h3>
<!--l. 300--><p class="noindent" >The single most powerful method for speeding the solution of such models is to redeÔ¨Åne the
problem in a way that reduces the number of state variables (if possible). In the consumption
problem here, the obvious idea is to see whether the problem can be rewritten in terms of the
ratio of various variables to permanent noncapital (‚Äòlabor‚Äô) income <img 
src="SolvingMicroDSOPs15x.svg" alt="pppt  " class="math";align="absmiddle"> (henceforth for brevity
referred to simply as ‚Äòpermanent income.‚Äô)
<!--l. 310--><p class="indent" >  In the last period of life, there is no future, <img 
src="SolvingMicroDSOPs16x.svg" alt="vT +1 = 0  " class="math";align="absmiddle">, so the optimal plan is to consume
everything, implying that
  <table 
class="equation"><tr><td><a 
 id="x1-3001r4"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs17x.svg" alt="              m1 ‚àíœÅ
vT(mT ,pppT ) = --T--.
              1 ‚àí œÅ
" class="math-display" ></center></td><td class="equation-label">(4)</td></tr></table>
<!--l. 315--><p class="nopar" >
Now deÔ¨Åne nonbold variables as the bold variable divided by the level of permanent
income in the same period, so that, for example, <img 
src="SolvingMicroDSOPs18x.svg" alt="mT  =  mT ‚àïpppT  " class="math";align="absmiddle">; and deÔ¨Åne
<img 
src="SolvingMicroDSOPs19x.svg" alt="vT (mT ) = u(mT )  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs7.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-3002f6"></a>  
For our CRRA utility function, <img 
src="SolvingMicroDSOPs22x.svg" alt="u(xy) = x1‚àí œÅu(y)  " class="math";align="absmiddle">, so equation (<a 
href="#x1-3001r4">4<!--tex4ht:ref: eq:levelTm1 --></a>) can be rewritten
as
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs23x.svg" alt="                    1‚àí œÅ              1‚àíœÅ
v  (m  ,ppp ) = ppp1‚àíœÅ-mT---=  ppp1‚àíœÅŒì 1‚àí œÅm-T---= ppp1‚àíœÅ Œì 1‚àíœÅv (m  ).
  T   T  T     T  1 ‚àí œÅ     T‚àí1  T  1 ‚àí œÅ    T‚àí 1 T   T   T
" class="math-display" ></center></td></tr></table>
<!--l. 323--><p class="nopar" >
<!--l. 326--><p class="indent" >  Now deÔ¨Åne a new optimization problem:
  <table 
class="equation"><tr><td><a 
 id="x1-3003r5"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs24x.svg" alt="vt(mt ) = max   u(ct) + ùîºt[Œ≤Œì 1‚àíœÅvt+1(mt+1)]
           ct                t+1
       s.t.

     at = mt ‚àí ct
  mt+1 =  (R‚àïŒì t+1) at + ùúÉt+1
          ‚óü--‚óù‚óú--‚óû
           ‚â° ‚Ñõt+1
" class="math-display" ><a 
 id="x1-3003r4"></a></center></td></tr></table>
<!--l. 7--><p class="nopar" >
<!--l. 338--><p class="indent" >  The accumulation equation is the normalized version of the transition equation for
<img 
src="SolvingMicroDSOPs25x.svg" alt="m
  t+1   " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs8.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-3004f7"></a>  
Then it is easy to see that for <img 
src="SolvingMicroDSOPs27x.svg" alt="t = T ‚àí 1  " class="math";align="absmiddle">,
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs28x.svg" alt="v   (m    ,ppp    ) = ppp1‚àíœÅv    (m    )
 T‚àí1   T‚àí1  T ‚àí1     T‚àí1 T‚àí 1  T ‚àí1
" class="math-display" ></center></td></tr></table>
                                                                                     
                                                                                     
<!--l. 348--><p class="nopar" >
and so on back to all earlier periods. Hence, if we solve the problem (<a 
href="#x1-3003r4">5<!--tex4ht:ref: vtNorm --></a>) which has only a single
state variable <img 
src="SolvingMicroDSOPs29x.svg" alt="mt  " class="math";align="absmiddle">, we can obtain the levels of the value function, consumption, and all other
variables of interest simply by multiplying the results by the appropriate function of <img 
src="SolvingMicroDSOPs30x.svg" alt="ppp
  t  " class="math";align="absmiddle">,
e.g.¬†<img 
src="SolvingMicroDSOPs31x.svg" alt="ct(mt, pppt) = ppptct(mt ‚àïpppt)  " class="math";align="absmiddle"> or <img 
src="SolvingMicroDSOPs32x.svg" alt="              1‚àíœÅ
vt (mt, pppt) = pppt  vt(mt)  " class="math";align="absmiddle">. We have thus reduced the problem
from two continuous state variables to one (and thereby enormously simpliÔ¨Åed its
solution).
<!--l. 356--><p class="indent" >  For some problems it will not be obvious that there is an appropriate ‚Äònormalizing‚Äô variable,
but many problems can be normalized if suÔ¨Écient thought is given. For example,
<a 
href="#Xvalencia:2006">Valencia</a>¬†(<a 
href="#Xvalencia:2006">2006</a>) shows how a bank‚Äôs optimization problem can be normalized by the level of
the bank‚Äôs productivity.
<!--l. 366--><p class="indent" >  <a 
 id="The-Usual-Theory"></a>
  <h3 class="sectionHead"><span class="titlemark">4  </span> <a 
 id="x1-40004"></a>The Usual Theory, and A Bit More Notation</h3>
<!--l. 371--><p class="noindent" >The Ô¨Årst order condition for (<a 
href="#x1-3003r4">5<!--tex4ht:ref: vtNorm --></a>) with respect to <img 
src="SolvingMicroDSOPs33x.svg" alt="ct  " class="math";align="absmiddle"> is
  <table 
class="equation"><tr><td><a 
 id="x1-4001r5"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs34x.svg" alt="u ‚Ä≤(c ) = ùîº [Œ≤ ‚Ñõ   Œì 1‚àíœÅv‚Ä≤  (m   )]
    t     t    t+1  t+1  t+1   t+1
      =  ùîºt[Œ≤R    Œìt‚àí+œÅ1vt‚Ä≤+1(mt+1 )]
" class="math-display" ><a 
 id="x1-4001r4"></a></center></td></tr></table>
<!--l. 375--><p class="nopar" >
and because the <a 
href="https://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption/Envelope" ><span 
class="ectt-1200">Envelope</span></a> theorem tells us that
  <table 
class="equation"><tr><td><a 
 id="x1-4002r5"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs35x.svg" alt="v‚Ä≤t(mt ) = ùîºt[Œ≤RŒì ‚àít+œÅ1v ‚Ä≤t+1 (mt+1 )]
" class="math-display" ></center></td><td class="equation-label">(5)</td></tr></table>
                                                                                     
                                                                                     
<!--l. 379--><p class="nopar" >
we can substitute the LHS of (<a 
href="#x1-4002r5">5<!--tex4ht:ref: eq:envelope --></a>) for the RHS of (<a 
href="#x1-4001r4">5<!--tex4ht:ref: eq:upceqEvtp1 --></a>) to get
  <table 
class="equation"><tr><td><a 
 id="x1-4003r6"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs36x.svg" alt="u ‚Ä≤(ct) = v‚Ä≤t(mt )
" class="math-display" ></center></td><td class="equation-label">(6)</td></tr></table>
<!--l. 3--><p class="nopar" >
and rolling this equation forward one period yields
  <table 
class="equation"><tr><td><a 
 id="x1-4004r7"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs37x.svg" alt="u‚Ä≤(ct+1) = v ‚Ä≤t+1(at‚Ñõt+1 + ùúÉt+1)
" class="math-display" ></center></td><td class="equation-label">(7)</td></tr></table>
<!--l. 391--><p class="nopar" >
while substituting the LHS in equation (<a 
href="#x1-4001r4">5<!--tex4ht:ref: eq:upceqEvtp1 --></a>) gives us the Euler equation for consumption
  <table 
class="equation"><tr><td><a 
 id="x1-4005r8"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs38x.svg" alt="  ‚Ä≤             ‚àíœÅ  ‚Ä≤
u (ct) = ùîºt[Œ≤R Œì t+1u (ct+1)].
" class="math-display" ></center></td><td class="equation-label">(8)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 401--><p class="indent" >  Now note that in equation (<a 
href="#x1-4004r7">7<!--tex4ht:ref: eq:upctp1EqVpxtp1 --></a>) neither <img 
src="SolvingMicroDSOPs39x.svg" alt="mt  " class="math";align="absmiddle"> nor <img 
src="SolvingMicroDSOPs40x.svg" alt="ct  " class="math";align="absmiddle"> has any <span 
class="ecti-1200">direct </span>eÔ¨Äect on <img 
src="SolvingMicroDSOPs41x.svg" alt="vt+1   " class="math";align="absmiddle"> - only
the diÔ¨Äerence between them (i.e.¬†unconsumed market resources or ‚Äòassets‚Äô <img 
src="SolvingMicroDSOPs42x.svg" alt="a
 t  " class="math";align="absmiddle">)
matters. It is therefore possible (and will turn out to be convenient) to deÔ¨Åne a
function<span class="footnote-mark"><a 
href="SolvingMicroDSOPs9.html#fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-4006f8"></a>  
  <table 
class="equation"><tr><td><a 
 id="x1-4007r9"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs43x.svg" alt="ùî≥t(at) = ùîºt[Œ≤Œì 1t‚àí+1œÅvt+1(‚Ñõt+1at + ùúÉt+1)]
" class="math-display" ></center></td><td class="equation-label">(9)</td></tr></table>
<!--l. 3--><p class="nopar" >
that returns the expected <img 
src="SolvingMicroDSOPs44x.svg" alt="t + 1  " class="math";align="absmiddle"> value associated with ending period <img 
src="SolvingMicroDSOPs45x.svg" alt="t  " class="math";align="absmiddle"> with any given
amount of  assets. This deÔ¨Ånition implies that
  <table 
class="equation"><tr><td><a 
 id="x1-4008r10"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs46x.svg" alt="ùî≥‚Ä≤(a ) = ùîº [Œ≤R Œì ‚àí œÅv‚Ä≤ (‚Ñõ    a + ùúÉ   )]
 t  t     t    t+1 t+1   t+1  t   t+1
" class="math-display" ></center></td><td class="equation-label">(10)</td></tr></table>
                                                                                     
                                                                                     
<!--l. 420--><p class="nopar" >
or, substituting from equation (<a 
href="#x1-4004r7">7<!--tex4ht:ref: eq:upctp1EqVpxtp1 --></a>),
  <table 
class="equation"><tr><td><a 
 id="x1-4009r11"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs47x.svg" alt=" ‚Ä≤         [    ‚àíœÅ  ‚Ä≤                    ]
ùî≥t(at) = ùîºt  Œ≤R Œìt+1u (ct+1 (‚Ñõt+1at + ùúÉt+1 ))  .
" class="math-display" ></center></td><td class="equation-label">(11)</td></tr></table>
<!--l. 424--><p class="nopar" >
Finally, note for future use that the Ô¨Årst order condition (<a 
href="#x1-4001r4">5<!--tex4ht:ref: eq:upceqEvtp1 --></a>) can now be rewritten as
  <table 
class="equation"><tr><td><a 
 id="x1-4010r12"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs48x.svg" alt="u‚Ä≤(c) = ùî≥‚Ä≤(m  ‚àí c ).
   t     t   t   t
" class="math-display" ></center></td><td class="equation-label">(12)</td></tr></table>
<!--l. 4--><p class="nopar" >
<!--l. 436--><p class="indent" >  <a 
 id="Solving-the-Next-To-Last-Period"></a>
  <h3 class="sectionHead"><span class="titlemark">5  </span> <a 
 id="x1-50005"></a>Solving the Next-to-Last Period</h3>
<!--l. 439--><p class="noindent" >The problem in the second-to-last period of life is:
  <table 
class="equation-star"><tr><td>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs49x.svg" alt="v   (m     ) = max  u (c   ) + Œ≤ ùîº   [Œì 1‚àíœÅv ((m     ‚àí c   )‚Ñõ   + ùúÉ  )] ,
 T‚àí1   T‚àí 1    cT‚àí1      T‚àí1       T‚àí1   T   T    T‚àí1    T‚àí 1  T    T
" class="math-display" ></center></td></tr></table>
<!--l. 443--><p class="nopar" >
and using (1) the fact that <img 
src="SolvingMicroDSOPs50x.svg" alt="vT =  u(c)  " class="math";align="absmiddle">; (2) the deÔ¨Ånition of <img 
src="SolvingMicroDSOPs51x.svg" alt="u(c)  " class="math";align="absmiddle">; (3) the deÔ¨Ånition of the
expectations operator, and (4) the fact that <img 
src="SolvingMicroDSOPs52x.svg" alt="Œì T  " class="math";align="absmiddle"> is nonstochastic, this becomes
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs53x.svg" alt="                                   ‚à´
                     c1T‚àí‚àíœÅ1      1‚àíœÅ   ‚àû ((mT ‚àí 1 ‚àí cT‚àí 1)‚ÑõT + ùúÉ)1‚àíœÅ
vT‚àí1(mT ‚àí 1) = macx    1 ‚àí-œÅ-+ Œ≤ŒìT       -----------1 ‚àí-œÅ---------- d‚Ñ± (ùúÉ )
               T‚àí1                  0
" class="math-display" ></center></td></tr></table>
<!--l. 453--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs54x.svg" alt="‚Ñ± " class="math";align="absmiddle"> is the cumulative distribution function for <img 
src="SolvingMicroDSOPs55x.svg" alt="ùúÉ  " class="math";align="absmiddle">.
<!--l. 456--><p class="indent" >  In principle, the maximization implicitly deÔ¨Ånes a function  <img 
src="SolvingMicroDSOPs56x.svg" alt="cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> that yields
optimal consumption in period <img 
src="SolvingMicroDSOPs57x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> for any given level of resources <img 
src="SolvingMicroDSOPs58x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">. Unfortunately,
however, there is no general analytical solution to this maximization problem, and so for any
given <img 
src="SolvingMicroDSOPs59x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> we must use numerical computational tools to Ô¨Ånd the <img 
src="SolvingMicroDSOPs60x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> that maximizes
the expression. This is excruciatingly slow because for every potential <img 
src="SolvingMicroDSOPs61x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> to be
considered, the integral must be calculated numerically, and numerical integration is <span 
class="ecti-1200">very</span>
slow.
<!--l. 466--><p class="indent" >  <a 
 id="Discretizing-the-Distribution"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.1  </span> <a 
 id="x1-60005.1"></a>Discretizing the Distribution</h4>
<!--l. 468--><p class="noindent" >Our Ô¨Årst time-saving step is therefore to construct a discrete approximation to the lognormal
distribution that can be used in place of numerical integration. We calculate an <img 
src="SolvingMicroDSOPs62x.svg" alt="n  " class="math";align="absmiddle">-point
approximation as follows.
<!--l. 476--><p class="indent" >  DeÔ¨Åne a set of points from <img 
src="SolvingMicroDSOPs63x.svg" alt="‚ôØ0   " class="math";align="absmiddle"> to <img 
src="SolvingMicroDSOPs64x.svg" alt="‚ôØn
  ùúÉ   " class="math";align="absmiddle"> on the <img 
src="SolvingMicroDSOPs65x.svg" alt="[0,1]  " class="math";align="absmiddle"> interval as the elements of the set
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs66x.svg" alt="‚ôØ = {0,1 ‚àïn,2‚àïn, ...,1} " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs10.html#fn9x0"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-6001f9"></a>  
Call the inverse of the <img 
src="SolvingMicroDSOPs68x.svg" alt="ùúÉ  " class="math";align="absmiddle"> distribution <img 
src="SolvingMicroDSOPs69x.svg" alt="  ‚àí1
‚Ñ±   " class="math";align="absmiddle">, and deÔ¨Åne the points <img 
src="SolvingMicroDSOPs70x.svg" alt=" ‚àí1     ‚àí1
‚ôØi  = ‚Ñ±   (‚ôØi)  " class="math";align="absmiddle">. Then the
conditional mean of <img 
src="SolvingMicroDSOPs71x.svg" alt="ùúÉ  " class="math";align="absmiddle"> in each of the intervals numbered 1 to <img 
src="SolvingMicroDSOPs72x.svg" alt="n  " class="math";align="absmiddle"> is:
  <table 
class="equation"><tr><td><a 
 id="x1-6002r13"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs73x.svg" alt="                          ‚à´  ‚ôØ‚àí1
ùúÉ  ‚â° ùîº[ùúÉ|‚ôØ‚àí1 ‚â§ ùúÉ &#x003C;  ‚ôØ‚àí 1] =   i  ùúó d‚Ñ± (ùúó).
 i        i‚àí 1       i       ‚ôØ‚àí1
                            i‚àí1
" class="math-display" ></center></td><td class="equation-label">(13)</td></tr></table>
<!--l. 482--><p class="nopar" >
<!--l. 484--><p class="indent" >  The method is illustrated in Figure¬†<a 
href="#x1-60041">1<!--tex4ht:ref: fig:discreteapprox --></a>. The solid continuous curve represents the ‚Äútrue‚Äù CDF
<img 
src="SolvingMicroDSOPs74x.svg" alt="‚Ñ±  (ùúÉ)  " class="math";align="absmiddle"> for a lognormal distribution such that <img 
src="SolvingMicroDSOPs75x.svg" alt="ùîº[ùúÉ] = 1  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs76x.svg" alt="œÉùúÉ = 0.1  " class="math";align="absmiddle">. The short vertical line
segments represent the <img 
src="SolvingMicroDSOPs77x.svg" alt="n ùúÉ  " class="math";align="absmiddle"> equiprobable values of <img 
src="SolvingMicroDSOPs78x.svg" alt="ùúÉi  " class="math";align="absmiddle"> which are used to approximate this
distribution.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs11.html#fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-6003f10"></a>  
<a 
 id="discreteApprox"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-60041"></a>
                                                                                     
                                                                                     
<!--l. 3--><p class="noindent" > <img 
src="./Figures/discreteApprox.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†1:</span><span  
class="content">Discrete Approximation to Lognormal Distribution <img 
src="SolvingMicroDSOPs79x.svg" alt="‚Ñ± " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-60041 -->
                                                                                     
                                                                                     
  </div>
<!--l. 501--><p class="indent" >  Recalling our deÔ¨Ånition of <img 
src="SolvingMicroDSOPs80x.svg" alt="ùî≥t(at)  " class="math";align="absmiddle">, for <img 
src="SolvingMicroDSOPs81x.svg" alt="t = T ‚àí  1  " class="math";align="absmiddle">
  <table 
class="equation"><tr><td><a 
 id="x1-6005r14"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs82x.svg" alt="                    (   )  nùúÉ               1‚àíœÅ
                1‚àí œÅ  1-- ‚àë   (‚ÑõT-aT-‚àí1 +-ùúÉi)---
ùî≥T‚àí 1(aT ‚àí1) = Œ≤ŒìT     nùúÉ            1 ‚àí œÅ
                           i=1
" class="math-display" ></center></td><td class="equation-label">(14)</td></tr></table>
<!--l. 3--><p class="nopar" >
so we can rewrite the maximization problem as
  <table 
class="equation"><tr><td><a 
 id="x1-6006r15"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs83x.svg" alt="                   {                            }
                     -c1T‚àí‚àíœÅ1-
vT ‚àí1(mT ‚àí1) = mcaTx‚àí1  1 ‚àí œÅ + ùî≥T ‚àí1(mT ‚àí1 ‚àí cT‚àí1)  .
" class="math-display" ></center></td><td class="equation-label">(15)</td></tr></table>
<!--l. 8--><p class="nopar" >
  <h4 class="subsectionHead"><span class="titlemark">5.2  </span> <a 
 id="x1-70005.2"></a>The Approximate Consumption and Value Functions</h4>
<!--l. 523--><p class="noindent" >Given a particular value of <img 
src="SolvingMicroDSOPs84x.svg" alt="mT ‚àí1   " class="math";align="absmiddle">, a numerical maximization routine can now Ô¨Ånd the <img 
src="SolvingMicroDSOPs85x.svg" alt="cT‚àí1   " class="math";align="absmiddle">
that maximizes (<a 
href="#x1-6006r15">15<!--tex4ht:ref: eq:vEndTm1 --></a>) in a reasonable amount of time. The <span 
class="ecti-1200">Mathematica </span>program that solves
exactly this problem is called <span 
class="ectt-1200">2period.m</span>. (The archive also contains parallel Matlab programs,
but these notes will dwell on the speciÔ¨Åcs of the <span 
class="ecti-1200">Mathematica </span>implementation, which is
superior in many respects.)
                                                                                     
                                                                                     
<!--l. 530--><p class="indent" >  The Ô¨Årst thing <span 
class="ectt-1200">2period.m </span>does is to read in the Ô¨Åle <span 
class="ectt-1200">functions.m </span>which contains
deÔ¨Ånitions of the consumption and value functions; <span 
class="ectt-1200">functions.m </span>also deÔ¨Ånes the function
<span 
class="ectt-1200">SolveAnotherPeriod </span>which, given the existence in memory of a solution for period <img 
src="SolvingMicroDSOPs86x.svg" alt="t + 1  " class="math";align="absmiddle">,
solves for period <img 
src="SolvingMicroDSOPs87x.svg" alt="t  " class="math";align="absmiddle">.
<!--l. 536--><p class="indent" >  The next step is to run the programs <span 
class="ectt-1200">setup_params.m</span>, <span 
class="ectt-1200">setup_grids.m</span>, <span 
class="ectt-1200">setup_shocks.m</span>,
respectively. <span 
class="ectt-1200">setup_params.m </span>sets values for the parameter values like the coeÔ¨Écient of
relative risk aversion. <span 
class="ectt-1200">setup_shocks.m </span>calculates the values for the <img 
src="SolvingMicroDSOPs88x.svg" alt="ùúÉi  " class="math";align="absmiddle"> deÔ¨Åned above (and
puts those values, and the (identical) probability associated with each of them, in the vector
variables <img 
src="SolvingMicroDSOPs89x.svg" alt="ùúÉ   " class="math";align="absmiddle"><span 
class="ectt-1200">Vals </span>and <img 
src="SolvingMicroDSOPs90x.svg" alt="ùúÉ   " class="math";align="absmiddle"><span 
class="ectt-1200">Prob</span>). Finally, <span 
class="ectt-1200">setup_grids.m </span>constructs a list of potential values
of cash-on-hand and saving, then puts them in the vector variables <span 
class="ectt-1200">mVec </span>= <span 
class="ectt-1200">aVec </span>=
<img 
src="SolvingMicroDSOPs91x.svg" alt="{0, 1,2,3,4} " class="math";align="absmiddle"> respectively. Then <span 
class="ectt-1200">2period.m </span>runs the program <span 
class="ectt-1200">setup_lastperiod.m </span>which
deÔ¨Ånes the elements necessary to determine behavior in the last period, in which <img 
src="SolvingMicroDSOPs92x.svg" alt="cT(m ) = m  " class="math";align="absmiddle">
and <img 
src="SolvingMicroDSOPs93x.svg" alt="vT(m ) = u(m )  " class="math";align="absmiddle">.
<!--l. 550--><p class="indent" >  After all the setup, the only remaining step in <span 
class="ectt-1200">2period.m </span>is to invoke <span 
class="ectt-1200">SolveAnotherPeriod</span>,
which constructs the solution for period <img 
src="SolvingMicroDSOPs94x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> given the presence of the solution for period
<img 
src="SolvingMicroDSOPs95x.svg" alt="T  " class="math";align="absmiddle"> (constructed by <span 
class="ectt-1200">setup_lastperiod.m</span>).
<!--l. 555--><p class="indent" >  Because we will always be comparing our solution to the perfect foresight solution, we also
construct the variables required to characterize the perfect foresight consumption function in
periods prior to <img 
src="SolvingMicroDSOPs96x.svg" alt="T  " class="math";align="absmiddle">. In particular, we construct the list <span 
class="ectt-1200">yExpPDV </span>(which contains the PDV of
expected income ‚Äì ‚Äòexpected human wealth‚Äô), and <span 
class="ectt-1200">yMinPDV </span>which contains the minimum possible
discounted value of future income at the beginning of period <img 
src="SolvingMicroDSOPs97x.svg" alt="T ‚àí  1  " class="math";align="absmiddle"> (‚Äòminimum human
wealth‚Äô).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs12.html#fn11x0"><sup class="textsuperscript">11</sup></a></span><a 
 id="x1-7001f11"></a>  
<!--l. 566--><p class="indent" >  The perfect foresight consumption function is also constructed (<span 
class="ectt-1200">setup_PerfectForesightSolution.m</span>).
This program uses the fact that, in <span 
class="ecti-1200">Mathematica</span>, functions can be saved as objects using the
commands <span 
class="ectt-1200"># </span>and <span 
class="ectt-1200">&#x0026;</span>. The <span 
class="ectt-1200"># </span>denotes the argument of the function, while the <span 
class="ectt-1200">&#x0026;</span>, placed at the end
of the function, tells <span 
class="ecti-1200">Mathematica </span>that the function should be saved as an object. In the
program, the last period perfect foresight consumption function is saved as an element in the
list <img 
src="SolvingMicroDSOPs98x.svg" alt="c–≥   " class="math";align="absmiddle">  <span 
class="ectt-1200">= {(# - 1 + Last[yExpPDV]) Last[</span><img 
src="SolvingMicroDSOPs99x.svg" alt="Œ∫   " class="math";align="absmiddle"><span 
class="ectt-1200">Min] &#x0026;}</span>, where <span 
class="ectt-1200">Last[yExpPDV]</span>
gives the just-constructed PDV of human wealth at the beginning of <img 
src="SolvingMicroDSOPs100x.svg" alt="T  " class="math";align="absmiddle"> (equal to
1, since current income is included in <img 
src="SolvingMicroDSOPs101x.svg" alt="hT  " class="math";align="absmiddle">), and <span 
class="ectt-1200">Last[</span><img 
src="SolvingMicroDSOPs102x.svg" alt="Œ∫   " class="math";align="absmiddle"><span 
class="ectt-1200">Min] </span>gives the perfect
foresight marginal propensity to consume (equal to 1, since it is optimal to spend all
resources in the last period). Since <span 
class="ectt-1200"># </span>in the code stands in for what was called <img 
src="SolvingMicroDSOPs103x.svg" alt="m  " class="math";align="absmiddle"> in
the model, the discounted total wealth is decomposed into discounted non-human
wealth <span 
class="ectt-1200"># - 1 </span>and discounted human wealth <span 
class="ectt-1200">Last[yExpPDV]</span>. The resulting formula
then corresponds to <img 
src="SolvingMicroDSOPs104x.svg" alt="¬ØcT = (mT ‚àí  1 + hT)Œ∫T  " class="math";align="absmiddle">, which translates to <img 
src="SolvingMicroDSOPs105x.svg" alt="¬ØcT = mT  " class="math";align="absmiddle"> for
<img 
src="SolvingMicroDSOPs106x.svg" alt="hT =  Œ∫T = 1  " class="math";align="absmiddle">.
<!--l. 587--><p class="indent" >  The inÔ¨Ånite horizon perfect foresight marginal propensity to save
  <table 
class="equation"><tr><td><a 
 id="x1-7002r16"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs107x.svg" alt="              1‚àïœÅ
Œª = (1‚àïR )(RŒ≤ )
" class="math-display" ></center></td><td class="equation-label">(16)</td></tr></table>
<!--l. 590--><p class="nopar" >
is also deÔ¨Åned because it will be useful in a number of
derivations.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs13.html#fn12x0"><sup class="textsuperscript">12</sup></a></span><a 
 id="x1-7003f12"></a>  
<!--l. 594--><p class="indent" >  The program then constructs behavior for one iteration back from the last period of life by
using the function <span 
class="ectt-1200">AddNewPeriodToParamLifeDates</span>. Using the <span 
class="ecti-1200">Mathematica</span>¬†command
<span 
class="ectt-1200">AppendTo</span>, various existing lists (which characterized the solution for period <img 
src="SolvingMicroDSOPs108x.svg" alt="T  " class="math";align="absmiddle">) are redeÔ¨Åned
to include an additional element representing the relevant formulas in the second to last period
of life. For example, <img 
src="SolvingMicroDSOPs109x.svg" alt="Œ∫   " class="math";align="absmiddle"><span 
class="ectt-1200">Min </span>now has two elements. The second element, given by <span 
class="ectt-1200">1/(1 +</span>
<span 
class="ectt-1200">Last[</span><img 
src="SolvingMicroDSOPs110x.svg" alt="Œª   " class="math";align="absmiddle"><span 
class="ectt-1200">]/Last[</span><img 
src="SolvingMicroDSOPs111x.svg" alt="Œ∫   " class="math";align="absmiddle"><span 
class="ectt-1200">Min])</span>, is the perfect foresight marginal propensity to consume in
<img 
src="SolvingMicroDSOPs112x.svg" alt="t = T ‚àí 1  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs14.html#fn13x0"><sup class="textsuperscript">13</sup></a></span><a 
 id="x1-7004f13"></a>  
<!--l. 606--><p class="indent" >  Next, the program deÔ¨Ånes a function <img 
src="SolvingMicroDSOPs113x.svg" alt="ùî≥   " class="math";align="absmiddle"><span 
class="ectt-1200">[at_] </span>(in <span 
class="ectt-1200">functions_stable.m</span>) which  is the
exact implementation of (<a 
href="#x1-4007r9">9<!--tex4ht:ref: eq:vEndtdefn --></a>): It returns the expectation of the value of behaving
optimally in period <img 
src="SolvingMicroDSOPs114x.svg" alt="T  " class="math";align="absmiddle"> given any speciÔ¨Åc amount of assets at the end of <img 
src="SolvingMicroDSOPs115x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">,
<img 
src="SolvingMicroDSOPs116x.svg" alt="aT ‚àí1   " class="math";align="absmiddle">.
<!--l. 614--><p class="indent" >  The heart of the program is the next expression (in <span 
class="ectt-1200">functions.m</span>). This expression loops
over the values of the variable <span 
class="ectt-1200">mVec</span>, solving the maximization problem (given in equation
(<a 
href="#x1-6006r15">15<!--tex4ht:ref: eq:vEndTm1 --></a>)):
  <table 
class="equation"><tr><td><a 
 id="x1-7005r17"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs117x.svg" alt="max   u[c ] + ùî≥ [mVec [[i]]- c]
  c
" class="math-display" ></center></td><td class="equation-label">(17)</td></tr></table>
                                                                                     
                                                                                     
<!--l. 622--><p class="nopar" >
for each of the <img 
src="SolvingMicroDSOPs118x.svg" alt="i  " class="math";align="absmiddle"> values of <span 
class="ectt-1200">mVec </span>(henceforth let‚Äôs call these points <img 
src="SolvingMicroDSOPs119x.svg" alt="mT ‚àí1,i  " class="math";align="absmiddle">).  The
maximization routine returns two values: the maximized value, and the value of <img 
src="SolvingMicroDSOPs120x.svg" alt="c  " class="math";align="absmiddle"> which
yields that maximized value. When the loop (the <span 
class="ectt-1200">Table </span>command) is Ô¨Ånished, the variable
<span 
class="ectt-1200">vAndcList </span>contains two lists, one with the values <img 
src="SolvingMicroDSOPs121x.svg" alt="vT‚àí 1,i  " class="math";align="absmiddle"> and the other with the consumption
levels <img 
src="SolvingMicroDSOPs122x.svg" alt="cT‚àí 1,i  " class="math";align="absmiddle"> associated with the <img 
src="SolvingMicroDSOPs123x.svg" alt="mT ‚àí 1,i  " class="math";align="absmiddle">.
  <h4 class="subsectionHead"><span class="titlemark">5.3  </span> <a 
 id="x1-80005.3"></a>An Interpolated Consumption Function</h4>
<!--l. 640--><p class="noindent" >Now we use the Ô¨Årst of the really convenient built-in features of  <span 
class="ecti-1200">Mathematica</span>. Given a set of
points on a function (in this case, the consumption function <img 
src="SolvingMicroDSOPs124x.svg" alt="c   (m )
 T‚àí1  " class="math";align="absmiddle">), <span 
class="ecti-1200">Mathematica</span>¬†can
create an object called an <span 
class="ectt-1200">InterpolatingFunction </span>which when applied to an input <img 
src="SolvingMicroDSOPs125x.svg" alt="m  " class="math";align="absmiddle"> will
yield the value of <img 
src="SolvingMicroDSOPs126x.svg" alt="c  " class="math";align="absmiddle"> that corresponds to a linear interpolation of the value of <img 
src="SolvingMicroDSOPs127x.svg" alt="c  " class="math";align="absmiddle"> from the
points in the <span 
class="ectt-1200">InterpolatingFunction </span>object. We can therefore deÔ¨Åne an approximation to
the consumption function <img 
src="SolvingMicroDSOPs128x.svg" alt="`cT‚àí1(mT ‚àí 1)  " class="math";align="absmiddle"> which, when called with an <img 
src="SolvingMicroDSOPs129x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> that is equal to
one of the points in <span 
class="ectt-1200">mVec[[i]] </span>returns the associated value of <img 
src="SolvingMicroDSOPs130x.svg" alt="c
 T‚àí1,i  " class="math";align="absmiddle">, and when called with a
value of <img 
src="SolvingMicroDSOPs131x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> that is not exactly equal to one of the <span 
class="ectt-1200">mVec[[i]]</span>, returns the value of
<img 
src="SolvingMicroDSOPs132x.svg" alt="c  " class="math";align="absmiddle"> that reÔ¨Çects a linear interpolation between the <img 
src="SolvingMicroDSOPs133x.svg" alt="cT‚àí1,i  " class="math";align="absmiddle"> associated with the two
<span 
class="ectt-1200">mVec[[i]] </span>points nearest to <img 
src="SolvingMicroDSOPs134x.svg" alt="mT ‚àí1   " class="math";align="absmiddle">. Thus if the function is called with <img 
src="SolvingMicroDSOPs135x.svg" alt="mT ‚àí1 = 1.75  " class="math";align="absmiddle">
and the nearest gridpoints  are <img 
src="SolvingMicroDSOPs136x.svg" alt="mj,T‚àí1 = 1  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs137x.svg" alt="mk,T‚àí 1 = 2  " class="math";align="absmiddle"> then the value of
<img 
src="SolvingMicroDSOPs138x.svg" alt="c
 T‚àí 1   " class="math";align="absmiddle"> returned by the function would be <img 
src="SolvingMicroDSOPs139x.svg" alt="(0.25c     + 0.75c     )
      j,T‚àí 1       k,T‚àí1  " class="math";align="absmiddle">. We can deÔ¨Åne a
numerical approximation to the value function <img 
src="SolvingMicroDSOPs140x.svg" alt="`vT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> in an exactly analogous
way.
<!--l. 668--><p class="indent" >  Figures <a 
href="#x1-80022">2<!--tex4ht:ref: fig:PlotcTm1Simple --></a> and¬†<a 
href="#x1-80033">3<!--tex4ht:ref: fig:PlotVTm1Simple --></a> show plots of the <img 
src="SolvingMicroDSOPs141x.svg" alt="`cT‚àí1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs142x.svg" alt="`vT‚àí1   " class="math";align="absmiddle"> <span 
class="ectt-1200">InterpolatingFunctions </span>that are generated
by the program <span 
class="ectt-1200">2PeriodInt.m</span>. While the <img 
src="SolvingMicroDSOPs143x.svg" alt="`cT‚àí1   " class="math";align="absmiddle"> function looks very smooth, the fact that the
<img 
src="SolvingMicroDSOPs144x.svg" alt="`vT ‚àí1   " class="math";align="absmiddle"> function is a set of line segments is very evident. This Ô¨Ågure provides the beginning of
the intuition for why trying to approximate the value function directly is a bad idea (in this
context).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs15.html#fn14x0"><sup class="textsuperscript">14</sup></a></span><a 
 id="x1-8001f14"></a>  
<!--l. 680--><p class="indent" >  <a 
 id="PlotcTm1Simple"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-80022"></a>
                                                                                     
                                                                                     
<!--l. 682--><p class="noindent" > <img 
src="./Figures/PlotcTm1Simple.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†2:</span><span  
class="content"><img 
src="SolvingMicroDSOPs145x.svg" alt="cT ‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs146x.svg" alt="`cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-80022 -->
                                                                                     
                                                                                     
  </div>
<!--l. 687--><p class="indent" >  <a 
 id="PlotvTm1Simple"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-80033"></a>
                                                                                     
                                                                                     
<!--l. 689--><p class="noindent" > <img 
src="./Figures/PlotVTm1Simple.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†3:</span><span  
class="content"><img 
src="SolvingMicroDSOPs147x.svg" alt="vT ‚àí1   " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs148x.svg" alt="`vT‚àí 1(mT ‚àí 1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-80033 -->
                                                                                     
                                                                                     
  </div>
<!--l. 694--><p class="indent" >  <a 
 id="Interpolating-Expectations"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.4  </span> <a 
 id="x1-90005.4"></a>Interpolating Expectations</h4>
<!--l. 699--><p class="noindent" ><span 
class="ectt-1200">2period.m </span>works well in the sense that it generates a good approximation to the true optimal
consumption function. However, there is a clear ineÔ¨Éciency in the program: Since it uses
equation (<a 
href="#x1-6006r15">15<!--tex4ht:ref: eq:vEndTm1 --></a>), for every value of <img 
src="SolvingMicroDSOPs149x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle"> the program must calculate the utility consequences of
various possible choices of <img 
src="SolvingMicroDSOPs150x.svg" alt="cT ‚àí1   " class="math";align="absmiddle"> as it searches for the best choice.  But for any given
value of <img 
src="SolvingMicroDSOPs151x.svg" alt="aT‚àí1   " class="math";align="absmiddle">, there is a good chance that the program may end up calculating the
corresponding <img 
src="SolvingMicroDSOPs152x.svg" alt="ùî≥  " class="math";align="absmiddle"> many times while maximizing utility from diÔ¨Äerent <img 
src="SolvingMicroDSOPs153x.svg" alt="m
  T‚àí1   " class="math";align="absmiddle">‚Äôs. For
example, it is possible that the program will calculate the value of ending the period
with <img 
src="SolvingMicroDSOPs154x.svg" alt="aT ‚àí1 = 0  " class="math";align="absmiddle"> dozens of times. It would be much more eÔ¨Écient if the program
could make that calculation once and then merely recall the value when it is needed
again.
<!--l. 716--><p class="indent" >  This can be achieved using the same interpolation technique used above to construct a
direct numerical approximation to the value function: DeÔ¨Åne a grid of possible values for
saving at time <img 
src="SolvingMicroDSOPs155x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs156x.svg" alt="‚ÉóaT ‚àí1   " class="math";align="absmiddle"> (<span 
class="ectt-1200">aVec </span>in <span 
class="ectt-1200">setup_grids.m</span>), designating the speciÔ¨Åc points
<img 
src="SolvingMicroDSOPs157x.svg" alt="aT ‚àí1,i  " class="math";align="absmiddle">; for each of these values of <img 
src="SolvingMicroDSOPs158x.svg" alt="aT ‚àí1,i  " class="math";align="absmiddle">, calculate the vector <img 
src="SolvingMicroDSOPs159x.svg" alt="‚Éóùî≥T‚àí1   " class="math";align="absmiddle"> as the collection of
points <img 
src="SolvingMicroDSOPs160x.svg" alt="ùî≥T‚àí 1,i = ùî≥T ‚àí1(aT‚àí1,i)  " class="math";align="absmiddle"> using equation (<a 
href="#x1-4007r9">9<!--tex4ht:ref: eq:vEndtdefn --></a>); then construct an <span 
class="ectt-1200">InterpolatingFunction</span>
object <img 
src="SolvingMicroDSOPs161x.svg" alt="`ùî≥   (a    )
 T‚àí 1  T‚àí1  " class="math";align="absmiddle"> from the list of points on the function captured in the <img 
src="SolvingMicroDSOPs162x.svg" alt="‚Éóa
 T ‚àí1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs163x.svg" alt="‚Éóùî≥
  T‚àí1   " class="math";align="absmiddle">
vectors.
<!--l. 730--><p class="indent" >  Thus, we are now interpolating for the function that reveals
the expected value of <span 
class="ecti-1200">ending </span>the period with a given amount of
assets.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs16.html#fn15x0"><sup class="textsuperscript">15</sup></a></span><a 
 id="x1-9001f15"></a>  
The program <span 
class="ectt-1200">2periodIntExp.m </span>solves this problem. Figure¬†<a 
href="#x1-90024">4<!--tex4ht:ref: fig:PlotOTm1RawVSInt --></a> compares the true value
function to the <span 
class="ectt-1200">InterpolatingFunction </span>approximation; the functions are of course identical
at the gridpoints chosen for <img 
src="SolvingMicroDSOPs164x.svg" alt="aT‚àí 1   " class="math";align="absmiddle"> and they appear reasonably close except in the region
below <img 
src="SolvingMicroDSOPs165x.svg" alt="mT ‚àí1 = 1  " class="math";align="absmiddle">.
<!--l. 742--><p class="indent" >  <a 
 id="PlotOTm1RawVSInt"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-90024"></a>
                                                                                     
                                                                                     
<!--l. 744--><p class="noindent" > <img 
src="./Figures/PlotOTm1RawVSInt.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†4:</span><span  
class="content">End-Of-Period Value <img 
src="SolvingMicroDSOPs166x.svg" alt="ùî≥T‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs167x.svg" alt="`ùî≥T ‚àí1(aT‚àí1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-90024 -->
                                                                                     
                                                                                     
  </div>
<!--l. 749--><p class="indent" >  <a 
 id="PlotComparecTm1AB"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-90035"></a>
                                                                                     
                                                                                     
<!--l. 751--><p class="noindent" > <img 
src="./Figures/PlotComparecTm1AB.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†5:</span><span  
class="content"><img 
src="SolvingMicroDSOPs168x.svg" alt="cT ‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs169x.svg" alt="`cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-90035 -->
                                                                                     
                                                                                     
  </div>
<!--l. 756--><p class="indent" >  Nevertheless, the resulting consumption rule obtained when <img 
src="SolvingMicroDSOPs170x.svg" alt="`ùî≥T‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> is used instead of
<img 
src="SolvingMicroDSOPs171x.svg" alt="ùî≥T ‚àí1(aT‚àí1)  " class="math";align="absmiddle"> is surprisingly bad, as shown in Ô¨Ågure <a 
href="#x1-90035">5<!--tex4ht:ref: fig:PlotComparecTm1AB --></a>. For example, when <img 
src="SolvingMicroDSOPs172x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> goes
from 2 to 3, <img 
src="SolvingMicroDSOPs173x.svg" alt="`c
 T‚àí1   " class="math";align="absmiddle"> goes from about 1 to about 2, yet when <img 
src="SolvingMicroDSOPs174x.svg" alt="m
  T ‚àí1   " class="math";align="absmiddle"> goes from 3 to
4, <img 
src="SolvingMicroDSOPs175x.svg" alt="`cT‚àí1   " class="math";align="absmiddle"> goes from about 2 to about 2.05. The function fails even to be strictly
concave, which is distressing because Carroll and Kimball¬†(<a 
href="#Xcarroll&kimball:concavity">1996</a>) prove that the correct
consumption function is strictly concave in a wide class of problems that includes this
problem.
<!--l. 769--><p class="indent" >  <a 
 id="Value-Function-versus-First-Order-Condition"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.5  </span> <a 
 id="x1-100005.5"></a>Value Function versus First Order Condition</h4>
<!--l. 772--><p class="noindent" >Loosely speaking, our diÔ¨Éculty reÔ¨Çects the fact that the consumption choice is governed by
the <span 
class="ecti-1200">marginal </span>value function, not by the <span 
class="ecti-1200">level </span>of the value function (which is the object that we
approximated). To understand this point, recall that a quadratic utility function exhibits risk
aversion because with a stochastic <img 
src="SolvingMicroDSOPs176x.svg" alt="c  " class="math";align="absmiddle">,
  <table 
class="equation"><tr><td><a 
 id="x1-10001r18"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs177x.svg" alt="ùîº [‚àí (c ‚àí /c)2] &#x003C; ‚àí (ùîº[c] ‚àí /c)2
" class="math-display" ></center></td><td class="equation-label">(18)</td></tr></table>
<!--l. 784--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs178x.svg" alt="/c  " class="math";align="absmiddle"> is the ‚Äòbliss point‚Äô. However, unlike the CRRA utility function, with quadratic utility
the consumption/saving <span 
class="ecti-1200">behavior </span>of consumers is unaÔ¨Äected by risk since behavior is
determined by the Ô¨Årst order condition, which depends on <span 
class="ecti-1200">marginal </span>utility, and when utility is
quadratic, marginal utility is unaÔ¨Äected by risk:
  <table 
class="equation"><tr><td><a 
 id="x1-10002r19"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs179x.svg" alt="ùîº[‚àí 2(c ‚àí /c)] = ‚àí 2(ùîº[c] ‚àí /c).
" class="math-display" ></center></td><td class="equation-label">(19)</td></tr></table>
<!--l. 792--><p class="nopar" >
<!--l. 794--><p class="indent" >  Intuitively, if one‚Äôs goal is to accurately capture choices that are governed by marginal
value, numerical techniques that approximate the <span 
class="ecti-1200">marginal </span>value function will yield a more
accurate approximation to optimal behavior than techniques that approximate the <span 
class="ecti-1200">level </span>of the
value function.
<!--l. 801--><p class="indent" >  The Ô¨Årst order condition of the maximization problem in period <img 
src="SolvingMicroDSOPs180x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> is:
  <table 
class="equation"><tr><td><a 
 id="x1-10003r20"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs181x.svg" alt=" ‚Ä≤                  ‚àíœÅ  ‚Ä≤
u (cT‚àí1) = Œ≤ ùîºT‚àí 1[Œì T Ru (cT)]
              (  1)  n‚àëùúÉ
    c‚àíTœÅ‚àí1 = RŒ≤   ---     Œì ‚àíTœÅ(R(mT ‚àí 1 ‚àí cT ‚àí1) + ùúÉi)‚àíœÅ.
                nùúÉ   i=1
" class="math-display" ></center></td><td class="equation-label">(20)</td></tr></table>
<!--l. 4--><p class="nopar" >
<a 
 id="PlotuPrimeVSOPrime"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100046"></a>
                                                                                     
                                                                                     
<!--l. 812--><p class="noindent" > <img 
src="./Figures/PlotuPrimeVSOPrime.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†6:</span><span  
class="content"><img 
src="SolvingMicroDSOPs182x.svg" alt="u ‚Ä≤(c)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs183x.svg" alt="ùî≥‚Ä≤T‚àí 1(3 ‚àí c),ùî≥‚Ä≤T‚àí 1(4 ‚àí c),`ùî≥‚Ä≤T ‚àí1(3 ‚àí c),`ùî≥‚Ä≤T ‚àí1(4 ‚àí c)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-100046 -->
                                                                                     
                                                                                     
  </div>
<!--l. 817--><p class="indent" >  The downward-sloping curve in Figure <a 
href="#x1-100046">6<!--tex4ht:ref: fig:PlotuPrimeVSOPrime --></a> shows the value of <img 
src="SolvingMicroDSOPs184x.svg" alt="c‚àíTœÅ‚àí1   " class="math";align="absmiddle"> for our baseline
parameter values for <img 
src="SolvingMicroDSOPs185x.svg" alt="0 ‚â§ cT‚àí 1 ‚â§ 4  " class="math";align="absmiddle"> (the horizontal axis). The solid upward-sloping curve
shows the value of the RHS of (<a 
href="#x1-10003r20">20<!--tex4ht:ref: eq:FOCTm1 --></a>) as a function of <img 
src="SolvingMicroDSOPs186x.svg" alt="c
 T ‚àí1   " class="math";align="absmiddle"> under the assumption that
<img 
src="SolvingMicroDSOPs187x.svg" alt="mT ‚àí 1 = 3  " class="math";align="absmiddle">. Constructing this Ô¨Ågure is rather time-consuming, because for every value of
<img 
src="SolvingMicroDSOPs188x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> plotted we must calculate the RHS of (<a 
href="#x1-10003r20">20<!--tex4ht:ref: eq:FOCTm1 --></a>). The value of <img 
src="SolvingMicroDSOPs189x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> for which the RHS and
LHS of (<a 
href="#x1-10003r20">20<!--tex4ht:ref: eq:FOCTm1 --></a>) are equal is the optimal level of consumption given that <img 
src="SolvingMicroDSOPs190x.svg" alt="mT ‚àí1 = 3  " class="math";align="absmiddle">, so the
intersection of the downward-sloping and the upward-sloping curves gives the optimal value of
<img 
src="SolvingMicroDSOPs191x.svg" alt="cT‚àí 1   " class="math";align="absmiddle">. As we can see, the two curves intersect just below <img 
src="SolvingMicroDSOPs192x.svg" alt="cT ‚àí1 = 2  " class="math";align="absmiddle">. Similarly, the
upward-sloping dashed curve shows the expected value of the RHS of (<a 
href="#x1-10003r20">20<!--tex4ht:ref: eq:FOCTm1 --></a>) under the
assumption that <img 
src="SolvingMicroDSOPs193x.svg" alt="mT ‚àí1 = 4  " class="math";align="absmiddle">, and the intersection of this curve with <img 
src="SolvingMicroDSOPs194x.svg" alt="u ‚Ä≤(cT‚àí1)  " class="math";align="absmiddle"> yields the
optimal level of consumption if <img 
src="SolvingMicroDSOPs195x.svg" alt="mT  ‚àí1 = 4  " class="math";align="absmiddle">. These two curves intersect slightly below
<img 
src="SolvingMicroDSOPs196x.svg" alt="cT‚àí 1 = 2.5  " class="math";align="absmiddle">. Thus, increasing <img 
src="SolvingMicroDSOPs197x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> from 3 to 4 increases optimal consumption by about
0.5.
<!--l. 838--><p class="indent" >  Now consider the derivative of our function <img 
src="SolvingMicroDSOPs198x.svg" alt="`ùî≥T‚àí1(aT‚àí 1)  " class="math";align="absmiddle">. Because we have constructed
<img 
src="SolvingMicroDSOPs199x.svg" alt="`ùî≥T ‚àí1   " class="math";align="absmiddle"> as a linear interpolation, the slope of <img 
src="SolvingMicroDSOPs200x.svg" alt="`ùî≥T‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> between any two adjacent points
<img 
src="SolvingMicroDSOPs201x.svg" alt="{aT ‚àí1,i,ai+1,T‚àí 1} " class="math";align="absmiddle"> is constant. The level of the slope immediately below any particular
gridpoint is diÔ¨Äerent, of course, from the slope above that gridpoint, a fact which implies that
the derivative of <img 
src="SolvingMicroDSOPs202x.svg" alt="`ùî≥T‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> follows a step function.
<!--l. 848--><p class="indent" >  The solid-line step function in Figure <a 
href="#x1-100046">6<!--tex4ht:ref: fig:PlotuPrimeVSOPrime --></a> depicts the actual value of <img 
src="SolvingMicroDSOPs203x.svg" alt=" ‚Ä≤
`ùî≥T‚àí1(3 ‚àí cT‚àí1)  " class="math";align="absmiddle">. When
we attempt to Ô¨Ånd optimal values of <img 
src="SolvingMicroDSOPs204x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> given <img 
src="SolvingMicroDSOPs205x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> using <img 
src="SolvingMicroDSOPs206x.svg" alt="`ùî≥T ‚àí1(aT‚àí1)  " class="math";align="absmiddle">, the numerical
optimization routine will return the <img 
src="SolvingMicroDSOPs207x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> for which <img 
src="SolvingMicroDSOPs208x.svg" alt="u‚Ä≤(cT‚àí1) = `ùî≥‚Ä≤T‚àí 1(mT ‚àí 1 ‚àí cT ‚àí1)  " class="math";align="absmiddle">. Thus,
for <img 
src="SolvingMicroDSOPs209x.svg" alt="m     = 3
  T‚àí1  " class="math";align="absmiddle"> the program will return the value of <img 
src="SolvingMicroDSOPs210x.svg" alt="c
 T‚àí 1   " class="math";align="absmiddle"> for which the downward-sloping
<img 
src="SolvingMicroDSOPs211x.svg" alt="  ‚Ä≤
u (cT‚àí1)  " class="math";align="absmiddle"> curve intersects with the <img 
src="SolvingMicroDSOPs212x.svg" alt=" ‚Ä≤
`ùî≥T‚àí 1(3 ‚àí cT ‚àí1)  " class="math";align="absmiddle">; as the diagram shows, this value is
exactly equal to 2. Similarly, if we ask the routine to Ô¨Ånd the optimal <img 
src="SolvingMicroDSOPs213x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs214x.svg" alt="mT  ‚àí1 = 4  " class="math";align="absmiddle">, it
Ô¨Ånds the point of intersection of <img 
src="SolvingMicroDSOPs215x.svg" alt="u ‚Ä≤(cT‚àí1)  " class="math";align="absmiddle"> with <img 
src="SolvingMicroDSOPs216x.svg" alt="`ùî≥ ‚Ä≤T‚àí1(4 ‚àí cT‚àí1)  " class="math";align="absmiddle">; and as the diagram shows,
this intersection is only slightly above 2. Hence, this Ô¨Ågure illustrates why the numerical
consumption function plotted earlier returned values very close to <img 
src="SolvingMicroDSOPs217x.svg" alt="c    = 2
 T‚àí1  " class="math";align="absmiddle"> for both
<img 
src="SolvingMicroDSOPs218x.svg" alt="mT ‚àí 1 = 3  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs219x.svg" alt="mT ‚àí 1 = 4  " class="math";align="absmiddle">.
<!--l. 867--><p class="indent" >  We would obviously obtain much better estimates of the point of intersection
between <img 
src="SolvingMicroDSOPs220x.svg" alt="u‚Ä≤(cT‚àí1)  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs221x.svg" alt="ùî≥ ‚Ä≤T‚àí1(mT ‚àí1 ‚àí cT‚àí1)  " class="math";align="absmiddle"> if our estimate of <img 
src="SolvingMicroDSOPs222x.svg" alt="`ùî≥‚Ä≤T‚àí 1   " class="math";align="absmiddle"> were not a
step function. In fact, we already know how to construct linear interpolations to
functions, so the obvious next step is to construct a linear interpolating approximation
to the <span 
class="ecti-1200">expected marginal value of end-of-period assets function</span> <img 
src="SolvingMicroDSOPs223x.svg" alt=" ‚Ä≤
ùî≥ " class="math";align="absmiddle">. That is, we
calculate
  <table 
class="equation"><tr><td><a 
 id="x1-10005r21"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs224x.svg" alt="                     ( 1 ) ‚àënùúÉ
ùî≥‚Ä≤T ‚àí1(aT‚àí1) = Œ≤R Œì ‚àíTœÅ  ---     (‚ÑõT aT‚àí 1 + ùúÉi)‚àíœÅ
                       nùúÉ   i=1
" class="math-display" ></center></td><td class="equation-label">(21)</td></tr></table>
<!--l. 877--><p class="nopar" >
at the points in <span 
class="ectt-1200">aVec </span>yielding <img 
src="SolvingMicroDSOPs225x.svg" alt="          ‚Ä≤               ‚Ä≤
{{aT ‚àí1,1,ùî≥T ‚àí1,1},{aT ‚àí1,2,ùî≥T‚àí 1,2}...} " class="math";align="absmiddle"> and construct
<img 
src="SolvingMicroDSOPs226x.svg" alt="`ùî≥‚Ä≤T ‚àí1(aT‚àí1)  " class="math";align="absmiddle"> as the linear interpolating function that Ô¨Åts this set of points.
<!--l. 884--><p class="indent" >  <a 
></a>PlotOPRawVSFOC <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100067"></a>
                                                                                     
                                                                                     
<!--l. 886--><p class="noindent" > <img 
src="./Figures/PlotOPRawVSFOC.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†7:</span><span  
class="content"><img 
src="SolvingMicroDSOPs227x.svg" alt="ùî≥ ‚Ä≤T‚àí1(aT‚àí1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs228x.svg" alt="`ùî≥‚Ä≤T ‚àí1(aT‚àí1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-100067 -->
                                                                                     
                                                                                     
  </div>
<!--l. 892--><p class="indent" >  The program Ô¨Åle <span 
class="ectt-1200">functionsIntExpFOC.m </span>therefore uses the function <img 
src="SolvingMicroDSOPs229x.svg" alt="ùî≥   " class="math";align="absmiddle"><span 
class="ectt-1200">a[at_] </span>deÔ¨Åned
in <span 
class="ectt-1200">functions_stable.m </span>as the embodiment of equation¬†(<a 
href="#x1-10005r21">21<!--tex4ht:ref: eq:vEndPrimeTm1 --></a>), and constructs the
<span 
class="ectt-1200">InterpolatingFunction </span>as described above. The results are shown in Figure <a 
href="#x1-100067">7<!--tex4ht:ref: fig:PlotOPRawVSFOC --></a>. The linear
interpolating approximation looks roughly as good (or bad) for the <span 
class="ecti-1200">marginal </span>value function as
it was for the level of the value function. However, Figure <a 
href="#x1-100078">8<!--tex4ht:ref: fig:PlotcTm1ABC --></a> shows that the new consumption
function (long dashes) is a considerably better approximation of the true consumption
function (solid) than was the consumption function obtained by approximating the level of the
value function (short dashes).
<!--l. 906--><p class="indent" >  <a 
 id="PlotcTm1ABC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100078"></a>
                                                                                     
                                                                                     
<!--l. 908--><p class="noindent" > <img 
src="./Figures/PlotcTm1ABC.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†8:</span><span  
class="content"><img 
src="SolvingMicroDSOPs230x.svg" alt="cT ‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (solid) Versus Two Methods for Constructing <img 
src="SolvingMicroDSOPs231x.svg" alt="`cT‚àí1(mT ‚àí 1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-100078 -->
                                                                                     
                                                                                     
  </div>
<!--l. 913--><p class="indent" >  <a 
 id="Transformation"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.6  </span> <a 
 id="x1-110005.6"></a>Transformation</h4>
<!--l. 916--><p class="noindent" >Even the new-and-improved consumption function diverges notably from the true solution,
especially at lower values of <img 
src="SolvingMicroDSOPs232x.svg" alt="m  " class="math";align="absmiddle">. That is because the linear interpolation does an increasingly
poor job of capturing the nonlinearity of <img 
src="SolvingMicroDSOPs233x.svg" alt=" ‚Ä≤
ùî≥T‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> at lower and lower levels of
<img 
src="SolvingMicroDSOPs234x.svg" alt="a  " class="math";align="absmiddle">.
<!--l. 922--><p class="indent" >  This is where we unveil our next trick. To understand the logic, start by considering the
case where <img 
src="SolvingMicroDSOPs235x.svg" alt="‚Ñõ   =  Œ≤ = Œì  =  1
  T         T  " class="math";align="absmiddle"> and there is no uncertainty  (that is, we know for sure that
income next period will be <img 
src="SolvingMicroDSOPs236x.svg" alt="ùúÉT = 1  " class="math";align="absmiddle">). The Ô¨Ånal Euler equation is then:
  <table 
class="equation"><tr><td><a 
 id="x1-11001r22"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs237x.svg" alt="c‚àíœÅ  = c‚àí œÅ.
 T‚àí1    T
" class="math-display" ></center></td><td class="equation-label">(22)</td></tr></table>
<!--l. 930--><p class="nopar" >
<!--l. 932--><p class="indent" >  In the case we are now considering with no uncertainty and no liquidity constraints, the
optimizing consumer does not care whether a unit of income is scheduled to be received in the
future period <img 
src="SolvingMicroDSOPs238x.svg" alt="T  " class="math";align="absmiddle"> or the current period <img 
src="SolvingMicroDSOPs239x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">; there is perfect certainty that the income will
be received, so the consumer treats it as equivalent to a unit of current wealth. Total resources
therefore are comprised of two types: current market resources <img 
src="SolvingMicroDSOPs240x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> and ‚Äòhuman wealth‚Äô
(the PDV of future income) of <img 
src="SolvingMicroDSOPs241x.svg" alt="ùî•T‚àí1 = 1  " class="math";align="absmiddle"> (where we use the Gothic font to signify that this is
the expectation, as of the END of the period, of the income that will be received in future
periods; it does not include current income, which has already been incorporated into
<img 
src="SolvingMicroDSOPs242x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">).
<!--l. 945--><p class="indent" >  The optimal solution is to spend half of total lifetime resources in period <img 
src="SolvingMicroDSOPs243x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">
and the remainder in period <img 
src="SolvingMicroDSOPs244x.svg" alt="T  " class="math";align="absmiddle">. Since total resources are known with certainty
to be <img 
src="SolvingMicroDSOPs245x.svg" alt="mT ‚àí 1 + ùî•T ‚àí1 = mT ‚àí1 + 1  " class="math";align="absmiddle">, and since <img 
src="SolvingMicroDSOPs246x.svg" alt="v‚Ä≤  (mT ‚àí1) = u ‚Ä≤(cT‚àí1)
 T‚àí1  " class="math";align="absmiddle"> this implies
that
  <table 
class="equation"><tr><td><a 
 id="x1-11002r23"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs247x.svg" alt="               ( m    +  1) ‚àíœÅ
v‚Ä≤T ‚àí1(mT ‚àí1) =   --T‚àí1-----   .
                     2
" class="math-display" ></center></td><td class="equation-label">(23)</td></tr></table>
<!--l. 956--><p class="nopar" >
Of course, this is a highly nonlinear function. However, if we raise both sides of (<a 
href="#x1-11002r23">23<!--tex4ht:ref: eq:vPLin --></a>) to the
power <img 
src="SolvingMicroDSOPs248x.svg" alt="(‚àí 1 ‚àïœÅ)  " class="math";align="absmiddle"> the result is a linear function:
  <table 
class="equation"><tr><td><a 
 id="x1-11003r24"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs249x.svg" alt=" ‚Ä≤          ‚àí 1‚àïœÅ   mT-‚àí-1 +-1
vT‚àí 1(mT ‚àí 1)t     =     2     .
" class="math-display" ></center></td><td class="equation-label">(24)</td></tr></table>
<!--l. 962--><p class="nopar" >
This is a speciÔ¨Åc example of a general phenomenon: A theoretical literature cited in¬†<a 
href="#Xcarroll&kimball:concavity">Carroll
and Kimball</a>¬†(<a 
href="#Xcarroll&kimball:concavity">1996</a>) establishes that under perfect certainty, if the period-by-period marginal
utility function is of the form <img 
src="SolvingMicroDSOPs250x.svg" alt=" ‚àíœÅ
ct  " class="math";align="absmiddle">, the marginal value function will be of the form
<img 
src="SolvingMicroDSOPs251x.svg" alt="          ‚àíœÅ
(Œ≥mt  + Œ∂)  " class="math";align="absmiddle"> for some constants <img 
src="SolvingMicroDSOPs252x.svg" alt="{Œ≥, Œ∂} " class="math";align="absmiddle">. This means that if we were solving the perfect
foresight problem numerically, we could always calculate a numerically exact (because linear)
interpolation. To put this in intuitive terms, the problem we are facing is that the marginal
value function is highly nonlinear. But we have a compelling solution to that problem,
because the nonlinearity springs largely from the fact that we are raising something to
the power <img 
src="SolvingMicroDSOPs253x.svg" alt="‚àí  œÅ  " class="math";align="absmiddle">. In eÔ¨Äect, we can ‚Äòunwind‚Äô all of the nonlinearity owing to that
operation and the remaining nonlinearity will not be nearly so great. SpeciÔ¨Åcally,
applying the foregoing insights to the end-of-period value function <img 
src="SolvingMicroDSOPs254x.svg" alt="ùî≥T ‚àí1   " class="math";align="absmiddle">, we can
deÔ¨Åne
  <table 
class="equation"><tr><td><a 
 id="x1-11004r25"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs255x.svg" alt="               ‚Ä≤         ‚àí 1‚àïœÅ
ùî†T‚àí1(aT‚àí 1) ‚â° [ùî≥T‚àí 1(aT ‚àí1)]
" class="math-display" ></center></td><td class="equation-label">(25)</td></tr></table>
<!--l. 980--><p class="nopar" >
which would be linear in the perfect foresight case. Thus, our procedure is to calculate the
values of <img 
src="SolvingMicroDSOPs256x.svg" alt="ùî†T‚àí 1,i  " class="math";align="absmiddle"> at each of the <img 
src="SolvingMicroDSOPs257x.svg" alt="aT‚àí1,i  " class="math";align="absmiddle"> gridpoints, with the idea that we will construct <img 
src="SolvingMicroDSOPs258x.svg" alt="`ùî†T‚àí 1   " class="math";align="absmiddle">
as the interpolating function connecting these points.
<!--l. 989--><p class="indent" >  <a 
 id="The-Self-Imposed-Natural-Borrowing-Constraint-and-the-a-Lower-Bound"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.7  </span> <a 
 id="x1-120005.7"></a>The Self-Imposed ‚ÄòNatural‚Äô Borrowing Constraint and the <img 
src="SolvingMicroDSOPs259x.svg" alt="aT‚àí1   " class="math";align="absmiddle"> Lower Bound</h4>
<!--l. 993--><p class="noindent" >This is the appropriate moment to ask an awkward question that we have so far neglected:
How should a function like <img 
src="SolvingMicroDSOPs260x.svg" alt="`ùî†T‚àí 1   " class="math";align="absmiddle"> be evaluated outside the range of points spanned by
<img 
src="SolvingMicroDSOPs261x.svg" alt="{a     ,...,a     }
   T‚àí1,1     T‚àí 1,n " class="math";align="absmiddle"> for which we have calculated the corresponding <img 
src="SolvingMicroDSOPs262x.svg" alt="ùî†
 T ‚àí1,i  " class="math";align="absmiddle"> gridpoints
used to produce our linearly interpolating approximation <img 
src="SolvingMicroDSOPs263x.svg" alt="`ùî†T‚àí 1   " class="math";align="absmiddle"> (as described in
section¬†<a 
href="#x1-80005.3">5.3<!--tex4ht:ref: subsec:LinInterp --></a>)?
<!--l. 1000--><p class="indent" >  The natural answer would seem to be linear extrapolation; for example, we could
use
  <table 
class="equation"><tr><td><a 
 id="x1-12001r26"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs264x.svg" alt="`ùî†T‚àí 1(aT ‚àí1) = `ùî†T‚àí1(aT‚àí 1,1) + `ùî†aT‚àí 1(aT ‚àí1,1)(aT‚àí 1 ‚àí aT ‚àí1,1)
" class="math-display" ></center></td><td class="equation-label">(26)</td></tr></table>
<!--l. 1003--><p class="nopar" >
for values of <img 
src="SolvingMicroDSOPs265x.svg" alt="aT‚àí 1 &#x003C; aT‚àí1,1   " class="math";align="absmiddle">, where <img 
src="SolvingMicroDSOPs266x.svg" alt="`a
ùî†T‚àí1(aT‚àí1,1)  " class="math";align="absmiddle"> is the derivative of the <img 
src="SolvingMicroDSOPs267x.svg" alt="`
ùî†T‚àí1   " class="math";align="absmiddle">
function at the bottommost gridpoint (see below). Unfortunately, this approach
will lead us into diÔ¨Éculties. To see why, consider what happens to the true (not
approximated) <img 
src="SolvingMicroDSOPs268x.svg" alt="ùî≥T ‚àí1(aT‚àí1)  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs269x.svg" alt="aT‚àí 1   " class="math";align="absmiddle"> approaches the value <img 
src="SolvingMicroDSOPs270x.svg" alt="aT‚àí1 = ‚àí ùúÉ‚Ñõ ‚àíT1  " class="math";align="absmiddle">. From (<a 
href="#x1-10005r21">21<!--tex4ht:ref: eq:vEndPrimeTm1 --></a>) we
have
  <table 
class="equation"><tr><td><a 
 id="x1-12002r27"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs271x.svg" alt="                                      (   ) ‚àënùúÉ
   lim    ùî≥‚Ä≤T‚àí1(aT‚àí 1) =   lim    Œ≤R Œì ‚àíT œÅ 1--     (aT‚àí 1‚ÑõT + ùúÉi)‚àíœÅ .
aT‚àí1‚ÜìaT‚àí 1             aT‚àí1‚ÜìaT‚àí1         nùúÉ   i=1
" class="math-display" ></center></td><td class="equation-label">(27)</td></tr></table>
<!--l. 1013--><p class="nopar" >
<!--l. 1015--><p class="indent" >  But since <img 
src="SolvingMicroDSOPs272x.svg" alt="ùúÉ-=  ùúÉ1   " class="math";align="absmiddle">, exactly at <img 
src="SolvingMicroDSOPs273x.svg" alt="aT‚àí1 = aT ‚àí1   " class="math";align="absmiddle"> the Ô¨Årst term in the summation would be
<img 
src="SolvingMicroDSOPs274x.svg" alt="(‚àí ùúÉ-+ ùúÉ1)‚àíœÅ = 1‚àï0œÅ  " class="math";align="absmiddle"> which is inÔ¨Ånity. The reason is simple: <img 
src="SolvingMicroDSOPs275x.svg" alt="‚àí aT ‚àí1   " class="math";align="absmiddle"> is the PDV, as of
<img 
src="SolvingMicroDSOPs276x.svg" alt="T ‚àí  1  " class="math";align="absmiddle">, of the minimum possible realization of income in period <img 
src="SolvingMicroDSOPs277x.svg" alt="T  " class="math";align="absmiddle"> (<img 
src="SolvingMicroDSOPs278x.svg" alt="‚Ñõ   a    = ‚àí ùúÉ
  T -T‚àí1      1   " class="math";align="absmiddle">). Thus,
if the consumer borrows an amount greater than or equal to <img 
src="SolvingMicroDSOPs279x.svg" alt="   ‚àí1
ùúÉ‚Ñõ T  " class="math";align="absmiddle"> (that is, if the consumer
ends <img 
src="SolvingMicroDSOPs280x.svg" alt="T ‚àí  1  " class="math";align="absmiddle"> with <img 
src="SolvingMicroDSOPs281x.svg" alt="             ‚àí1
aT ‚àí1 ‚â§ ‚àí ùúÉ‚Ñõ T  " class="math";align="absmiddle">) and then draws the worst possible income shock in
period <img 
src="SolvingMicroDSOPs282x.svg" alt="T  " class="math";align="absmiddle">, he will have to consume zero in period <img 
src="SolvingMicroDSOPs283x.svg" alt="T  " class="math";align="absmiddle"> (or a negative amount), which
yields <img 
src="SolvingMicroDSOPs284x.svg" alt="‚àí ‚àû " class="math";align="absmiddle"> utility and <img 
src="SolvingMicroDSOPs285x.svg" alt="‚àû " class="math";align="absmiddle"> marginal utility (or undeÔ¨Åned utility and marginal
utility).
<!--l. 1029--><p class="indent" >  These reÔ¨Çections lead us to the conclusion that the consumer faces a ‚Äòself-imposed‚Äô liquidity
constraint (which results from the precautionary motive): He will never borrow an amount
greater than or equal to <img 
src="SolvingMicroDSOPs286x.svg" alt="ùúÉ‚Ñõ ‚àíT1  " class="math";align="absmiddle"> (that is, assets will never reach the lower bound of
<img 
src="SolvingMicroDSOPs287x.svg" alt="a-
 T ‚àí1 " class="math";align="absmiddle">).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs17.html#fn16x0"><sup class="textsuperscript">16</sup></a></span><a 
 id="x1-12003f16"></a>  
The constraint is ‚Äòself-imposed‚Äô in the sense that if the utility function were diÔ¨Äerent (say,
Constant Absolute Risk Aversion), the consumer would be willing to borrow more than <img 
src="SolvingMicroDSOPs288x.svg" alt="   ‚àí1
ùúÉ‚Ñõ T  " class="math";align="absmiddle">
because a choice of zero or negative consumption in period <img 
src="SolvingMicroDSOPs289x.svg" alt="T  " class="math";align="absmiddle"> would yield some Ô¨Ånite amount
of utility.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs18.html#fn17x0"><sup class="textsuperscript">17</sup></a></span><a 
 id="x1-12004f17"></a>  
<!--l. 1046--><p class="indent" >  This self-imposed constraint cannot be captured well when the <img 
src="SolvingMicroDSOPs290x.svg" alt="ùî≥‚Ä≤T‚àí 1   " class="math";align="absmiddle"> function is
approximated by a piecewise linear function like <img 
src="SolvingMicroDSOPs291x.svg" alt="`ùî≥‚Ä≤
 T‚àí 1   " class="math";align="absmiddle">, because a linear approximation can
never reach the correct gridpoint for <img 
src="SolvingMicroDSOPs292x.svg" alt=" ‚Ä≤
ùî≥T ‚àí1(aT‚àí1) = ‚àû.  " class="math";align="absmiddle"> To see what will happen instead, note
Ô¨Årst that if we are approximating <img 
src="SolvingMicroDSOPs293x.svg" alt="ùî≥‚Ä≤T‚àí1   " class="math";align="absmiddle"> the smallest value in <span 
class="ectt-1200">aVec </span>must be greater than
<img 
src="SolvingMicroDSOPs294x.svg" alt="aT ‚àí1 " class="math";align="absmiddle"> (because the expectation for any gridpoint <img 
src="SolvingMicroDSOPs295x.svg" alt="‚â§ aT ‚àí1   " class="math";align="absmiddle"> is undeÔ¨Åned). Then when the
approximating <img 
src="SolvingMicroDSOPs296x.svg" alt="ùî≥‚Ä≤
 T ‚àí1   " class="math";align="absmiddle"> function is evaluated at some value less than the Ô¨Årst element in
<span 
class="ectt-1200">aVec[1]</span>, the approximating function will linearly extrapolate the slope that characterized the
lowest segment of the piecewise linear approximation (between <span 
class="ectt-1200">aVec[1] </span>and <span 
class="ectt-1200">aVec[2]</span>), a
procedure that will return a positive Ô¨Ånite number, even if the requested <img 
src="SolvingMicroDSOPs297x.svg" alt="aT‚àí1   " class="math";align="absmiddle"> point is below
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs298x.svg" alt="aT ‚àí1 " class="math";align="absmiddle">. This means that the precautionary saving motive is understated, and by an
arbitrarily large amount as the level of assets approaches its true theoretical minimum
<img 
src="SolvingMicroDSOPs299x.svg" alt="a-
 T ‚àí1 " class="math";align="absmiddle">.
<!--l. 1065--><p class="indent" >  The foregoing logic demonstrates that the marginal value of saving approaches inÔ¨Ånity as
<img 
src="SolvingMicroDSOPs300x.svg" alt="                    ‚àí1
aT ‚àí1 ‚Üì aT ‚àí1 = ‚àí ùúÉ-‚Ñõ T  " class="math";align="absmiddle">. But this implies that <img 
src="SolvingMicroDSOPs301x.svg" alt="                           ‚Ä≤          ‚àí1‚àïœÅ
limaT ‚àí1‚ÜìaT‚àí 1 ùî†T‚àí1(aT‚àí 1) = (ùî≥T ‚àí1(aT‚àí1))   =  0  " class="math";align="absmiddle">;
that is, as <img 
src="SolvingMicroDSOPs302x.svg" alt="a  " class="math";align="absmiddle"> approaches its minimum possible value, the corresponding amount of <img 
src="SolvingMicroDSOPs303x.svg" alt="c  " class="math";align="absmiddle"> must
approach <span 
class="ecti-1200">its </span>minimum possible value: zero.
<!--l. 1072--><p class="indent" >  The upshot of this discussion is a realization that all we need to do is to augment each of
the <img 
src="SolvingMicroDSOPs304x.svg" alt="‚ÉóaT‚àí 1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs305x.svg" alt="‚ÉócT‚àí 1   " class="math";align="absmiddle"> vectors with an extra point so that the Ô¨Årst element in the list used to
produce our <span 
class="ectt-1200">InterpolatingFunction </span>is <img 
src="SolvingMicroDSOPs306x.svg" alt="{aT ‚àí1,0,cT‚àí 1,0} = {aT ‚àí1,0.} " class="math";align="absmiddle">.
<!--l. 1077--><p class="indent" >  <a 
 id="GothVInvVSGothC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-120059"></a>
                                                                                     
                                                                                     
<!--l. 1079--><p class="noindent" > <img 
src="./Figures/GothVInvVSGothC.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†9:</span><span  
class="content"><img 
src="SolvingMicroDSOPs307x.svg" alt="ùî†T ‚àí1(aT‚àí1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs308x.svg" alt="`ùî†T‚àí1(aT‚àí 1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-120059 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1086--><p class="indent" >  Figure <a 
href="#x1-120059">9<!--tex4ht:ref: fig:GothVInvVSGothC --></a> plots the results (generated by the program <span 
class="ectt-1200">2periodIntExpFOCInv.m</span>). The solid
line calculates the exact numerical value of <img 
src="SolvingMicroDSOPs309x.svg" alt="ùî†T‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> while the dashed line is the linear
interpolating approximation <img 
src="SolvingMicroDSOPs310x.svg" alt="`ùî†   (a   ).
 T ‚àí1  T‚àí1  " class="math";align="absmiddle"> This Ô¨Ågure well illustrates the value of the
transformation: The true function is close to linear, and so the linear approximation is
almost indistinguishable from the true function except at the very lowest values of
<img 
src="SolvingMicroDSOPs311x.svg" alt="aT ‚àí1   " class="math";align="absmiddle">.
<!--l. 1099--><p class="indent" >  Figure¬†<a 
href="#x1-1200610">10<!--tex4ht:ref: fig:GothVVSGothCInv --></a> similarly shows that when we calculate <img 
src="SolvingMicroDSOPs312x.svg" alt="``ùî≥‚Ä≤  (a    )
 T‚àí1  T‚àí 1  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs313x.svg" alt="[`ùî†   (a    )]‚àíœÅ
  T‚àí1  T‚àí 1  " class="math";align="absmiddle"> (dashed
line) we obtain a <span 
class="ecti-1200">much </span>closer approximation to the true function <img 
src="SolvingMicroDSOPs314x.svg" alt=" ‚Ä≤
ùî≥T‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> (solid
line) than we did in the previous  program which did not do the transformation
(Figure¬†<a 
href="#x1-100067">7<!--tex4ht:ref: fig:PlotOPRawVSFOC --></a>).
<!--l. 1109--><p class="indent" >  <a 
 id="GothVVSGothCInv"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1200610"></a>
                                                                                     
                                                                                     
<!--l. 1111--><p class="noindent" > <img 
src="./Figures/GothVVSGothCInv.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†10:</span><span  
class="content"><img 
src="SolvingMicroDSOPs315x.svg" alt="ùî≥‚Ä≤T‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> vs. <img 
src="SolvingMicroDSOPs316x.svg" alt="``ùî≥‚Ä≤T‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> Constructed Using <img 
src="SolvingMicroDSOPs317x.svg" alt="`ùî†T‚àí1(aT‚àí 1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-1200610 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1118--><p class="indent" >  <a 
 id="The-Method-of-Endogenous-Gridpoints"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.8  </span> <a 
 id="x1-130005.8"></a>The Method of Endogenous Gridpoints</h4>
<!--l. 1121--><p class="noindent" >Our solution procedure for <img 
src="SolvingMicroDSOPs318x.svg" alt="c
 T‚àí1   " class="math";align="absmiddle"> still requires us, for each point in <img 
src="SolvingMicroDSOPs319x.svg" alt="‚Éóm
  T‚àí1   " class="math";align="absmiddle"> (<span 
class="ectt-1200">mVect </span>in the
code), to use a numerical rootÔ¨Ånding algorithm to search for the value of <img 
src="SolvingMicroDSOPs320x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> that
solves <img 
src="SolvingMicroDSOPs321x.svg" alt=" ‚Ä≤          ‚Ä≤
u(cT‚àí 1) = ùî≥T‚àí1(mT ‚àí1 ‚àí cT‚àí1)  " class="math";align="absmiddle">. Unfortunately, rootÔ¨Ånding is a notoriously
computation-intensive (that is, slow!) operation.
<!--l. 1128--><p class="indent" >  Our next trick lets us completely skip the rootÔ¨Ånding step. The method can be understood
by noting that any arbitrary value of <img 
src="SolvingMicroDSOPs322x.svg" alt="a
 T‚àí 1,i  " class="math";align="absmiddle"> (greater than its lower bound value <img 
src="SolvingMicroDSOPs323x.svg" alt="a
-T‚àí1   " class="math";align="absmiddle">) will
be associated with <span 
class="ecti-1200">some </span>marginal valuation as of the end of period <img 
src="SolvingMicroDSOPs324x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">, and the further
observation that it is trivial to Ô¨Ånd the value of <img 
src="SolvingMicroDSOPs325x.svg" alt="c  " class="math";align="absmiddle"> that yields the same marginal valuation,
using the Ô¨Årst order condition,
  <table 
class="equation"><tr><td><a 
 id="x1-13001r28"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs326x.svg" alt=" ‚Ä≤           ‚Ä≤
u (cT‚àí1,i) = ùî≥T‚àí1(aT ‚àí1,i)
   cT ‚àí1,i = u‚Ä≤‚àí1(ùî≥‚Ä≤T‚àí1(aT‚àí 1,i))
              ‚Ä≤          ‚àí 1‚àïœÅ
         =  (ùî≥T‚àí1(aT‚àí 1,i))
         ‚â°  ùî†T‚àí1(aT‚àí 1,i)
         ‚â°  ùî†    .
             T‚àí1,i
" class="math-display" ></center></td><td class="equation-label">(28)</td></tr></table>
<!--l. 1142--><p class="nopar" >
<!--l. 1144--><p class="indent" >  But with mutually consistent values of <img 
src="SolvingMicroDSOPs327x.svg" alt="c
 T ‚àí1,i  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs328x.svg" alt="a
  T‚àí1,i  " class="math";align="absmiddle"> (consistent, in the
sense that they are the unique optimal values that correspond to the solution to the
problem in a single state), we can obtain the <img 
src="SolvingMicroDSOPs329x.svg" alt="mT ‚àí1,i  " class="math";align="absmiddle"> that corresponds to both of them
from
  <table 
class="equation"><tr><td><a 
 id="x1-13002r29"></a>
  <center class="math-display" >
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs330x.svg" alt="mT ‚àí1,i = cT‚àí 1,i + aT ‚àí1,i.
" class="math-display" ></center></td><td class="equation-label">(29)</td></tr></table>
<!--l. 1149--><p class="nopar" >
<!--l. 1151--><p class="indent" >  These <img 
src="SolvingMicroDSOPs331x.svg" alt="m
  T‚àí1   " class="math";align="absmiddle"> gridpoints are ‚Äúendogenous‚Äù in contrast to the usual solution method of
specifying some ex-ante grid of values of <img 
src="SolvingMicroDSOPs332x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle"> and then using a rootÔ¨Ånding routine to locate
the corresponding optimal <img 
src="SolvingMicroDSOPs333x.svg" alt="cT‚àí1   " class="math";align="absmiddle">.
<!--l. 1155--><p class="indent" >  Thus, we can generate a set of <img 
src="SolvingMicroDSOPs334x.svg" alt="mT ‚àí1,i  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs335x.svg" alt="cT ‚àí1,i  " class="math";align="absmiddle"> pairs that can be interpolated between in
order to yield <img 
src="SolvingMicroDSOPs336x.svg" alt="`c(mT ‚àí1)  " class="math";align="absmiddle"> at virtually zero computational cost once we have the <img 
src="SolvingMicroDSOPs337x.svg" alt="‚Éóùî†T‚àí 1   " class="math";align="absmiddle"> values in
hand!<span class="footnote-mark"><a 
href="SolvingMicroDSOPs19.html#fn18x0"><sup class="textsuperscript">18</sup></a></span><a 
 id="x1-13003f18"></a>  
One might worry about whether the <img 
src="SolvingMicroDSOPs338x.svg" alt="{m, c} " class="math";align="absmiddle"> points obtained in this way will provide a good
representation of the consumption function as a whole, but in practice there are good reasons
why they work well (basically, this procedure generates a set of gridpoints that is
naturally dense right around the parts of the function with the greatest nonlinearity). <a 
 id="PlotComparecTm1AD"></a>
<div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1300411"></a>
                                                                                     
                                                                                     
<!--l. 1167--><p class="noindent" > <img 
src="./Figures/PlotComparecTm1AD.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†11:</span><span  
class="content"><img 
src="SolvingMicroDSOPs339x.svg" alt="cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs340x.svg" alt="`cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-1300411 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1171--><p class="indent" >  Figure¬†<a 
href="#x1-1300411">11<!--tex4ht:ref: fig:ComparecTm1AD --></a> plots the actual consumption function <img 
src="SolvingMicroDSOPs341x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> and the approximated consumption
function <img 
src="SolvingMicroDSOPs342x.svg" alt="`cT‚àí1   " class="math";align="absmiddle"> derived by the method of endogenous grid points. Compared to the
approximate consumption functions illustrated in Figure¬†<a 
href="#x1-100078">8<!--tex4ht:ref: fig:PlotcTm1ABC --></a> <img 
src="SolvingMicroDSOPs343x.svg" alt="`c
 T ‚àí1   " class="math";align="absmiddle"> is quite close to the actual
consumption function.
<!--l. 1180--><p class="indent" >  <a 
 id="Improving-the-a-Grid"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.9  </span> <a 
 id="x1-140005.9"></a>Improving the <img 
src="SolvingMicroDSOPs344x.svg" alt="a  " class="math";align="absmiddle"> Grid</h4>
<!--l. 1183--><p class="noindent" >Thus far, we have arbitrarily used <img 
src="SolvingMicroDSOPs345x.svg" alt="a  " class="math";align="absmiddle"> gridpoints of <img 
src="SolvingMicroDSOPs346x.svg" alt="{0.,1.,2.,3.,4.} " class="math";align="absmiddle"> (augmented
in the last subsection by <img 
src="SolvingMicroDSOPs347x.svg" alt="a
-T ‚àí1   " class="math";align="absmiddle">). But it has been obvious from the Ô¨Ågures that
the approximated <img 
src="SolvingMicroDSOPs348x.svg" alt="`ùî†T‚àí 1   " class="math";align="absmiddle"> function tends to be farthest from its true value <img 
src="SolvingMicroDSOPs349x.svg" alt="ùî†T‚àí1   " class="math";align="absmiddle"> at
low values of <img 
src="SolvingMicroDSOPs350x.svg" alt="a  " class="math";align="absmiddle">. Combining this with our insight that <img 
src="SolvingMicroDSOPs351x.svg" alt="aT‚àí1   " class="math";align="absmiddle"> is a lower bound, we
are now in position to deÔ¨Åne a more deliberate method for constructing gridpoints
for <img 
src="SolvingMicroDSOPs352x.svg" alt="aT‚àí1   " class="math";align="absmiddle"> ‚Äì a method that yields values that are more densely spaced than the
uniform grid at low values of <img 
src="SolvingMicroDSOPs353x.svg" alt="a  " class="math";align="absmiddle">. A pragmatic choice that works well is to Ô¨Ånd the
values such that (1) the last value <span 
class="ecti-1200">exceeds the lower bound </span>by the same amount
<img 
src="SolvingMicroDSOPs354x.svg" alt="¬ØaT ‚àí1   " class="math";align="absmiddle"> as our original maximum gridpoint (in our case, 4.); (2) we have the same
number of gridpoints as before; and (3) the <span 
class="ecti-1200">multi-exponential growth rate </span>(that is,
<img 
src="SolvingMicroDSOPs355x.svg" alt="   ...
eee   " class="math";align="absmiddle"> for some number of exponentiations <img 
src="SolvingMicroDSOPs356x.svg" alt="n ùúÉ  " class="math";align="absmiddle">) from each point to the next point is
constant (instead of, as previously, imposing constancy of the absolute gap between
points).
<!--l. 1200--><p class="indent" >  <a 
 id="GothVInvVSGothCEEE"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1400112"></a>
                                                                                     
                                                                                     
<!--l. 1202--><p class="noindent" > <img 
src="./Figures/GothVInvVSGothCEEE.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†12:</span><span  
class="content"><img 
src="SolvingMicroDSOPs357x.svg" alt="ùî†T ‚àí1(aT‚àí1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs358x.svg" alt="`ùî†T‚àí1(aT‚àí 1)  " class="math";align="absmiddle">, Multi-Exponential <span 
class="ectt-1200">aVec</span></span></figcaption><!--tex4ht:label?: x1-1400112 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1209--><p class="indent" >  <a 
 id="GothVVSGothCInvEEE"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1400213"></a>
                                                                                     
                                                                                     
<!--l. 1211--><p class="noindent" > <img 
src="./Figures/GothVVSGothCInvEEE.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†13:</span><span  
class="content"><img 
src="SolvingMicroDSOPs359x.svg" alt="ùî≥‚Ä≤T‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> vs. <img 
src="SolvingMicroDSOPs360x.svg" alt="``ùî≥‚Ä≤T‚àí 1(aT ‚àí1)  " class="math";align="absmiddle">, Multi-Exponential <span 
class="ectt-1200">aVec</span></span></figcaption><!--tex4ht:label?: x1-1400213 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1217--><p class="indent" >  The results (generated by the program <span 
class="ectt-1200">2periodIntExpFOCInvEEE.m</span>) are depicted in
Figures¬†<a 
href="#x1-1400112">12<!--tex4ht:ref: fig:GothVInvVSGothCEE --></a> and <a 
href="#x1-1400213">13<!--tex4ht:ref: fig:GothVVSGothCInvEE --></a>, which are notably closer to their respective truths than the corresponding
Ô¨Ågures that used the original grid.
<!--l. 1223--><p class="indent" >  <a 
 id="The-Method-of-Moderation"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.10  </span> <a 
 id="x1-150005.10"></a>The Method of Moderation</h4>
<!--l. 2--><p class="noindent" >Unfortunately, this endogenous gridpoints solution is not very well-behaved outside the
original range of gridpoints targeted by the solution method. (Though other common solution
methods are no better outside their own predeÔ¨Åned ranges). Figure¬†<a 
href="#x1-1500114">14<!--tex4ht:ref: fig:ExtrapProblem --></a> demonstrates the point
by plotting the amount of precautionary saving implied by a linear extrapolation of our
approximated consumption rule (the consumption of the perfect foresight consumer
<img 
src="SolvingMicroDSOPs361x.svg" alt="¬ØcT‚àí 1   " class="math";align="absmiddle"> minus our approximation to optimal consumption under uncertainty, <img 
src="SolvingMicroDSOPs362x.svg" alt="`cT‚àí 1   " class="math";align="absmiddle">).
Although theory proves that precautionary saving is always positive, the linearly
extrapolated numerical approximation eventually predicts negative precautionary
saving (at the point in the Ô¨Ågure where the extrapolated locus crosses the horizontal
axis).
<!--l. 16--><p class="indent" >  <a 
 id="ExtrapProblemPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1500114"></a>
                                                                                     
                                                                                     
<!--l. 18--><p class="noindent" > <img 
src="./Figures/ExtrapProblemPlot.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†14:</span><span  
class="content">For  Large  Enough  <img 
src="SolvingMicroDSOPs363x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">,  Predicted  Precautionary  Saving  is  Negative
(Oops!)</span></figcaption><!--tex4ht:label?: x1-1500114 -->
                                                                                     
                                                                                     
  </div>
<!--l. 23--><p class="indent" >  This error cannot be Ô¨Åxed by extending the upper gridpoint; in the presence of
serious uncertainty, the consumption rule will need to be evaluated outside of <span 
class="ecti-1200">any</span>
prespeciÔ¨Åed grid (because starting from the top gridpoint, a large enough realization
of the uncertain variable will push next period‚Äôs realization of assets above that
top; a similar argument applies below the bottom gridpoint). While a judicious
extrapolation technique can prevent this problem from being fatal (for example by carefully
excluding negative precautionary saving), the problem is often dealt with using
inelegant methods whose implications for the accuracy of the solution are diÔ¨Écult to
gauge.
<!--l. 1--><p class="indent" >  As a preliminary to our solution, deÔ¨Åne <img 
src="SolvingMicroDSOPs364x.svg" alt="ùî•t  " class="math";align="absmiddle"> as end-of-period human wealth (the present
discounted value of future labor income) for a perfect foresight version of the problem of a ‚Äòrisk
optimist:‚Äô a consumer who believes with perfect conÔ¨Ådence that the shocks will always take the
value 1, <img 
src="SolvingMicroDSOPs365x.svg" alt="ùúÉt+n = ùîº [ùúÉ] = 1 ‚àÄ n &#x003E; 0  " class="math";align="absmiddle">. The solution to a perfect foresight problem of this kind takes
the form<span class="footnote-mark"><a 
href="SolvingMicroDSOPs20.html#fn19x0"><sup class="textsuperscript">19</sup></a></span><a 
 id="x1-15002f19"></a>  
  <table 
class="equation"><tr><td><a 
 id="x1-15003r30"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs368x.svg" alt="¬Øct(mt ) = (mt + ùî•t)Œ∫t
" class="math-display" ></center></td><td class="equation-label">(30)</td></tr></table>
<!--l. 3--><p class="nopar" >
for a constant minimal marginal propensity to consume <img 
src="SolvingMicroDSOPs369x.svg" alt="Œ∫
-t  " class="math";align="absmiddle"> given below.
<!--l. 1--><p class="indent" >  We similarly deÔ¨Åne <img 
src="SolvingMicroDSOPs370x.svg" alt="ùî•t  " class="math";align="absmiddle"> as ‚Äòminimal human wealth,‚Äô the present discounted value
of labor income if the shocks were to take on their worst possible value in every
future period <img 
src="SolvingMicroDSOPs371x.svg" alt="ùúÉt+n = ùúÉ-‚àÄ n &#x003E; 0  " class="math";align="absmiddle"> (which we deÔ¨Åne as corresponding to the beliefs of a
‚Äòpessimist‚Äô).
<!--l. 10--><p class="indent" >  We will call a ‚Äòrealist‚Äô the consumer who correctly perceives the true probabilities of the
future risks and optimizes accordingly.
<!--l. 12--><p class="indent" >  A Ô¨Årst useful point is that, for the realist, a lower bound for the level of market resources is
<img 
src="SolvingMicroDSOPs372x.svg" alt="mt  = ‚àí ùî•-
         t  " class="math";align="absmiddle">, because if <img 
src="SolvingMicroDSOPs373x.svg" alt="mt  " class="math";align="absmiddle"> equalled this value then there would be a positive Ô¨Ånite chance
(however small) of receiving <img 
src="SolvingMicroDSOPs374x.svg" alt="ùúÉt+n = ùúÉ-  " class="math";align="absmiddle"> in every future period, which would require the
                                                                                     
                                                                                     
consumer to set <img 
src="SolvingMicroDSOPs375x.svg" alt="ct  " class="math";align="absmiddle"> to zero in order to guarantee that the intertemporal budget constraint
holds¬†(this is the multiperiod generalization of the discussion in section <a 
href="#x1-120005.7">5.7<!--tex4ht:ref: subsec:LiqConstrSelfImposed --></a> about <img 
src="SolvingMicroDSOPs376x.svg" alt="aT‚àí 1   " class="math";align="absmiddle">).
Since consumption of zero yields negative inÔ¨Ånite utility, the solution to realist consumer‚Äôs
problem is not well deÔ¨Åned for values of <img 
src="SolvingMicroDSOPs377x.svg" alt="m  &#x003C; m
  t  --t  " class="math";align="absmiddle">, and the limiting value of the realist‚Äôs <img 
src="SolvingMicroDSOPs378x.svg" alt="c
 t  " class="math";align="absmiddle"> is
zero as <img 
src="SolvingMicroDSOPs379x.svg" alt="mt ‚Üì mt  " class="math";align="absmiddle">.
<!--l. 28--><p class="indent" >  Given this result, it will be convenient to deÔ¨Åne ‚Äòexcess‚Äô market resources as the amount by
which actual resources exceed the lower bound, and ‚Äòexcess‚Äô human wealth as the
amount by which mean expected human wealth exceeds guaranteed minimum human
wealth:
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs380x.svg" alt="             =‚óú‚àí‚óûm‚óüt‚óù
‚ñ¥mt  = mt +   ùî•
              -t
 ‚ñ¥ùî•t = ùî•t ‚àí ùî•t.
" class="math-display" ></center></td></tr></table>
<!--l. 35--><p class="nopar" >
<!--l. 37--><p class="indent" >  We can now transparently deÔ¨Åne the optimal consumption rules for the two perfect foresight
problems, those of the ‚Äòoptimist‚Äô and the ‚Äòpessimist.‚Äô The ‚Äòpessimist‚Äô perceives human wealth
to be equal to its minimum feasible value <img 
src="SolvingMicroDSOPs381x.svg" alt="ùî•t  " class="math";align="absmiddle"> with certainty, so consumption is given by the
perfect foresight solution
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs382x.svg" alt="ct(mt ) = (mt  + ùî•t)Œ∫t
      =  ‚ñ¥mt Œ∫t.
" class="math-display" ></center></td></tr></table>
<!--l. 46--><p class="nopar" >
                                                                                     
                                                                                     
<!--l. 48--><p class="indent" >  The ‚Äòoptimist,‚Äô on the other hand, pretends that there is no uncertainty about future
income, and therefore consumes
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs383x.svg" alt="¬Øct(mt ) = (mt + ùî•t ‚àí ùî•t + ùî•t)Œ∫t
       = (‚ñ¥mt  + ‚ñ¥ ùî•t)Œ∫t

       = ct(mt ) + ‚ñ¥ùî•tŒ∫t.
" class="math-display" ></center></td></tr></table>
<!--l. 55--><p class="nopar" >
<!--l. 57--><p class="indent" >  It seems obvious that the spending of the realist will be strictly greater than that of the
pessimist and strictly less than that of the optimist. Figure¬†<a 
href="#x1-1500415">15<!--tex4ht:ref: fig:IntExpFOCInvPesReaOptNeedHiPlot --></a> illustrates the proposition for
the consumption rule in period <img 
src="SolvingMicroDSOPs384x.svg" alt="T ‚àí  1  " class="math";align="absmiddle">.
<a 
 id="IntExpFOCInvPesReaOptNeedHiPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1500415"></a>
                                                                                     
                                                                                     
<!--l. 3--><p class="noindent" > <img 
src="./Figures/IntExpFOCInvPesReaOptNeedHiPlot.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†15:</span><span  
class="content">Moderation Illustrated: <img 
src="SolvingMicroDSOPs385x.svg" alt="cT‚àí 1 &#x003C; `cT ‚àí1 &#x003C; ¬ØcT‚àí1   " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-1500415 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2--><p class="indent" >  Proof is more diÔ¨Écult than might be imagined, but the necessary work is done in
<a 
href="#XBufferStockTheory">Carroll</a>¬†(<a 
href="#XBufferStockTheory">Forthcoming</a>) so we will take the proposition as a fact and proceed by manipulating
the inequality:
<div class="center" 
>
<!--l. 1--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs386x.svg" alt="  ‚ñ¥m  Œ∫  &#x003C;             c(m  +  ‚ñ¥m  )            &#x003C; (‚ñ¥m   + ‚ñ¥ ùî• )Œ∫
     t-t                t--t      t                    t     t-t
‚àí ‚ñ¥mt Œ∫t &#x003E;            ‚àí ct(mt + ‚ñ¥mt )           &#x003E; ‚àí (‚ñ¥mt  + ‚ñ¥ ùî•t)Œ∫t
   ‚ñ¥ùî•tŒ∫t &#x003E;   ( ¬Øct(mt +  ‚ñ¥mt ) ‚àí ct(mt + ‚ñ¥mt  ))   &#x003E; 0
               ¬Øct(mt-+--‚ñ¥mt-) ‚àí-ct(mt-+-‚ñ¥mt--)
       1 &#x003E;                ‚ñ¥ ùî• Œ∫                 &#x003E; 0
             ‚óü--------------‚óùt‚óú-t------------‚óû
                            ‚â°ÀÜœôt
" ></div></div>
<!--l. 1--><p class="noindent" >where the fraction in the middle of the last inequality is the ratio of actual precautionary saving
(the numerator is the diÔ¨Äerence between perfect-foresight consumption and optimal
consumption in the presence of uncertainty) to the maximum conceivable amount of
precautionary saving (the amount that would be undertaken by the pessimist who consumes
nothing out of any future income beyond the perfectly certain component).
<!--l. 1--><p class="indent" >  DeÔ¨Åning <img 
src="SolvingMicroDSOPs387x.svg" alt="Œº  = log ‚ñ¥m
  t         t  " class="math";align="absmiddle"> (which can range from <img 
src="SolvingMicroDSOPs388x.svg" alt="‚àí  ‚àû " class="math";align="absmiddle"> to <img 
src="SolvingMicroDSOPs389x.svg" alt="‚àû " class="math";align="absmiddle">), the object in the middle of
the last inequality is
  <table 
class="equation"><tr><td><a 
 id="x1-15005r31"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs390x.svg" alt="         (                           )
          ¬Øct(mt-+-eŒºt)-‚àí-ct(mt--+-eŒºt)
ÀÜœôt(Œºt) ‚â°             ‚ñ¥ùî• Œ∫              ,
                        tt
" class="math-display" ></center></td><td class="equation-label">(31)</td></tr></table>
<!--l. 5--><p class="nopar" >
and we now deÔ¨Åne
  <table 
class="equation"><tr><td><a 
 id="x1-15006r32"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs391x.svg" alt="            ( 1 ‚àí ÀÜœô (Œºt) )
ÀÜœáœáœát(Œºt) = log   -----t----
                ÀÜœôt(Œºt)
      =  log (1‚àïÀÜœôt(Œºt) ‚àí 1 )
" class="math-display" ></center></td><td class="equation-label">(32)</td></tr></table>
<!--l. 10--><p class="nopar" >
which has the virtue that it is linear in the limit as <img 
src="SolvingMicroDSOPs392x.svg" alt="Œºt  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs393x.svg" alt="+  ‚àû " class="math";align="absmiddle">.
<!--l. 3--><p class="indent" >  Given <img 
src="SolvingMicroDSOPs394x.svg" alt="ÀÜœáœáœá  " class="math";align="absmiddle">, the consumption function can be recovered from
  <table 
class="equation"><tr><td><a 
 id="x1-15007r33"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs395x.svg" alt="         ‚óú------=‚óûÀÜœô‚óüt----‚óù
         (      1      )
ÀÜct = ¬Øct ‚àí  ------------  ‚ñ¥ùî•tŒ∫t.
           1 + exp (œáœáÀÜœát)
" class="math-display" ></center></td><td class="equation-label">(33)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 2--><p class="indent" >  Thus, the procedure is to calculate <img 
src="SolvingMicroDSOPs396x.svg" alt="ÀÜœáœáœát  " class="math";align="absmiddle"> at the points <img 
src="SolvingMicroDSOPs397x.svg" alt="‚ÉóŒºt  " class="math";align="absmiddle"> corresponding to the log of the
<img 
src="SolvingMicroDSOPs398x.svg" alt="‚ñ¥ ‚Éómt  " class="math";align="absmiddle"> points deÔ¨Åned above, and then using these to construct an interpolating approximation
<img 
src="SolvingMicroDSOPs399x.svg" alt="`ÀÜœáœáœát " class="math";align="absmiddle"> from which we indirectly obtain our approximated consumption rule <img 
src="SolvingMicroDSOPs400x.svg" alt="`ÀÜct  " class="math";align="absmiddle"> by substituting
<img 
src="SolvingMicroDSOPs401x.svg" alt="`ÀÜœáœáœá
  t " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs402x.svg" alt="ÀÜœáœáœá  " class="math";align="absmiddle"> in equation (<a 
href="#x1-15007r33">33<!--tex4ht:ref: eq:cFuncHi --></a>).
<!--l. 8--><p class="indent" >  Because this method relies upon the fact that the problem is easy to solve if the decision
maker has unreasonable views (either in the optimistic or the pessimistic direction), and
because the correct solution is always between these immoderate extremes, we call our
solution procedure the ‚Äòmethod of moderation.‚Äô
<!--l. 14--><p class="indent" >  Results are shown in Figure¬†<a 
href="#x1-1500816">16<!--tex4ht:ref: fig:ExtrapProblemSolved --></a>; a reader with very good eyesight might be able to detect
the barest hint of a discrepancy between the Truth and the Approximation at the far
righthand edge of the Ô¨Ågure ‚Äì a stark contrast with the calamitous divergence evident in
Figure¬†<a 
href="#x1-1500114">14<!--tex4ht:ref: fig:ExtrapProblem --></a>. <a 
 id="ExtrapProblemSolvedPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1500816"></a>
                                                                                     
                                                                                     
<!--l. 21--><p class="noindent" > <img 
src="./Figures/ExtrapProblemSolvedPlot.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†16:</span><span  
class="content">Extrapolated <img 
src="SolvingMicroDSOPs403x.svg" alt="`ÀÜcT‚àí 1   " class="math";align="absmiddle"> Constructed Using the Method of Moderation</span></figcaption><!--tex4ht:label?: x1-1500816 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1436--><p class="indent" >  <a 
 id="Approximating-the-Slope-Too"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.11  </span> <a 
 id="x1-160005.11"></a>Approximating the Slope Too</h4>
<!--l. 1440--><p class="noindent" >Until now, we have calculated the level of consumption at various diÔ¨Äerent gridpoints and used
linear interpolation (either directly for <img 
src="SolvingMicroDSOPs404x.svg" alt="cT ‚àí1   " class="math";align="absmiddle"> or indirectly for, say, <img 
src="SolvingMicroDSOPs405x.svg" alt="ÀÜœáœáœáT‚àí 1   " class="math";align="absmiddle">). But the resulting
piecewise linear approximations have the unattractive feature that they are not diÔ¨Äerentiable
at the ‚Äòkink points‚Äô that correspond to the gridpoints where the slope of the function changes
discretely.
<!--l. 1449--><p class="indent" >  <a 
href="#XBufferStockTheory">Carroll</a>¬†(<a 
href="#XBufferStockTheory">Forthcoming</a>) shows that the true consumption function for this problem is
‚Äòsmooth:‚Äô It exhibits a well-deÔ¨Åned unique marginal propensity to consume at every positive
value of <img 
src="SolvingMicroDSOPs406x.svg" alt="m  " class="math";align="absmiddle">. This suggests that we should calculate, not just the level of consumption, but
also the marginal propensity to consume (henceforth <img 
src="SolvingMicroDSOPs407x.svg" alt="Œ∫  " class="math";align="absmiddle">) at each gridpoint, and then Ô¨Ånd an
interpolating approximation that smoothly matches both the level and the slope at those
points.
<!--l. 1459--><p class="indent" >  This requires us to diÔ¨Äerentiate (<a 
href="#x1-15005r31">31<!--tex4ht:ref: eq:koppa --></a>) and (<a 
href="#x1-15006r32">32<!--tex4ht:ref: eq:chi --></a>), yielding
  <table 
class="equation"><tr><td><a 
 id="x1-16001r34"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs408x.svg" alt="                      (       --‚â°Œ∫Œ∫Œ∫t(mt)---)
 Œº               ‚àí1 Œºt(      ‚óúm   ‚óû‚óü  Œºt‚óù)
ÀÜœôt (Œºt) = (‚ñ¥ ùî•tŒ∫t)  e    Œ∫t ‚àí ct (mt + e )
         (             )
 Œº          ‚àí ÀÜœô Œºt(Œºt)‚àï ÀÜœô2
ÀÜœáœáœát (Œºt) =   -----------t
           1‚àïœôÀÜt(Œºt) ‚àí 1
" class="math-display" ></center></td><td class="equation-label">(34)</td></tr></table>
<!--l. 1463--><p class="nopar" >
and (dropping arguments) with some algebra these can be combined to yield
  <table 
class="equation"><tr><td><a 
 id="x1-16002r35"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs409x.svg" alt="      (                         )
  Œº        Œ∫t‚ñ¥mt ‚ñ¥ ùî•t(Œ∫t ‚àí Œ∫t)
œáœáœáÀÜt =   ------------------------- .
        (¬Øct ‚àí ct)(¬Øct ‚àí ct ‚àí Œ∫t‚ñ¥ ùî•t)
" class="math-display" ></center></td><td class="equation-label">(35)</td></tr></table>
<!--l. 1468--><p class="nopar" >
<!--l. 1470--><p class="indent" >  To compute the vector of values of (<a 
href="#x1-16001r34">34<!--tex4ht:ref: eq:koppaPrime --></a>) corresponding to the points in <img 
src="SolvingMicroDSOPs410x.svg" alt="‚ÉóŒºt  " class="math";align="absmiddle">, we need the
marginal propensities to consume (designated <img 
src="SolvingMicroDSOPs411x.svg" alt="Œ∫  " class="math";align="absmiddle">) at each of the gridpoints, <img 
src="SolvingMicroDSOPs412x.svg" alt=" m
ct  " class="math";align="absmiddle"> (the vector of
such values is <img 
src="SolvingMicroDSOPs413x.svg" alt="‚ÉóŒ∫t  " class="math";align="absmiddle">). These can be obtained by diÔ¨Äerentiating the Euler equation (<a 
href="#x1-4010r12">12<!--tex4ht:ref: eq:upEqbetaOp --></a>) (where
we deÔ¨Åne <img 
src="SolvingMicroDSOPs414x.svg" alt="ùî™t(a) ‚â° ùî†t(a) + a  " class="math";align="absmiddle">):
  <table 
class="equation"><tr><td><a 
 id="x1-16003r36"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs415x.svg" alt=" ‚Ä≤        a
u (ùî†t) = ÀÜùî≥ t(ùî™t ‚àí  ùî†t)
" class="math-display" ></center></td><td class="equation-label">(36)</td></tr></table>
<!--l. 1479--><p class="nopar" >
with respect to <img 
src="SolvingMicroDSOPs416x.svg" alt="a  " class="math";align="absmiddle">, yielding a marginal propensity to <span 
class="ecti-1200">have consumed</span> <img 
src="SolvingMicroDSOPs417x.svg" alt="ùî†a  " class="math";align="absmiddle"> at each
gridpoint:
  <table 
class="equation"><tr><td><a 
 id="x1-16004r37"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs418x.svg" alt="u ‚Ä≤‚Ä≤(ùî†t)ùî†at = ÀÜùî≥ata(ùî™t ‚àí ùî†t)
       a   ÀÜaa           ‚Ä≤‚Ä≤
      ùî†t = ùî≥t (ùî™t ‚àí ùî†t)‚àïu  (ùî†t)
" class="math-display" ></center></td><td class="equation-label">(37)</td></tr></table>
<!--l. 1485--><p class="nopar" >
and the marginal propensity to consume at the beginning of the period is obtained from the
marginal propensity to have consumed by noting that
  <table 
class="equation-star"><tr><td>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs419x.svg" alt="     ùî† = ùî™ ‚àí  a
 a         a
ùî†  + 1 = ùî™
" class="math-display" ></center></td></tr></table>
<!--l. 1491--><p class="nopar" >
which, together with the chain rule <img 
src="SolvingMicroDSOPs420x.svg" alt="ùî†a = cm ùî™a  " class="math";align="absmiddle">, yields the MPC from
  <table 
class="equation"><tr><td><a 
 id="x1-16005r38"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs421x.svg" alt="    =ùî™a
   ‚óú-‚óû‚óü-‚óù
cm(ùî†a + 1) = ùî†a
       cm =  ùî†a‚àï(1 + ùî†a).
" class="math-display" ></center></td><td class="equation-label">(38)</td></tr></table>
<!--l. 1497--><p class="nopar" >
<!--l. 1500--><p class="indent" >  Designating <img 
src="SolvingMicroDSOPs422x.svg" alt="`ÀÜcT‚àí1   " class="math";align="absmiddle"> as the approximated consumption rule obtained using an interpolating
polynomial approximation to <img 
src="SolvingMicroDSOPs423x.svg" alt="œáœáœáÀÜ  " class="math";align="absmiddle"> that matches both the level and the Ô¨Årst derivative at
the gridpoints, Figure¬†<a 
href="#x1-1600617">17<!--tex4ht:ref: fig:IntExpFOCInvPesReaOptGapPlot --></a> plots the diÔ¨Äerence between this latest approximation
and the true consumption rule for period <img 
src="SolvingMicroDSOPs424x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> up to the same large value (far
beyond the largest gridpoint) used in prior Ô¨Ågures. Of course, at the gridpoints
the approximation will match the true function; but this Ô¨Ågure illustrates that the
approximation is quite accurate far beyond the last gridpoint (which is the last point
at which the diÔ¨Äerence touches the horizontal axis). (We plot here the diÔ¨Äerence
between the two functions rather than the level plotted in previous Ô¨Ågures, because in
levels the approximation error would not be detectable even to the most eagle-eyed
reader.)
<!--l. 1517--><p class="indent" >  <a 
 id="IntExpFOCInvPesReaOptGapPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1600617"></a>
                                                                                     
                                                                                     
<!--l. 1519--><p class="noindent" > <img 
src="./Figures/IntExpFOCInvPesReaOptGapPlot.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†17:</span><span  
class="content">DiÔ¨Äerence Between True <img 
src="SolvingMicroDSOPs425x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs426x.svg" alt="`ÀÜcT‚àí 1   " class="math";align="absmiddle"> Is Minuscule</span></figcaption><!--tex4ht:label?: x1-1600617 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1527--><p class="indent" >  <a 
 id="Value"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.12  </span> <a 
 id="x1-170005.12"></a>Value</h4>
<!--l. 2--><p class="noindent" >Although section¬†<a 
href="#x1-100005.5">5.5<!--tex4ht:ref: subsec:vVsuP --></a> argued that our problem is more eÔ¨Éciently solved by constructing the
consumption rule than by approximating the value function, often it is useful to know the
value function as well as the consumption rule. Fortunately, many of the tricks used when
solving for the consumption rule have a direct analogue in approximation of the value
function.
<!--l. 9--><p class="indent" >  Consider the perfect foresight (or ‚Äúoptimist‚Äôs‚Äù) problem in period <img 
src="SolvingMicroDSOPs427x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">:
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs428x.svg" alt="¬ØvT ‚àí1(mT ‚àí1) ‚â° u(cT‚àí1) + Œ≤u (cT )
            =  u(c   )(1 + Œ≤ ((Œ≤ R )1‚àïœÅ)1‚àíœÅ)
                  T‚àí1 (         T      )
            =  u(cT‚àí1)  1 + Œ≤ (Œ≤TR )1‚àïœÅ‚àí1
                      (          1‚àïœÅ  )
            =  u(cT‚àí1)  1 + (Œ≤T R)  ‚àïR
            =  u(cT‚àí1)PDVT   (c)‚àïcT ‚àí1
                      ‚óü ---t-‚óù‚óú-----‚óû
                            ‚â°‚ÑÇTt
" class="math-display" ></center></td></tr></table>
<!--l. 16--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs429x.svg" alt="‚ÑÇTt =  PDVTt (c)  " class="math";align="absmiddle"> is the present discounted value of consumption. A similar function
can be constructed recursively for earlier periods, yielding the general expression <a 
 id="vFuncPF"></a>
  <table 
class="equation"><tr><td><a 
 id="x1-17001r39"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs430x.svg" alt="¬Øvt(mt ) = u(¬Øct)‚ÑÇT
               ‚àít1
       =  u(¬Øct)Œ∫t
       =  u((‚ñ¥mt +  ‚ñ¥ùî•t)Œ∫t)Œ∫‚àít1
                        1‚àíœÅ  ‚àí1
       =  u(‚ñ¥mt +  ‚ñ¥ùî•t)Œ∫t  Œ∫-t
       =  u(‚ñ¥m  +  ‚ñ¥ùî• )Œ∫‚àí œÅ
               t      t-t
" class="math-display" ></center></td><td class="equation-label">(39)</td></tr></table>
<!--l. 7--><p class="nopar" >
where the second line uses the fact demonstrated in <a 
href="#XBufferStockTheory">Carroll</a>¬†(<a 
href="#XBufferStockTheory">Forthcoming</a>) that
<img 
src="SolvingMicroDSOPs431x.svg" alt="‚ÑÇt =  Œ∫‚àí1
       t  " class="math";align="absmiddle">.
<!--l. 10--><p class="indent" >  This can be transformed as
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs432x.svg" alt="¬ØŒõt ‚â° ((1 ‚àí œÅ)¬Øvt)1‚àï(1‚àíœÅ)
         T 1‚àï(1‚àíœÅ)
  =  ct(‚ÑÇ t )
  =  (‚ñ¥m   + ‚ñ¥ ùî• )Œ∫‚àíœÅ‚àï(1‚àíœÅ)
         t     t -t
" class="math-display" ></center></td></tr></table>
<!--l. 15--><p class="nopar" >
with derivative
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs433x.svg" alt=" m      T 1‚àï(1‚àíœÅ)
¬ØŒõt =  (‚ÑÇt )     Œ∫t,
   =  Œ∫‚àítœÅ‚àï(1‚àí œÅ)
" class="math-display" ></center></td></tr></table>
                                                                                     
                                                                                     
<!--l. 5--><p class="nopar" >
and since <img 
src="SolvingMicroDSOPs434x.svg" alt="‚ÑÇTt  " class="math";align="absmiddle"> is a constant while the consumption function is linear, <img 
src="SolvingMicroDSOPs435x.svg" alt="¬ØŒõt  " class="math";align="absmiddle"> will also be
linear.
<!--l. 9--><p class="indent" >  We apply the same transformation to the value function for the problem with uncertainty
(the ‚Äúrealist‚Äôs‚Äù problem) and diÔ¨Äerentiate
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs436x.svg" alt=" ¬ØŒõt = ((1 ‚àí œÅ)¬Øvt(mt ))1‚àï(1‚àí œÅ)
                    ‚àí 1+1 ‚àï(1‚àíœÅ)
¬ØŒõmt =  ((1 ‚àí œÅ)¬Øvt(mt ))         ¬Øvmt (mt)
" class="math-display" ></center></td></tr></table>
<!--l. 13--><p class="nopar" >
and an excellent approximation to the value function can be obtained by calculating the values
of <img 
src="SolvingMicroDSOPs437x.svg" alt="¬ØŒõ   " class="math";align="absmiddle"> at the same gridpoints used by the consumption function approximation, and
interpolating among those points.
<!--l. 18--><p class="indent" >  However, as with the consumption approximation, we can do even better if we realize that
the <img 
src="SolvingMicroDSOPs438x.svg" alt="¬ØŒõ   " class="math";align="absmiddle"> function for the optimist‚Äôs problem is an upper bound for the <img 
src="SolvingMicroDSOPs439x.svg" alt="Œõ   " class="math";align="absmiddle"> function in the
presence of uncertainty, and the value function for the pessimist is a lower bound. Analogously
to (<a 
href="#x1-15005r31">31<!--tex4ht:ref: eq:koppa --></a>), deÔ¨Åne an upper-case
  <table 
class="equation"><tr><td><a 
 id="x1-17002r40"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs440x.svg" alt="         (                           )
 ÀÜ         ¬ØŒõt(mt-+-eŒºt) ‚àí-Œõt(mt-+-eŒºt)
œòt (Œºt) =        ‚ñ¥ ùî•tŒ∫-(‚ÑÇT )1‚àï(1‚àíœÅ)
                     t  t
" class="math-display" ></center></td><td class="equation-label">(40)</td></tr></table>
<!--l. 24--><p class="nopar" >
with derivative (dropping arguments)
  <table 
class="equation"><tr><td><a 
 id="x1-17003r41"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs441x.svg" alt="ÀÜŒº            T 1‚àï(1‚àíœÅ) ‚àí1 Œºt  m    m
œòt = (‚ñ¥ ùî•tŒ∫t(‚ÑÇ t )     )  e  (¬ØŒõt ‚àí Œõt )
" class="math-display" ></center></td><td class="equation-label">(41)</td></tr></table>
<!--l. 29--><p class="nopar" >
and an upper-case version of the <img 
src="SolvingMicroDSOPs442x.svg" alt="œáœáœá  " class="math";align="absmiddle"> equation in (<a 
href="#x1-15006r32">32<!--tex4ht:ref: eq:chi --></a>):
  <table 
class="equation"><tr><td><a 
 id="x1-17004r42"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs443x.svg" alt="            (           )
ÀÜ             1-‚àí-ÀÜœòt(Œºt)
Xt(Œºt) = log    œòÀÜt(Œºt)
            (             )
       = log  1‚àïÀÜœòt(Œºt) ‚àí 1
" class="math-display" ></center></td><td class="equation-label">(42)</td></tr></table>
<!--l. 34--><p class="nopar" >
with corresponding derivative
  <table 
class="equation"><tr><td><a 
 id="x1-17005r43"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs444x.svg" alt="     (     Œº    )
ÀÜŒº     -‚àíœòÀÜt‚àïÀÜœò2t-
Xt =   1‚àï ÀÜœò ‚àí 1
           t
" class="math-display" ></center></td><td class="equation-label">(43)</td></tr></table>
<!--l. 38--><p class="nopar" >
and if we approximate these objects then invert them (as above with the <img 
src="SolvingMicroDSOPs445x.svg" alt="ÀÜœô  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs446x.svg" alt="œáœáÀÜœá  " class="math";align="absmiddle"> functions)
we obtain a very high-quality approximation to our inverted value function at the same points
                                                                                     
                                                                                     
for which we have our approximated value function:
  <table 
class="equation"><tr><td><a 
 id="x1-17006r44"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs447x.svg" alt="                =ÀÜœòt
         ‚óú(------‚óû‚óü-----)‚óù
                 1               T 1‚àï(1‚àí œÅ)
ÀÜŒõt = ¬ØŒõt ‚àí  ---------ÀÜ--  ‚ñ¥ ùî•tŒ∫t(‚ÑÇt )
           1 + exp (Xt)
" class="math-display" ></center></td><td class="equation-label">(44)</td></tr></table>
<!--l. 45--><p class="nopar" >
from which we obtain our approximation to the value function and its derivatives¬†as
<a 
 id="vHatFunc"></a>
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs448x.svg" alt="  ÀÜvt = u(ÀÜŒõt)
 ÀÜvm  = u‚Ä≤(ÀÜŒõ )ÀÜŒõm
   t       t
ÀÜvmtm  = u‚Ä≤‚Ä≤(ÀÜŒõt)(ÀÜŒõm )2 + u‚Ä≤(ÀÜŒõt)ÀÜŒõmm.
" class="math-display" ></center></td></tr></table>
<!--l. 52--><p class="nopar" >
<!--l. 54--><p class="indent" >  Although a linear interpolation that matches the level of <img 
src="SolvingMicroDSOPs449x.svg" alt="Œõ   " class="math";align="absmiddle"> at the gridpoints is simple, a
Hermite interpolation that matches both the level and the derivative of the <img 
src="SolvingMicroDSOPs450x.svg" alt="¬ØŒõt  " class="math";align="absmiddle"> function at the
gridpoints has the considerable virtue that the <img 
src="SolvingMicroDSOPs451x.svg" alt="¬Øvt  " class="math";align="absmiddle"> derived from it numerically satisÔ¨Åes
the envelope theorem at each of the gridpoints for which the problem has been
solved.
<!--l. 68--><p class="indent" >  If we use the double-derivative calculated above to produce a higher-order Hermite
polynomial, our approximation will also match marginal propensity to consume at the
gridpoints; this would guarantee that the consumption function generated from the value
function would match both the level of consumption and the marginal propensity to consume
at the gridpoints; the numerical diÔ¨Äerences between the newly constructed consumption
                                                                                     
                                                                                     
function and the highly accurate one constructed earlier would be negligible within the
grid.
<!--l. 1643--><p class="indent" >  <a 
 id="Refinement-A-Tighter-Upper-Bound"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.13  </span> <a 
 id="x1-180005.13"></a>ReÔ¨Ånement: A Tighter Upper Bound</h4>
<!--l. 1--><p class="noindent" ><a 
href="#XBufferStockTheory">Carroll</a>¬†(<a 
href="#XBufferStockTheory">Forthcoming</a>) derives an upper limit <img 
src="SolvingMicroDSOPs452x.svg" alt="¬ØŒ∫t  " class="math";align="absmiddle"> for the MPC as <img 
src="SolvingMicroDSOPs453x.svg" alt="mt  " class="math";align="absmiddle"> approaches its lower
bound. Using this fact plus the strict concavity of the consumption function yields the
proposition that
  <table 
class="equation"><tr><td><a 
 id="x1-18001r45"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs454x.svg" alt="ct(mt + ‚ñ¥mt ) &#x003C; ¬ØŒ∫t‚ñ¥mt.
" class="math-display" ></center></td><td class="equation-label">(45)</td></tr></table>
<!--l. 7--><p class="nopar" >
<!--l. 9--><p class="indent" >  The solution method described above does not guarantee that approximated consumption
will respect this constraint between gridpoints, and a failure to respect the constraint can
occasionally cause computational problems in solving or simulating the model. Here,
we describe a method for constructing an approximation that always satisÔ¨Åes the
constraint.
<!--l. 1--><p class="indent" >  DeÔ¨Åning <img 
src="SolvingMicroDSOPs455x.svg" alt="m#
  t  " class="math";align="absmiddle"> as the ‚Äòcusp‚Äô point where the two upper bounds intersect:
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs456x.svg" alt="(           )
    #                    #
 ‚ñ¥m t +  ‚ñ¥ùî•t  Œ∫t = ¬ØŒ∫t‚ñ¥m  t
              #      Œ∫t‚ñ¥ ùî•t
           ‚ñ¥m t  = ----------
                   (1 ‚àí Œ∫t)¬ØŒ∫t
              #    -Œ∫tùî•t ‚àí-ùî•t
             mt  = (1 ‚àí Œ∫ )¬ØŒ∫ ,
                        -t  t
" class="math-display" ></center></td></tr></table>
<!--l. 7--><p class="nopar" >
we want to construct a consumption function for <img 
src="SolvingMicroDSOPs457x.svg" alt="            #
mt ‚àà (mt, m t ]  " class="math";align="absmiddle"> that respects the tighter
upper bound:
<div class="center" 
>
<!--l. 3--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs458x.svg" alt="       ‚ñ¥mt Œ∫t &#x003C;       ct(mt + ‚ñ¥mt )       &#x003C; ¬ØŒ∫t‚ñ¥mt
‚ñ¥mt (¬ØŒ∫t ‚àí Œ∫t) &#x003E;  Œ∫¬Øt‚ñ¥(mt  ‚àí ct(mt + ‚ñ¥mt)  )  &#x003E; 0
                     ¬ØŒ∫t‚ñ¥mt‚àíct(mt+‚ñ¥mt)-
            1 &#x003E;         ‚ñ¥mt(¬ØŒ∫t‚àí Œ∫t)         &#x003E; 0.
" ></div></div>
<!--l. 1--><p class="indent" >  Again deÔ¨Åning <img 
src="SolvingMicroDSOPs459x.svg" alt="Œº  =  log ‚ñ¥m
  t         t  " class="math";align="absmiddle">, the object in the middle of the inequality is
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs460x.svg" alt="                       Œº   ‚àíŒº
         ¬ØŒ∫t-‚àí-ct(mt-+-e-t)e--t
Àáœôt(Œºt) ‚â°        ¬ØŒ∫t ‚àí Œ∫t
                  Œºt  ‚àíŒºt    m        Œºt
ÀáœôŒº(Œºt) = ct(mt-+-e--)e---‚àí-Œ∫Œ∫Œ∫t (mt-+-e-)-.
 t                   ¬ØŒ∫t ‚àí Œ∫t
" class="math-display" ><a 
 id="x1-180005.13"></a></center></td></tr></table>
<!--l. 5--><p class="nopar" >
<!--l. 1--><p class="indent" >  As <img 
src="SolvingMicroDSOPs461x.svg" alt="m
  t  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs462x.svg" alt="‚àí m-
    t  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs463x.svg" alt="Àáœô (Œº )
  t  t  " class="math";align="absmiddle"> converges to zero, while as <img 
src="SolvingMicroDSOPs464x.svg" alt="m
  t  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs465x.svg" alt="+ ‚àû " class="math";align="absmiddle">,
<img 
src="SolvingMicroDSOPs466x.svg" alt="Àáœôt(Œºt)  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs467x.svg" alt="1  " class="math";align="absmiddle">.
<!--l. 5--><p class="indent" >  As before (in equation (<a 
href="#x1-4007r9">9<!--tex4ht:ref: eq:vEndtdefn --></a>)), we can derive an approximated consumption function; call it
<img 
src="SolvingMicroDSOPs468x.svg" alt="`Àáct  " class="math";align="absmiddle">. This function will clearly do a better job approximating the consumption function for low
                                                                                     
                                                                                     
values of <img 
src="SolvingMicroDSOPs469x.svg" alt="mt  " class="math";align="absmiddle"> while the previous approximation will perform better for high values of
<img 
src="SolvingMicroDSOPs470x.svg" alt="mt  " class="math";align="absmiddle">.
<!--l. 10--><p class="indent" >  For middling values of <img 
src="SolvingMicroDSOPs471x.svg" alt="m  " class="math";align="absmiddle"> it is not clear which of these functions will perform better.
However, an alternative is available which performs well. DeÔ¨Åne the highest gridpoint below
<img 
src="SolvingMicroDSOPs472x.svg" alt="  #
m t  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs473x.svg" alt="¬Ø #
Àám t  " class="math";align="absmiddle"> and the lowest gridpoint above <img 
src="SolvingMicroDSOPs474x.svg" alt="  #
m t  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs475x.svg" alt="  #
ÀÜm-t  " class="math";align="absmiddle">. Then there will be a unique
interpolating polynomial that matches the level and slope of the consumption function at
these two points. Call this function <img 
src="SolvingMicroDSOPs476x.svg" alt="Àúct(m )  " class="math";align="absmiddle">.
<!--l. 18--><p class="indent" >  Using indicator functions that are zero everywhere except for speciÔ¨Åed intervals,
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs477x.svg" alt=" 111Lo(m ) = 1 if m ‚â§ m¬ØÀá#
                     t#          #
111Mid(m ) = 1 if     ¬ØÀám t &#x003C; m  &#x003C; ÀÜm-t
                                 #
 111Hi(m ) = 1 if                ÀÜm-t ‚â§ m
" class="math-display" ></center></td></tr></table>
<!--l. 5--><p class="nopar" >
we can deÔ¨Åne a well-behaved approximating consumption function
  <table 
class="equation"><tr><td><a 
 id="x1-18002r46"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs478x.svg" alt="                `      `
`ct = 111Lo`Àáct + 111MidÀúct + 111HiÀÜct.
" class="math-display" ></center></td><td class="equation-label">(46)</td></tr></table>
<!--l. 9--><p class="nopar" >
<!--l. 2--><p class="indent" >  This just says that, for each interval, we use the approximation that is most appropriate.
The function is continuous and once-diÔ¨Äerentiable everywhere, and is therefore well behaved
                                                                                     
                                                                                     
for computational purposes.
<!--l. 17--><p class="indent" >  We now construct an upper-bound value function implied for a consumer whose spending
behavior is consistent with the reÔ¨Åned upper-bound consumption rule.
<!--l. 20--><p class="indent" >  For <img 
src="SolvingMicroDSOPs479x.svg" alt="m   ‚â• m#
  t     t  " class="math";align="absmiddle">, this consumption rule is the same as before, so the constructed upper-bound
value function is also the same. However, for values <img 
src="SolvingMicroDSOPs480x.svg" alt="        #
mt  &#x003C; m t  " class="math";align="absmiddle"> matters are slightly more
complicated.
<!--l. 24--><p class="indent" >  Start with the fact that at the cusp point,
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs481x.svg" alt="    #           #    T
¬Øvt(m t ) = u(¬Øct(m t ))‚ÑÇt
       =  u(‚ñ¥m#  ¬ØŒ∫t)‚ÑÇT .
                t    t
" class="math-display" ></center></td></tr></table>
<!--l. 29--><p class="nopar" >
<!--l. 31--><p class="indent" >  But for <span 
class="ecti-1200">all</span> <img 
src="SolvingMicroDSOPs482x.svg" alt="mt  " class="math";align="absmiddle">,
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs483x.svg" alt="¬Øvt(m ) = u(¬Øct(m )) + ¬Øùî≥t(m ‚àí ¬Øct(m )),
" class="math-display" ></center></td></tr></table>
<!--l. 34--><p class="nopar" >
and we assume that for the consumer below the cusp point consumption is given by <img 
src="SolvingMicroDSOPs484x.svg" alt="¬ØŒ∫‚ñ¥mt  " class="math";align="absmiddle"> so
for <img 
src="SolvingMicroDSOPs485x.svg" alt="mt &#x003C; m#t  " class="math";align="absmiddle">
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs486x.svg" alt="¬Øvt(m ) = u (¬ØŒ∫t‚ñ¥m ) + ¬Øùî≥t((1 ‚àí ¬ØŒ∫t)‚ñ¥m ),
" class="math-display" ></center></td></tr></table>
<!--l. 38--><p class="nopar" >
which is easy to compute because <img 
src="SolvingMicroDSOPs487x.svg" alt="¬Øùî≥t(at) = Œ≤ ¬Øvt+1 (at‚Ñõ  + 1)  " class="math";align="absmiddle"> where <img 
src="SolvingMicroDSOPs488x.svg" alt="¬Øvt  " class="math";align="absmiddle"> is as deÔ¨Åned above
because a consumer who ends the current period with assets exceeding the lower bound will
not expect to be constrained next period. (Recall again that we are merely constructing an
object that is guaranteed to be an <span 
class="ecti-1200">upper bound </span>for the value that the ‚Äòrealist‚Äô consumer will
experience.) At the gridpoints deÔ¨Åned by the solution of the consumption problem can then
construct
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs489x.svg" alt="¬ØŒõt(m ) = ((1 ‚àí œÅ)¬Øvt(m ))1‚àï(1‚àíœÅ)
" class="math-display" ></center></td></tr></table>
<!--l. 45--><p class="nopar" >
and its derivatives which yields the appropriate vector for constructing <img 
src="SolvingMicroDSOPs490x.svg" alt="ÀáX  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs491x.svg" alt="Àáœò  " class="math";align="absmiddle">. The rest
of the procedure is analogous to that performed for the consumption rule and is thus omitted
for brevity.
<!--l. 1809--><p class="indent" >  <a 
 id="Extension-A-Stochastic-Interest-Factor"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.14  </span> <a 
 id="x1-190005.14"></a>Extension: A Stochastic Interest Factor</h4>
<!--l. 1813--><p class="noindent" >Thus far we have assumed that the interest factor is constant at <img 
src="SolvingMicroDSOPs492x.svg" alt="R  " class="math";align="absmiddle">. Extending the previous
derivations to allow for a perfectly forecastable time-varying interest factor <img 
src="SolvingMicroDSOPs493x.svg" alt="R
  t  " class="math";align="absmiddle"> would be
trivial. Allowing for a stochastic interest factor is less trivial.
<!--l. 1818--><p class="indent" >  The easiest case is where the interest factor is i.i.d.,
  <table 
class="equation"><tr><td><a 
 id="x1-19001r47"></a>
  <center class="math-display" >
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs494x.svg" alt="                        2     2
log Rt+n ‚àº   ùí© (r + œï ‚àí œÉr‚àï2,œÉr) ‚àÄ n &#x003E; 0
" class="math-display" ></center></td><td class="equation-label">(47)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 1826--><p class="indent" >  where <img 
src="SolvingMicroDSOPs495x.svg" alt="œï  " class="math";align="absmiddle"> is the risk premium and the <img 
src="SolvingMicroDSOPs496x.svg" alt="œÉ2 ‚àï2
  r  " class="math";align="absmiddle"> adjustment to the mean log return guarantees
that an increase in <img 
src="SolvingMicroDSOPs497x.svg" alt=" 2
œÉr  " class="math";align="absmiddle"> constitutes a mean-preserving spread in the level of the
return.
<!--l. 1829--><p class="indent" >  This case is reasonably straightforward because <a 
href="#Xmerton:restat">Merton</a>¬†(<a 
href="#Xmerton:restat">1969</a>) and <a 
href="#Xsamuelson:portfolio">Samuelson</a>¬†(<a 
href="#Xsamuelson:portfolio">1969</a>)
showed that for a consumer without labor income (or with perfectly forecastable
labor income) the consumption function is linear, with an inÔ¨Ånite-horizon
MPC<span class="footnote-mark"><a 
href="SolvingMicroDSOPs21.html#fn20x0"><sup class="textsuperscript">20</sup></a></span><a 
 id="x1-19002f20"></a>  
  <table 
class="equation"><tr><td><a 
 id="x1-19003r48"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs498x.svg" alt="        (       1‚àíœÅ)1‚àïœÅ
Œ∫ = 1 ‚àí  Œ≤ ùîºt[R t+1 ]
" class="math-display" ></center></td><td class="equation-label">(48)</td></tr></table>
<!--l. 1834--><p class="nopar" >
and in this case the previous analysis applies once we substitute this MPC for the one that
characterizes the perfect foresight problem without rate-of-return risk.
<!--l. 1838--><p class="indent" >  The more realistic case where the interest factor has some serial correlation is more
complex. We consider the simplest case that captures the main features of empirical interest
rate dynamics: An AR(1) process. Thus the speciÔ¨Åcation is
  <table 
class="equation"><tr><td><a 
 id="x1-19004r49"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs499x.svg" alt="rt+1 ‚àí r = (rt ‚àí r)Œ≥ + ùúñt+1
" class="math-display" ></center></td><td class="equation-label">(49)</td></tr></table>
<!--l. 1843--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs500x.svg" alt="r  " class="math";align="absmiddle"> is the long-run mean log interest factor, <img 
src="SolvingMicroDSOPs501x.svg" alt="0 &#x003C;  Œ≥ &#x003C; 1  " class="math";align="absmiddle"> is the AR(1) serial correlation
coeÔ¨Écient, and <img 
src="SolvingMicroDSOPs502x.svg" alt="ùúñt+1   " class="math";align="absmiddle"> is the stochastic shock.
<!--l. 1847--><p class="indent" >  The consumer‚Äôs problem in this case now has two state variables, <img 
src="SolvingMicroDSOPs503x.svg" alt="m
  t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs504x.svg" alt="r
 t  " class="math";align="absmiddle">, and is
described by
  <table 
class="equation"><tr><td><a 
 id="x1-19005r50"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs505x.svg" alt="vt(mt, rt) = max  u(ct) + ùîºt [Œ≤t+1Œì 1‚àít+1œÅvt+1 (mt+1, rt+1)]
             ct
         s.t.

       at = mt ‚àí ct
 rt+1 ‚àí r = (rt ‚àí r)Œ≥ + ùúñt+1

    Rt+1 =  exp(rt+1)
    mt+1 =  (Rt+1‚àïŒì-t+1-)at + ùúÉt+1.
            ‚óü  ‚â°‚Ñõ‚óù‚óú   ‚óû
                  t+1
" class="math-display" ><a 
 id="x1-19005r49"></a></center></td></tr></table>
<!--l. 1857--><p class="nopar" >
<!--l. 1862--><p class="indent" >  We approximate the AR(1) process by a Markov transition matrix using standard
techniques. The stochastic interest factor is allowed to take on 11 values centered around the
steady-state value <img 
src="SolvingMicroDSOPs506x.svg" alt="r  " class="math";align="absmiddle"> and chosen [how?]. Given this Markov transition matrix, <span 
class="ecti-1200">conditional </span>on
the Markov AR(1) state the consumption functions for the ‚Äòoptimist‚Äô and the ‚Äòpessimist‚Äô will
still be linear, with identical MPC‚Äôs that are computed numerically. Given these MPC‚Äôs, the
(conditional) realist‚Äôs consumption function can be computed for each Markov state, and the
converged consumption rules constitute the solution contingent on the dynamics of the
stochastic interest rate process.
<!--l. 1868--><p class="indent" >  In principle, this reÔ¨Ånement should be combined with the previous one; further exposition of
this combination is omitted here because no new insights spring from the combination of the
two techniques.
<!--l. 1874--><p class="indent" >  <a 
 id="Imposing-Artificial-Borrowing-Constraints"></a>
                                                                                     
                                                                                     
  <h4 class="subsectionHead"><span class="titlemark">5.15  </span> <a 
 id="x1-200005.15"></a>Imposing ‚ÄòArtiÔ¨Åcial‚Äô Borrowing Constraints</h4>
<!--l. 1877--><p class="noindent" >Optimization problems often come with additional constraints that must
be satisÔ¨Åed. Particularly common is an ‚ÄòartiÔ¨Åcial‚Äô liquidity constraint that
prevents the consumer‚Äôs net worth from falling below some value, often
zero.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs22.html#fn21x0"><sup class="textsuperscript">21</sup></a></span><a 
 id="x1-20001f21"></a>  
The problem then becomes
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs507x.svg" alt="                                       1‚àí œÅ
vT‚àí1(mT ‚àí 1) = macTx‚àí1  u (cT ‚àí1) + ùîºT ‚àí1[Œ≤Œì T vT(mT )]

           s.t.
       aT‚àí1 = mT ‚àí 1 ‚àí cT ‚àí1

        mT  = ‚ÑõT  aT‚àí1 + ùúÉT
       aT‚àí1 ‚â•                                       0.
" class="math-display" ><a 
 id="x1-200005.15"></a></center></td></tr></table>
<!--l. 1889--><p class="nopar" >
<!--l. 1893--><p class="indent" >  By deÔ¨Ånition, the constraint will bind if the unconstrained consumer would choose a level of
spending that would violate the constraint. Here, that means that the constraint binds if the
<img 
src="SolvingMicroDSOPs508x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> that satisÔ¨Åes the unconstrained FOC
  <table 
class="equation"><tr><td><a 
 id="x1-20002r50"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs509x.svg" alt=" ‚àíœÅ     ‚Ä≤
cT‚àí1 = ùî≥T‚àí 1(mT ‚àí 1 ‚àí cT ‚àí1)
                                                                                     
                                                                                     
" class="math-display" ></center></td><td class="equation-label">(50)</td></tr></table>
<!--l. 1899--><p class="nopar" >
is greater than <img 
src="SolvingMicroDSOPs510x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">. Call <img 
src="SolvingMicroDSOPs511x.svg" alt="`c‚àó
 T‚àí1   " class="math";align="absmiddle"> the approximated function returning the level of <img 
src="SolvingMicroDSOPs512x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> that
satisÔ¨Åes (<a 
href="#x1-20002r50">50<!--tex4ht:ref: eq:cUnc --></a>). Then the approximated constrained optimal consumption function will be
  <table 
class="equation"><tr><td><a 
 id="x1-20003r51"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs513x.svg" alt="                          ‚àó
`cT‚àí1(mT ‚àí1) = min [mT ‚àí1,`cT‚àí1(mT ‚àí1)].
" class="math-display" ></center></td><td class="equation-label">(51)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 1915--><p class="indent" >  The introduction of the constraint also introduces a sharp nonlinearity in all of the
functions at the point where the constraint begins to bind. As a result, to get solutions that
are anywhere close to numerically accurate it is useful to augment the grid of values of the
state variable to include the exact value at which the constraint ceases to bind. Fortunately,
this is easy to calculate. We know that when the constraint is binding the consumer is saving
nothing, which yields marginal value of <img 
src="SolvingMicroDSOPs514x.svg" alt="ùî≥‚Ä≤  (0)
 T‚àí1  " class="math";align="absmiddle">. Further, when the constraint
is binding, <img 
src="SolvingMicroDSOPs515x.svg" alt="cT‚àí 1 = mT ‚àí1   " class="math";align="absmiddle">. Thus, the largest value of consumption for which the
constraint is binding will be the point for which the marginal utility of consumption is
exactly equal to the (expected, discounted) marginal value of saving 0. We know this
because the marginal utility of consumption is a downward-sloping function and
so if the consumer were to consume <img 
src="SolvingMicroDSOPs516x.svg" alt="ùúñ  " class="math";align="absmiddle"> more, the marginal utility of that extra
consumption would be <span 
class="ecti-1200">below </span>the (discounted, expected) marginal utility of saving, and
thus the consumer would engage in positive saving and the constraint would no
longer be binding. Thus the level of <img 
src="SolvingMicroDSOPs517x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle"> at which the lconstraint stops binding
is:<span class="footnote-mark"><a 
href="SolvingMicroDSOPs23.html#fn22x0"><sup class="textsuperscript">22</sup></a></span><a 
 id="x1-20004f22"></a>  
  <table 
class="equation"><tr><td><a 
 id="x1-20005r52"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs518x.svg" alt=" ‚Ä≤           ‚Ä≤
u(mT ‚àí 1) = ùî≥ T‚àí1(0)
   mT ‚àí1 = (ùî≥‚Ä≤   (0))(‚àí1‚àïœÅ)
             T ‚àí1
         = ùî†T‚àí 1(0 ).
" class="math-display" ><a 
 id="x1-20005r51"></a></center></td></tr></table>
<!--l. 1938--><p class="nopar" >
<!--l. 1940--><p class="indent" >  <a 
 id="cVScCon"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-2000618"></a>
                                                                                     
                                                                                     
<!--l. 1942--><p class="noindent" > <img 
src="./Figures/cVScCon.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†18:</span><span  
class="content">Constrained (solid) and Unconstrained (dashed) Consumption</span></figcaption><!--tex4ht:label?: x1-2000618 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1947--><p class="indent" >  The constrained problem is solved by <span 
class="ectt-1200">2periodIntExpFOCInvPesReaOptCon.m</span>; the
resulting consumption rule is shown in Figure <a 
href="#x1-2000618">18<!--tex4ht:ref: fig:cVScCon --></a>. For comparison purposes, the
approximate consumption rule from Figure <a 
href="#x1-2000618">18<!--tex4ht:ref: fig:cVScCon --></a> is reproduced here as the solid line. The
presence of the liquidity constraint requires three changes to the procedures outlined
above:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-20008x1">We redeÔ¨Åne <img 
src="SolvingMicroDSOPs519x.svg" alt="ùî•-
  t  " class="math";align="absmiddle">, which now is the PDV of receiving <img 
src="SolvingMicroDSOPs520x.svg" alt="ùúÉt+1 = ùúÉ-  " class="math";align="absmiddle"> next period and
      <img 
src="SolvingMicroDSOPs521x.svg" alt="ùúÉt+n =  0 ‚àÄ n &#x003E; 1  " class="math";align="absmiddle"> ‚Äì that is, the pessimist believes he will receive nothing beyond
      period <img 
src="SolvingMicroDSOPs522x.svg" alt="t + 1  " class="math";align="absmiddle">
      </li>
      <li 
  class="enumerate" id="x1-20010x2">We augment the end-of-period <span 
class="ectt-1200">aVec </span>with zero and with a point with a small
      positive value so that the generated <span 
class="ectt-1200">mVec </span>will the binding point <img 
src="SolvingMicroDSOPs523x.svg" alt="m#   " class="math";align="absmiddle"> and a point
      just above it (so that we can better capture the curvature around that point)
      </li>
      <li 
  class="enumerate" id="x1-20012x3">We redeÔ¨Åne the optimal consumption rule as in equation (<a 
href="#x1-20003r51">51<!--tex4ht:ref: eq:LiqCons --></a>). This ensures that
      the liquidity-constrained ‚Äòrealist‚Äô will consume more than the redeÔ¨Åned ‚Äòpessimist,‚Äô
      so that we will have <img 
src="SolvingMicroDSOPs524x.svg" alt="œô  " class="math";align="absmiddle"> still between <img 
src="SolvingMicroDSOPs525x.svg" alt="0  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs526x.svg" alt="1  " class="math";align="absmiddle"> and the ‚Äòmethod of moderation‚Äô
      will proceed smoothly.</li></ol>
<!--l. 1969--><p class="indent" >  As expected, the liquidity constraint only causes a divergence between the two functions at
the point where the optimal unconstrained consumption rule runs into the 45 degree
line.
<!--l. 1974--><p class="indent" >  <a 
 id="Recursions"></a>
  <h3 class="sectionHead"><span class="titlemark">6  </span> <a 
 id="x1-210006"></a>Recursion</h3>
<!--l. 1976--><p class="noindent" ><a 
 id="Theory"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.1  </span> <a 
 id="x1-220006.1"></a>Theory</h4>
<!--l. 1978--><p class="noindent" >Before we solve for periods earlier than <img 
src="SolvingMicroDSOPs527x.svg" alt="T ‚àí  1  " class="math";align="absmiddle">, we assume for convenience that in each such
period a liquidity constraint exists of the kind discussed above, preventing <img 
src="SolvingMicroDSOPs528x.svg" alt="c  " class="math";align="absmiddle"> from exceeding
<img 
src="SolvingMicroDSOPs529x.svg" alt="m  " class="math";align="absmiddle">. This simpliÔ¨Åes things a bit because now we can always consider an <span 
class="ectt-1200">aVec </span>that starts with
zero as its smallest element.
<!--l. 1984--><p class="indent" >  Recall now equations¬†(<a 
href="#x1-4009r11">11<!--tex4ht:ref: eq:vEndPrimetOfc --></a>) and (<a 
href="#x1-4010r12">12<!--tex4ht:ref: eq:upEqbetaOp --></a>):
  <table 
class="equation-star"><tr><td>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs530x.svg" alt="ùî≥‚Ä≤(a ) = ùîº [Œ≤R Œì ‚àíœÅu ‚Ä≤(c   (‚Ñõ   a  + ùúÉ   ))]
 t‚Ä≤ t     t‚Ä≤     t+1    t+1   t+1 t    t+1
u (ct) = ùî≥t(mt ‚àí  ct).
" class="math-display" ></center></td></tr></table>
<!--l. 1989--><p class="nopar" >
Assuming that the problem has been solved up to period <img 
src="SolvingMicroDSOPs531x.svg" alt="t + 1  " class="math";align="absmiddle"> (and thus assuming that we
have an approximated <img 
src="SolvingMicroDSOPs532x.svg" alt="`c   (m    )
 t+1   t+1  " class="math";align="absmiddle">), our solution method essentially involves using
these two equations in succession to work back progressively from period <img 
src="SolvingMicroDSOPs533x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> to
the beginning of life. Stated generally, the method is as follows. (Here, we use the
original, rather than the ‚ÄúreÔ¨Åned,‚Äù method for constructing consumption functions;
the generalization of the algorithm below to use the reÔ¨Åned method presents no
diÔ¨Éculties.)
<!--l. 1998--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-22002x1">For the grid of values <img 
src="SolvingMicroDSOPs534x.svg" alt="at,i  " class="math";align="absmiddle"> in <span 
class="ectt-1200">aVec</span><img 
src="SolvingMicroDSOPs535x.svg" alt="t  " class="math";align="absmiddle">, numerically calculate the values of <img 
src="SolvingMicroDSOPs536x.svg" alt="ùî†t(at,i)  " class="math";align="absmiddle"> and
      <img 
src="SolvingMicroDSOPs537x.svg" alt="ùî†at(at,i)  " class="math";align="absmiddle">,
      <table 
class="equation"><tr><td><a 
 id="x1-22003r52"></a>
      <center class="math-display" >
      <img 
src="SolvingMicroDSOPs538x.svg" alt="        ‚Ä≤     ‚àí1‚àïœÅ
ùî†t,i = (ùî≥t(at,i))    ,
      (    [   ‚àíœÅ                      ‚àíœÅ])‚àí 1‚àïœÅ
   =   Œ≤ ùîºt R Œìt+1(`ct+1(‚Ñõt+1at,i + ùúÉt+1))        ,
ùî†a =  ‚àí (1 ‚àïœÅ)(ùî≥‚Ä≤(a  ))‚àí 1‚àí 1‚àïœÅ ùî≥‚Ä≤‚Ä≤(a ),
 t,i            t  t,i         t  t,i
      " class="math-display" ></center></td><td class="equation-label">(52)</td></tr></table>
      <!--l. 5--><p class="nopar" >
      <!--l. 2013--><p class="noindent" >generating vectors of values <img 
src="SolvingMicroDSOPs539x.svg" alt="‚Éóùî†t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs540x.svg" alt="‚Éóùî†at  " class="math";align="absmiddle">.
                                                                                     
                                                                                     
      </li>
      <li 
  class="enumerate" id="x1-22005x2">Construct a corresponding list of values of <img 
src="SolvingMicroDSOPs541x.svg" alt="ct,i  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs542x.svg" alt="mt,i  " class="math";align="absmiddle"> from <img 
src="SolvingMicroDSOPs543x.svg" alt="ct,i = ùî†t,i  " class="math";align="absmiddle"> and
      <img 
src="SolvingMicroDSOPs544x.svg" alt="mt,i = ct,i + at,i  " class="math";align="absmiddle">; similarly construct a corresponding list of <img 
src="SolvingMicroDSOPs545x.svg" alt="Œ∫t,i  " class="math";align="absmiddle"> using equation
      (<a 
href="#x1-16005r38">38<!--tex4ht:ref: eq:MPCfromMPTHC --></a>).
      </li>
      <li 
  class="enumerate" id="x1-22007x3">Construct a corresponding list of <img 
src="SolvingMicroDSOPs546x.svg" alt="Œºt,i  " class="math";align="absmiddle">, the levels and Ô¨Årst derivatives of <img 
src="SolvingMicroDSOPs547x.svg" alt="œôt,i  " class="math";align="absmiddle">, and the
      levels and Ô¨Årst derivatives of <img 
src="SolvingMicroDSOPs548x.svg" alt="œát,i  " class="math";align="absmiddle">.
      </li>
      <li 
  class="enumerate" id="x1-22009x4">Construct an interpolating approximation <img 
src="SolvingMicroDSOPs549x.svg" alt="œá`t  " class="math";align="absmiddle"> that smoothly matches both the level and
      the slope at those points.
      </li>
      <li 
  class="enumerate" id="x1-22011x5">If we are to approximate the value function, construct a corresponding list of values of
      <img 
src="SolvingMicroDSOPs550x.svg" alt="vt,i  " class="math";align="absmiddle">, the levels and Ô¨Årst derivatives of <img 
src="SolvingMicroDSOPs551x.svg" alt="œòt,i  " class="math";align="absmiddle">, and the levels and Ô¨Årst derivatives of
      <img 
src="SolvingMicroDSOPs552x.svg" alt="ÀÜXt,i  " class="math";align="absmiddle">; and construct an interpolating approximation <img 
src="SolvingMicroDSOPs553x.svg" alt="ÀÜXt  " class="math";align="absmiddle"> that matches those
      points.</li></ol>
<!--l. 2026--><p class="indent" >  With <img 
src="SolvingMicroDSOPs554x.svg" alt="œá`t  " class="math";align="absmiddle"> in hand, our approximate consumption function is computed directly from the
appropriate substitutions in (<a 
href="#x1-15007r33">33<!--tex4ht:ref: eq:cFuncHi --></a>) and related equations. With this consumption rule in hand,
we can continue the backwards recursion to period <img 
src="SolvingMicroDSOPs555x.svg" alt="t ‚àí 1  " class="math";align="absmiddle"> and so on back to the beginning of
life.
<!--l. 2032--><p class="indent" >  Note that this loop does not contain steps for constructing <img 
src="SolvingMicroDSOPs556x.svg" alt=" ‚Ä≤
ÀÜvt(mt )  " class="math";align="absmiddle">. This is because with
<img 
src="SolvingMicroDSOPs557x.svg" alt="`ÀÜct(mt)  " class="math";align="absmiddle"> in hand, we simply <span 
class="ecti-1200">deÔ¨Åne</span> <img 
src="SolvingMicroDSOPs558x.svg" alt="ÀÜv ‚Ä≤t(mt ) = u‚Ä≤(`ÀÜct(mt ))  " class="math";align="absmiddle"> so there is no need to construct
interpolating approximations - the function arises ‚Äòfree‚Äô (or nearly so) from our constructed
<img 
src="SolvingMicroDSOPs559x.svg" alt="`ÀÜct(mt)  " class="math";align="absmiddle">.
<!--l. 2040--><p class="indent" >  The program <span 
class="ectt-1200">multiperiodCon.m</span><span class="footnote-mark"><a 
href="SolvingMicroDSOPs24.html#fn23x0"><sup class="textsuperscript">23</sup></a></span><a 
 id="x1-22012f23"></a>  
presents a fairly general and Ô¨Çexible approach to solving problems of this kind. The essential
structure of the program is a loop that simply works its way back from an assumed last period
of life, using the command <span 
class="ectt-1200">AppendTo </span>to record the interpolated <img 
src="SolvingMicroDSOPs560x.svg" alt="`œát  " class="math";align="absmiddle"> functions in the earlier
time periods back from the end. For a realistic life cycle problem, it would also be necessary at
a minimum to calibrate a nonconstant path of expected income growth over the
lifetime that matches the empirical proÔ¨Åle; allowing for such a calibration is the
reason we have included the <img 
src="SolvingMicroDSOPs561x.svg" alt="{Œì }Tt  " class="math";align="absmiddle"> vector in our computational speciÔ¨Åcation of the
problem.
<!--l. 2052--><p class="indent" >  <a 
 id="Mathmatica-Background"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.2  </span> <a 
 id="x1-230006.2"></a><span 
class="ecti-1200">Mathematica</span>¬†Background</h4>
<!--l. 2054--><p class="noindent" ><span 
class="ecti-1200">Mathematica</span>¬†has several features that are useful in solving the multiperiod problem.
                                                                                     
                                                                                     
      <ul class="itemize1">
      <li class="itemize">It can treat a user-created function as an object just like a number or a character.
      </li>
      <li class="itemize"><span 
class="ecti-1200">Mathematica</span>¬†uses the ‚Äòlist‚Äô as its basic data structure. A <span 
class="ecti-1200">Mathematica</span>¬†‚Äòlist‚Äô is a
      very powerful and Ô¨Çexible data construct. A list of length N in <span 
class="ecti-1200">Mathematica</span>¬†can
      hold essentially anything in each of its <img 
src="SolvingMicroDSOPs562x.svg" alt="N um  " class="math";align="absmiddle"> positions - a function, a number,
      another list, a symbolic expression, or any other object that <span 
class="ecti-1200">Mathematica</span>¬†can
      recognize. The items at position <img 
src="SolvingMicroDSOPs563x.svg" alt="i  " class="math";align="absmiddle"> in a list named <span 
class="ectt-1200">ExampleList </span>are retrieved or
      addressed using the syntax <span 
class="ectt-1200">ExampleList[[i]]</span>.
      </li>
      <li class="itemize">The function <span 
class="ectt-1200">Apply[FuncName_, DataListName_] </span>takes the function whose name
      is  <span 
class="ectt-1200">FuncName </span>(for  example,  <span 
class="ectt-1200">Vt</span>)  and  the  data  in  <span 
class="ectt-1200">DataListName </span>(for  example,
      <img 
src="SolvingMicroDSOPs564x.svg" alt="{1,19} " class="math";align="absmiddle">) and returns the result that would have been returned by calling the
      function <span 
class="ectt-1200">Vt[1,19]</span>.
      </li>
      <li class="itemize">The  function  <span 
class="ectt-1200">Map[FuncToApply_,DataToApplyItTo_] </span>takes  a  list  of  possible
      arguments to the function <span 
class="ectt-1200">FuncToApply </span>and applies that function to each of the
      elements of that list sequentially. For example, <span 
class="ectt-1200">Map[Sin,{1,2,3}] </span>would return a
      list <span 
class="ectt-1200">{Sin[1],Sin[2],Sin[3]}</span>.
      </li></ul>
<!--l. 2083--><p class="indent" >  <a 
 id="Program-Structure"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.3  </span> <a 
 id="x1-240006.3"></a>Program Structure</h4>
<!--l. 2086--><p class="noindent" >After the usual initializations, the heart of the program works like this.
<!--l. 2089--><p class="indent" >  <a 
 id="Iteration"></a>
  <h5 class="subsubsectionHead"><span class="titlemark">6.3.1  </span> <a 
 id="x1-250006.3.1"></a>Iteration</h5>
<!--l. 2092--><p class="noindent" >After setting up a variable <span 
class="ectt-1200">PeriodsToSolve </span>which deÔ¨Ånes the total number of periods that the
program will solve, the program sets up a ‚Äú<span 
class="ectt-1200">Do[SolveAnotherPeriod,{PeriodsToSolve}]</span>‚Äù
loop that runs the function <span 
class="ectt-1200">SolveAnotherPeriod </span>the number of times corresponding to
<span 
class="ectt-1200">PeriodsToSolve</span>. Every time <span 
class="ectt-1200">SolveAnotherPeriod </span>is run, the interpolated consumption
function for one period of life earlier is calculated. The structure of the <span 
class="ectt-1200">SolveAnotherPeriod</span>
function is as follows:
<!--l. 2104--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-25002x1">Add  various  period-t  parameters  to  their  respective  lifecycle  lists,  which  is
      accomplished by calling the <span 
class="ectt-1200">AddNewPeriodToParamLifeDates </span>function.
                                                                                     
                                                                                     
      </li>
      <li 
  class="enumerate" id="x1-25004x2">For each <img 
src="SolvingMicroDSOPs565x.svg" alt="at,i  " class="math";align="absmiddle"> in <span 
class="ectt-1200">aVec</span>, construct <img 
src="SolvingMicroDSOPs566x.svg" alt="ùî†   " class="math";align="absmiddle"> as follows:
      <table 
class="equation"><tr><td><a 
 id="x1-25005r53"></a>
      <center class="math-display" >
      <img 
src="SolvingMicroDSOPs567x.svg" alt="         (     [   ‚àíœÅ                      ‚àíœÅ]) ‚àí1‚àïœÅ
ùî†t(at,i) =  Œ≤ ùîºt R Œìt+1(`ÀÜct+1(‚Ñõt+1at,i + ùúÉt+1))
         (                                       ) ‚àí 1‚àïœÅ
             1  n‚àëùúÉ   (  ‚àíœÅ                    ‚àíœÅ)
       =   Œ≤ ---   R   Œìt+1(`ÀÜct+1(‚Ñõt+1at,i + ùúÉi))        .
             nùúÉ i=1
      " class="math-display" ></center></td><td class="equation-label">(53)</td></tr></table>
      <!--l. 2112--><p class="nopar" >
      and similarly construct the corresponding <img 
src="SolvingMicroDSOPs568x.svg" alt="ùî†at(at,i)  " class="math";align="absmiddle"> We also construct the corresponding
      <span 
class="ectt-1200">mVec</span>, <img 
src="SolvingMicroDSOPs569x.svg" alt="Œ∫   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span>, etc. by calling the <span 
class="ectt-1200">AddNewPeriodToSolvedLifeDates </span>function.
      </li>
      <li 
  class="enumerate" id="x1-25007x3">For each <img 
src="SolvingMicroDSOPs570x.svg" alt="m  " class="math";align="absmiddle"> in <span 
class="ectt-1200">mVec</span>, we can deÔ¨Åne <img 
src="SolvingMicroDSOPs571x.svg" alt="‚ñ¥m   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span>, Ô¨Ånd the corresponding optimal
      consumption vector for a pessimist and an optimist, construct the <img 
src="SolvingMicroDSOPs572x.svg" alt="œô  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs573x.svg" alt="œá  " class="math";align="absmiddle">
      vectors, and Ô¨Ånally an interpolation function <img 
src="SolvingMicroDSOPs574x.svg" alt="œá`t  " class="math";align="absmiddle">. Similarly we can construct an
      interpolation function <img 
src="SolvingMicroDSOPs575x.svg" alt="`Xt  " class="math";align="absmiddle"> that approximates the value function. The whole
      process is done by calling the <span 
class="ectt-1200">AddNewPeriodToSolvedLifeDatesPesReaOpt</span>
      function.
      </li>
      <li 
  class="enumerate" id="x1-25009x4">Various period-<img 
src="SolvingMicroDSOPs576x.svg" alt="t  " class="math";align="absmiddle"> functions are derived from <img 
src="SolvingMicroDSOPs577x.svg" alt="`œát  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs578x.svg" alt="`
Xt  " class="math";align="absmiddle"> (in <span 
class="ectt-1200">functions_ConsNVal.m</span>).
      Note that the liquidity constraint is dealt with by comparing the unconstrained solution
      <img 
src="SolvingMicroDSOPs579x.svg" alt="c   " class="math";align="absmiddle"><span 
class="ectt-1200">From</span><img 
src="SolvingMicroDSOPs580x.svg" alt="œá   " class="math";align="absmiddle"> with the 45 degree line.</li></ol>
<!--l. 2134--><p class="indent" >  <a 
 id="Results"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.4  </span> <a 
 id="x1-260006.4"></a>Results</h4>
<!--l. 2137--><p class="noindent" >As written, the program creates <img 
src="SolvingMicroDSOPs581x.svg" alt="`œá (Œº )
  t t   " class="math";align="absmiddle"> functions from which the relevant <img 
src="SolvingMicroDSOPs582x.svg" alt="`c (m  )
 t   t  " class="math";align="absmiddle"> functions
are recovered in any period for any value of <img 
src="SolvingMicroDSOPs583x.svg" alt="m  " class="math";align="absmiddle">.
<!--l. 2141--><p class="indent" >  <a 
 id="PlotCFuncsConverge"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-2600119"></a>
                                                                                     
                                                                                     
<!--l. 2143--><p class="noindent" > <img 
src="./Figures/PlotCFuncsConverge.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†19:</span><span  
class="content">Converging <img 
src="SolvingMicroDSOPs584x.svg" alt="`cT ‚àín(m )  " class="math";align="absmiddle"> Functions as <img 
src="SolvingMicroDSOPs585x.svg" alt="n  " class="math";align="absmiddle"> Increases</span></figcaption><!--tex4ht:label?: x1-2600119 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2149--><p class="indent" >  As an illustration, Figure <a 
href="#x1-2600119">19<!--tex4ht:ref: fig:PlotCFuncsConverge --></a> shows <img 
src="SolvingMicroDSOPs586x.svg" alt="`cT‚àí n(m )  " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs587x.svg" alt="n = {20, 15,10,5,1} " class="math";align="absmiddle">. At least one feature
of this Ô¨Ågure is encouraging: the consumption functions converge as the horizon
extends, something that <a 
href="#XBufferStockTheory">Carroll</a>¬†(<a 
href="#XBufferStockTheory">Forthcoming</a>) shows must be true under certain
parametric conditions that are satisÔ¨Åed by the baseline parameter values being used
here.
<!--l. 2669--><p class="indent" >  <a 
 id="Multiple-Control-Variables"></a>
  <h3 class="sectionHead"><span class="titlemark">7  </span> <a 
 id="x1-270007"></a>Multiple Control Variables</h3>
<!--l. 2672--><p class="noindent" >We now consider how to solve problems with multiple control variables. (To reduce notational
complexity, in this section we set <img 
src="SolvingMicroDSOPs588x.svg" alt="Œì t = 1 ‚àÄ t  " class="math";align="absmiddle">.)
<!--l. 2675--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">7.1  </span> <a 
 id="x1-280007.1"></a>Theory</h4>
<!--l. 2676--><p class="noindent" >The new control variable that the consumer can now choose is the portion of the portfolio to
invest in risky assets. Designating the gross return on the risky asset as <img 
src="SolvingMicroDSOPs589x.svg" alt="Rt+1   " class="math";align="absmiddle">, and using <img 
src="SolvingMicroDSOPs590x.svg" alt="œÇt  " class="math";align="absmiddle">
to represent the proportion of the portfolio invested in this asset between <img 
src="SolvingMicroDSOPs591x.svg" alt="t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs592x.svg" alt="t + 1  " class="math";align="absmiddle">
(restricted here, as often in the literature, to values between 0 and 1, corresponding
to an assumption that the consumer cannot be ‚Äònet short‚Äô and cannot issue net
equity), the overall return on the consumer‚Äôs portfolio between <img 
src="SolvingMicroDSOPs593x.svg" alt="t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs594x.svg" alt="t + 1  " class="math";align="absmiddle"> will be:
  <table 
class="equation"><tr><td><a 
 id="x1-28001r54"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs595x.svg" alt="Rt+1 =  R(1 ‚àí œÇt) + Rt+1 œÇt
     =  R + (R    ‚àí R)œÇ
              t+1      t
" class="math-display" ></center></td><td class="equation-label">(54)</td></tr></table>
<!--l. 4--><p class="nopar" >
and the maximization problem is
  <table 
class="equation-star"><tr><td>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs596x.svg" alt="v (m  ) = max   u(c ) + Œ≤ ùîº [v  (m   )]
 t   t   {ct,œÇt}     t       t t+1   t+1

      s.t.
  Rt+1 = R +  (Rt+1  ‚àí R)œÇt
  m    = (m  ‚àí  c)R    + ùúÉ
    t+1      t    t  t+1    t+1
   0 ‚â§œÇt                                 ‚â§ 1,
" class="math-display" ><a 
 id="x1-280007.1"></a></center></td></tr></table>
<!--l. 8--><p class="nopar" >
or, more compactly,
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs597x.svg" alt="vt(mt) = m{acxt,œÇt}  u(ct) + ùîºt[Œ≤vt+1((mt ‚àí ct)Rt+1 + ùúÉt+1)]

      s.t.
   0 ‚â§ œÇt                                              ‚â§  1.
" class="math-display" ></center></td></tr></table>
<!--l. 2710--><p class="nopar" >
The Ô¨Årst order condition with respect to <img 
src="SolvingMicroDSOPs598x.svg" alt="ct  " class="math";align="absmiddle"> is almost identical to that in the single-control
problem, equation (<a 
href="#x1-4001r4">5<!--tex4ht:ref: eq:upceqEvtp1 --></a>), with the only diÔ¨Äerence being that the nonstochastic interest factor <img 
src="SolvingMicroDSOPs599x.svg" alt="R  " class="math";align="absmiddle">
is now replaced by <img 
src="SolvingMicroDSOPs600x.svg" alt="Rt+1   " class="math";align="absmiddle">,
  <table 
class="equation"><tr><td><a 
 id="x1-28002r55"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs601x.svg" alt=" ‚Ä≤                 ‚Ä≤
u (ct) = Œ≤ ùîºt[Rt+1v t+1(mt+1 )],
" class="math-display" ></center></td><td class="equation-label">(55)</td></tr></table>
<!--l. 3--><p class="nopar" >
and the Envelope theorem derivation remains the same, yielding the Euler equation for
consumption
  <table 
class="equation"><tr><td><a 
 id="x1-28003r56"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs602x.svg" alt="u‚Ä≤(ct) = ùîºt[Œ≤Rt+1u ‚Ä≤(ct+1)].
" class="math-display" ></center></td><td class="equation-label">(56)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 2730--><p class="indent" >  The Ô¨Årst order condition with respect to the risky portfolio share is
  <table 
class="equation"><tr><td><a 
 id="x1-28004r57"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs603x.svg" alt="         ‚Ä≤
0 =  ùîºt[v t+1(mt+1 )(Rt+1 ‚àí R)at]
  =  atùîºt[u‚Ä≤(ct+1(mt+1))(Rt+1 ‚àí  R)].
" class="math-display" ><a 
 id="x1-28004r56"></a></center></td></tr></table>
<!--l. 4--><p class="nopar" >
<!--l. 2739--><p class="indent" >  As before, it will be useful to deÔ¨Åne <img 
src="SolvingMicroDSOPs604x.svg" alt="ùî≥t  " class="math";align="absmiddle"> as a function that yields the expected <img 
src="SolvingMicroDSOPs605x.svg" alt="t + 1  " class="math";align="absmiddle"> value
of ending period <img 
src="SolvingMicroDSOPs606x.svg" alt="t  " class="math";align="absmiddle"> in a given state. However, now that there are two control variables, the
expectation must be deÔ¨Åned as a function of the chosen values of both of those variables,
because expected end-of-period value will depend not just on how much the agent saves, but
also on how the saved assets are allocated between the risky and riskless assets. Thus we
                                                                                     
                                                                                     
deÔ¨Åne
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs607x.svg" alt="ùî≥t(at,œÇt) = ùîºt [Œ≤vt+1 (mt+1 )]
" class="math-display" ></center></td></tr></table>
<!--l. 2748--><p class="nopar" >
which has derivatives
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs608x.svg" alt="ùî≥a = ùîº [Œ≤R    vm  (m   )]
 tœÇ     t   t+1 t+1   t+m1
ùî≥t = ùîºt[Œ≤(Rt+1  ‚àí R)vt+1(mt+1 )]at
" class="math-display" ></center></td></tr></table>
<!--l. 2753--><p class="nopar" >
implying that the Ô¨Årst order conditions (<a 
href="#x1-28003r56">56<!--tex4ht:ref: eq:EulercRiskyR --></a>) and (<a 
href="#x1-28004r56">57<!--tex4ht:ref: eq:FOCw --></a>) can be rewritten
  <table 
class="equation"><tr><td><a 
 id="x1-28005r57"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs609x.svg" alt=" ‚Ä≤       a
u (ct) = ùî≥t(mt ‚àí ct,œÇt)
    0 = ùî≥œÇt(at,œÇt).
" class="math-display" ></center></td><td class="equation-label">(57)</td></tr></table>
<!--l. 2759--><p class="nopar" >
                                                                                     
                                                                                     
<!--l. 2761--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">7.2  </span> <a 
 id="x1-290007.2"></a>Application</h4>
<!--l. 2763--><p class="noindent" >Our Ô¨Årst step is to specify the stochastic process for <img 
src="SolvingMicroDSOPs610x.svg" alt="Rt+1   " class="math";align="absmiddle">. We follow the common practice of
assuming that returns are lognormally distributed, <img 
src="SolvingMicroDSOPs611x.svg" alt="log R ‚àº ùí©  (œï + r ‚àí œÉ2œï ‚àï2,œÉ2œï)  " class="math";align="absmiddle">
where <img 
src="SolvingMicroDSOPs612x.svg" alt="œï  " class="math";align="absmiddle"> is the equity premium over the returns <img 
src="SolvingMicroDSOPs613x.svg" alt="r  " class="math";align="absmiddle"> available on the riskless
asset.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs25.html#fn24x0"><sup class="textsuperscript">24</sup></a></span><a 
 id="x1-29001f24"></a>  
<!--l. 2769--><p class="indent" >  As with labor income uncertainty, it is necessary to discretize the rate-of-return risk in order
to have a problem that is soluble in a reasonable amount of time. We follow the same
procedure as for labor income uncertainty, generating a set of <img 
src="SolvingMicroDSOPs616x.svg" alt="nr  " class="math";align="absmiddle"> equiprobable shocks to the
rate of return; in a slight abuse of notation, we will designate the portfolio-weighted return
(contingent on the chosen portfolio share in equity, and potentially contingent on any other
aspect of the consumer‚Äôs problem) simply as <img 
src="SolvingMicroDSOPs617x.svg" alt="Ri,j  " class="math";align="absmiddle"> (where dependence on <img 
src="SolvingMicroDSOPs618x.svg" alt="i  " class="math";align="absmiddle"> is allowed to
permit the possibility of nonzero correlation between the return on the risky asset and the
shock to labor income (for example, in recessions the stock market falls and labor income also
declines).
<!--l. 2781--><p class="indent" >  The direct expressions for the derivatives of <img 
src="SolvingMicroDSOPs619x.svg" alt="ùî≥t  " class="math";align="absmiddle"> are
  <table 
class="equation"><tr><td><a 
 id="x1-29002r58"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs620x.svg" alt="             (      ) n‚àëùúÉ ‚àënr
ùî≥a(a ,œÇ) = Œ≤   --1--         R   (c   (R   a +  ùúÉ))‚àíœÅ
 t  t  t       nrn ùúÉ           i,j  t+1   i,j t    i
             (      ) in=1 j=1
 œÇ             --1--  ‚àëùúÉ ‚àënr                            ‚àíœÅ
ùî≥t(at,œÇt) = Œ≤   n n           (Ri,j ‚àí R )(ct+1(Ri,jat + ùúÉi)) .
                r  ùúÉ  i=1 j=1
" class="math-display" ></center></td><td class="equation-label">(58)</td></tr></table>
<!--l. 2785--><p class="nopar" >
<!--l. 2787--><p class="indent" >  Writing these equations out explicitly makes a problem very apparent: For every diÔ¨Äerent
combination of <img 
src="SolvingMicroDSOPs621x.svg" alt="{at,œÇt} " class="math";align="absmiddle"> that the routine wishes to consider, it must perform two
double-summations of <img 
src="SolvingMicroDSOPs622x.svg" alt="nr √ó n  " class="math";align="absmiddle"> terms. Once again, there is an ineÔ¨Éciency if it must perform
these same calculations many times for the same or nearby values of <img 
src="SolvingMicroDSOPs623x.svg" alt="{at,œÇt} " class="math";align="absmiddle">, and
                                                                                     
                                                                                     
again the solution is to construct an approximation to the derivatives of the <img 
src="SolvingMicroDSOPs624x.svg" alt="ùî≥  " class="math";align="absmiddle">
function.
<!--l. 2796--><p class="indent" >  Details of the construction of the interpolating approximation are given below; assume for
the moment that we have the approximations <img 
src="SolvingMicroDSOPs625x.svg" alt="ÀÜùî≥a
 t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs626x.svg" alt="ÀÜùî≥œÇ
 t  " class="math";align="absmiddle"> in hand and we want to proceed.
As noted above, nonlinear equation solvers (including those built into <span 
class="ecti-1200">Mathematica</span>) can Ô¨Ånd
the solution to a set of simultaneous equations. Thus we could ask <span 
class="ecti-1200">Mathematica</span>¬†to
solve
  <table 
class="equation"><tr><td><a 
 id="x1-29003r59"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs627x.svg" alt=" ‚àíœÅ    a
ct  = ÀÜùî≥t(mt ‚àí ct,œÇt)
  0 = ÀÜùî≥œÇt(mt ‚àí ct,œÇt)
" class="math-display" ></center></td><td class="equation-label">(59)</td></tr></table>
<!--l. 2806--><p class="nopar" >
simultaneously for <img 
src="SolvingMicroDSOPs628x.svg" alt="c  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs629x.svg" alt="œÇ  " class="math";align="absmiddle"> at the set of potential <img 
src="SolvingMicroDSOPs630x.svg" alt="mt  " class="math";align="absmiddle"> values deÔ¨Åned in <span 
class="ectt-1200">mVec</span>. However,
multidimensional constrained maximization problems are diÔ¨Écult and sometimes quite slow to
solve. There is a better way. DeÔ¨Åne the problem
  <table 
class="equation"><tr><td><a 
 id="x1-29004r60"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs631x.svg" alt="Àúùî≥t(at) = maxœÇt   ùî≥t(at,œÇt)

     s.t.
  0 ‚â§ œÇt                ‚â§ 1
" class="math-display" ></center></td></tr></table>
<!--l. 2815--><p class="nopar" >
where the typographical diÔ¨Äerence between <img 
src="SolvingMicroDSOPs632x.svg" alt="Àúùî≥  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs633x.svg" alt="ùî≥  " class="math";align="absmiddle"> indicates that this is the <img 
src="SolvingMicroDSOPs634x.svg" alt="ùî≥  " class="math";align="absmiddle"> that has been
optimized with respect to all of the arguments other than the one still present (<img 
src="SolvingMicroDSOPs635x.svg" alt="at  " class="math";align="absmiddle">). We solve this
problem for the set of gridpoints in <span 
class="ectt-1200">aVec </span>and use the results to construct the interpolating function
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs636x.svg" alt="`a
Àúùî≥t(at)  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs26.html#fn25x0"><sup class="textsuperscript">25</sup></a></span><a 
 id="x1-29005f25"></a>  
With this function in hand, we can use the Ô¨Årst order condition from the single-control
problem
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs639x.svg" alt=" ‚àíœÅ
ct  = `Àúùî≥at(mt ‚àí  ct)
" class="math-display" ></center></td></tr></table>
<!--l. 2832--><p class="nopar" >
to solve for the optimal level of consumption as a function of <img 
src="SolvingMicroDSOPs640x.svg" alt="mt  " class="math";align="absmiddle">. Thus we have transformed
the multidimensional optimization problem into a sequence of two simple optimization
problems for which solutions are much easier and more reliable.
<!--l. 2838--><p class="indent" >  Note the parallel between this trick and the fundamental insight of dynamic programming:
Dynamic programming techniques transform a multi-period (or inÔ¨Ånite-period) optimization
problem into a sequence of two-period optimization problems which are individually much
easier to solve; we have done the same thing here, but with multiple dimensions of controls
rather than multiple periods.
<!--l. 2845--><p class="indent" >  <a 
 id="Implementation"></a>
  <h4 class="subsectionHead"><span class="titlemark">7.3  </span> <a 
 id="x1-300007.3"></a>Implementation</h4>
<!--l. 2848--><p class="noindent" >The program which solves the constrained problem with multiple control variables is
<span 
class="ectt-1200">multicontrolCon.m</span>.
<!--l. 2851--><p class="indent" >  Some of the functions deÔ¨Åned in <span 
class="ectt-1200">multicontrolCon.m </span>correspond to the derivatives of
<img 
src="SolvingMicroDSOPs641x.svg" alt="ùî≥t(at,œÇt)  " class="math";align="absmiddle">.
<!--l. 2860--><p class="indent" >  The Ô¨Årst function deÔ¨Ånition that does not resemble anything in <span 
class="ectt-1200">multiperiod.m </span>is
<img 
src="SolvingMicroDSOPs642x.svg" alt="œÇ   " class="math";align="absmiddle"><span 
class="ectt-1200">Raw[at_]</span>. This function, for its input value of <img 
src="SolvingMicroDSOPs643x.svg" alt="at  " class="math";align="absmiddle">, calculates the value of the portfolio
share <img 
src="SolvingMicroDSOPs644x.svg" alt="œÇt  " class="math";align="absmiddle"> which satisÔ¨Åes the Ô¨Årst order condition (<a 
href="#x1-29003r59">59<!--tex4ht:ref: eq:FOCwrtw --></a>), tests whether the optimal portfolio
share would violate the constraints, and if so resets the portfolio share to the constrained
optimum. The function returns the optimal value of the portfolio share itself, <img 
src="SolvingMicroDSOPs645x.svg" alt="œÇ‚àót  " class="math";align="absmiddle">, from which
the functions <img 
src="SolvingMicroDSOPs646x.svg" alt="¬Øùî≥at(at)  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs647x.svg" alt="ÀÜœÇt(at)  " class="math";align="absmiddle"> will be constructed.
                                                                                     
                                                                                     
<!--l. 2871--><p class="indent" >  As <img 
src="SolvingMicroDSOPs648x.svg" alt="ÀÜœÇt(at)  " class="math";align="absmiddle"> can be constructed by <img 
src="SolvingMicroDSOPs649x.svg" alt="œÇ   " class="math";align="absmiddle"><span 
class="ectt-1200">Raw[at_]</span>, <img 
src="SolvingMicroDSOPs650x.svg" alt="  a
¬Øùî≥ t(at)  " class="math";align="absmiddle"> is constructed by another newly
deÔ¨Åned function <img 
src="SolvingMicroDSOPs651x.svg" alt="ùî≥   " class="math";align="absmiddle"><span 
class="ectt-1200">aOpt[at_]</span>, where the naming convention is obviously that ‚ÄòOpt‚Äô stands
for ‚ÄòOptimized.‚Äô With <img 
src="SolvingMicroDSOPs652x.svg" alt="¬Øùî≥a(at)
 t  " class="math";align="absmiddle"> in hand (as well as the appropriately redeÔ¨Åned <img 
src="SolvingMicroDSOPs653x.svg" alt="¬Øùî≥t(at)  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs654x.svg" alt="¬Øùî≥aa(a )
 t   t  " class="math";align="absmiddle">) the analysis is essentially identical to that for the standard multiperiod problem
with a single control variable.
<!--l. 2881--><p class="indent" >  The structure of the program in detail is as follows. First, perform  the usual
initializations. Then initialize <img 
src="SolvingMicroDSOPs655x.svg" alt="œÇ   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec </span>and the other variables speciÔ¨Åc to the multiple control
problem.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs27.html#fn26x0"><sup class="textsuperscript">26</sup></a></span><a 
 id="x1-30001f26"></a>  
In particular, there are now three kinds of functions: those with both <img 
src="SolvingMicroDSOPs656x.svg" alt="at  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs657x.svg" alt="œÇt  " class="math";align="absmiddle"> as
arguments, those with just <img 
src="SolvingMicroDSOPs658x.svg" alt="at  " class="math";align="absmiddle">, and those with <img 
src="SolvingMicroDSOPs659x.svg" alt="mt  " class="math";align="absmiddle">.
<!--l. 2900--><p class="indent" >  Once the setup is complete, the heart of the program is the following.
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-30003x1">Construct <img 
src="SolvingMicroDSOPs660x.svg" alt="ùî≥œÇ(a ,œÇ )
 t  t t  " class="math";align="absmiddle"> using the usual calculation over the tensor deÔ¨Åned by the
      combinations of the elements of <span 
class="ectt-1200">aVec </span>and <img 
src="SolvingMicroDSOPs661x.svg" alt="œÇ   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span>.
      </li>
      <li 
  class="enumerate" id="x1-30005x2">For any level of saving <span 
class="ectt-1200">at</span>, the function <img 
src="SolvingMicroDSOPs662x.svg" alt="œÇ   " class="math";align="absmiddle"><span 
class="ectt-1200">Raw[at_] </span>performs a rootÔ¨Ånding
      operation<span class="footnote-mark"><a 
href="SolvingMicroDSOPs28.html#fn27x0"><sup class="textsuperscript">27</sup></a></span><a 
 id="x1-30006f27"></a>  
      <table 
class="equation"><tr><td><a 
 id="x1-30007r60"></a>
      <center class="math-display" >
      <img 
src="SolvingMicroDSOPs666x.svg" alt="   0 = ùî≥œÇ(a,œÇ )
        t  t t
    s.t.
0 ‚â§ œÇt            ‚â§ 1
      " class="math-display" ></center></td></tr></table>
                                                                                     
                                                                                     
      <!--l. 2920--><p class="nopar" >
      and generates the corresponding optimal portfolio share <img 
src="SolvingMicroDSOPs667x.svg" alt="œÇ‚àót  " class="math";align="absmiddle">.
      </li>
      <li 
  class="enumerate" id="x1-30009x3">Construct the function <img 
src="SolvingMicroDSOPs668x.svg" alt="Àúùî≥   " class="math";align="absmiddle"><span 
class="ectt-1200">a[at_]</span>
      <table 
class="equation"><tr><td><a 
 id="x1-30010r60"></a>
      <center class="math-display" >
      <img 
src="SolvingMicroDSOPs669x.svg" alt=" a        a    ‚àó
Àúùî≥t(at) ‚â° ùî≥ t(at,œÇt (at))
      " class="math-display" ></center></td><td class="equation-label">(60)</td></tr></table>
      <!--l. 2928--><p class="nopar" >
      where <img 
src="SolvingMicroDSOPs670x.svg" alt=" ‚àó
œÇt (at)  " class="math";align="absmiddle"> is computed by <img 
src="SolvingMicroDSOPs671x.svg" alt="œÇ   " class="math";align="absmiddle"><span 
class="ectt-1200">Raw[at_]</span>.
      </li>
      <li 
  class="enumerate" id="x1-30012x4">Using <img 
src="SolvingMicroDSOPs672x.svg" alt="Àúùî≥at(at) ‚â° " class="math";align="absmiddle"><img 
src="SolvingMicroDSOPs673x.svg" alt="Àúùî≥   " class="math";align="absmiddle"><span 
class="ectt-1200">a[at_] </span>and the redeÔ¨Åned <img 
src="SolvingMicroDSOPs674x.svg" alt="Àúùî≥t(at)  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs675x.svg" alt="Àúùî≥ata(at)  " class="math";align="absmiddle"> (in place of
      <img 
src="SolvingMicroDSOPs676x.svg" alt="ùî≥at(at) ‚â° " class="math";align="absmiddle"> <img 
src="SolvingMicroDSOPs677x.svg" alt="ùî≥   " class="math";align="absmiddle"><span 
class="ectt-1200">a[at_] </span>in <span 
class="ectt-1200">multiperiod.m</span>), follow the same procedures as in
      <span 
class="ectt-1200">multiperiod.m </span>to generate <img 
src="SolvingMicroDSOPs678x.svg" alt="`c(m )
 t  " class="math";align="absmiddle">.
      </li></ol>
<!--l. 2940--><p class="indent" >  ¬†
  <h4 class="subsectionHead"><span class="titlemark">7.4  </span> <a 
 id="x1-310007.4"></a>Results</h4>
<!--l. 2943--><p class="noindent" >Figure¬†<a 
href="#x1-3100120">20<!--tex4ht:ref: fig:PlotctMultContr --></a> plots the Ô¨Årst-period consumption function generated by the program; qualitatively
it does not look much diÔ¨Äerent from the consumption functions generated by the program
without portfolio choice. Figure¬†<a 
href="#x1-3100221">21<!--tex4ht:ref: fig:PlotRiskySharetOfat --></a> plots the optimal portfolio share as a function of the level
of assets. This Ô¨Ågure exhibits several interesting features. First, even with a coeÔ¨Écient of
relative risk aversion of 6, an equity premium of only 4 percent, and an annual standard
deviation in equity returns of 15 percent, the optimal choice is for the agent to invest
a proportion 1 (100 percent) of the portfolio in stocks (instead of the safe bank
account with riskless return <img 
src="SolvingMicroDSOPs679x.svg" alt="R  " class="math";align="absmiddle">) is at values of <img 
src="SolvingMicroDSOPs680x.svg" alt="at  " class="math";align="absmiddle"> less than about 2. Second, the
proportion of the portfolio kept in stocks is <span 
class="ecti-1200">declining </span>in the level of wealth - i.e., the poor
should hold all of their meager assets in stocks, while the rich should be cautious,
holding more of their wealth in safe bank deposits and less in stocks. This seemingly
bizarre (and highly counterfactual) prediction reÔ¨Çects the nature of the risks the
                                                                                     
                                                                                     
consumer faces. Those consumers who are poor in measured Ô¨Ånancial wealth are
likely to derive a high proportion of future consumption from their labor income.
Since by assumption labor income risk is uncorrelated with rate-of-return risk, the
covariance between their future consumption and future stock returns is relatively
low. By contrast, persons with relatively large wealth will be paying for a large
proportion of future consumption out of that wealth, and hence if they invest too much
of it in stocks their consumption will have a high covariance with stock returns.
Consequently, they reduce that correlation by holding some of their wealth in the riskless
form.
<!--l. 2971--><p class="indent" >  <a 
 id="PlotctMultContr"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3100120"></a>
                                                                                     
                                                                                     
<!--l. 2973--><p class="noindent" > <img 
src="./Figures/PlotctMultContr.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†20:</span><span  
class="content"><img 
src="SolvingMicroDSOPs681x.svg" alt="c(m1 )  " class="math";align="absmiddle"> With Portfolio Choice</span></figcaption><!--tex4ht:label?: x1-3100120 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2978--><p class="indent" >  <a 
 id="PlotRiskySharetOfat"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3100221"></a>
                                                                                     
                                                                                     
<!--l. 2980--><p class="noindent" > <img 
src="./Figures/PlotRiskySharetOfat.png" alt="pict"  
 width="578.15999pt" >
<figcaption class="caption" ><span class="id">Figure¬†21:</span><span  
class="content">Portfolio Share in Risky Assets in First Period <img 
src="SolvingMicroDSOPs682x.svg" alt="œÇ(a)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-3100221 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2985--><p class="indent" >  <a 
 id="The-Infinite-Horizon"></a>
  <h3 class="sectionHead"><span class="titlemark">8  </span> <a 
 id="x1-320008"></a>The-InÔ¨Ånite-Horizon</h3>
<!--l. 2988--><p class="noindent" >All of the solution methods presented so far have involved period-by-period iteration from an
assumed last period of life, as is appropriate for life cycle problems. However, if the parameter
values for the problem satisfy certain conditions (detailed in <a 
href="#XBufferStockTheory">Carroll</a>¬†(<a 
href="#XBufferStockTheory">Forthcoming</a>)), the
consumption rules (and the rest of the problem) will converge to a Ô¨Åxed rule as the
horizon (remaining lifetime) gets large, as illustrated in Figure¬†<a 
href="#x1-2600119">19<!--tex4ht:ref: fig:PlotCFuncsConverge --></a>. Furthermore,
Deaton¬†(<a 
href="#XdeatonLiqConstr">1991</a>), Carroll¬†(<a 
href="#Xcarroll:brookings">1992</a>;¬†<a 
href="#XcarrollBSLCPIH">1997</a>) and others have argued that the ‚ÄòbuÔ¨Äer-stock‚Äô saving
behavior that emerges under some further restrictions on parameter values is a good
approximation of the behavior of typical consumers over much of the lifetime. Methods for
Ô¨Ånding the converged functions are therefore of interest, and are dealt with in this
section.
<!--l. 3004--><p class="indent" >  Of course, the simplest such method is to solve the problem as speciÔ¨Åed above for a large
number of periods. This is feasible, but there are much faster methods.
<!--l. 3008--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">8.1  </span> <a 
 id="x1-330008.1"></a>Convergence</h4>
<!--l. 3010--><p class="noindent" >In solving an inÔ¨Ånite-horizon problem, it is necessary to have some metric that determines
when to stop because a solution that is ‚Äògood enough‚Äô has been found.
<!--l. 3014--><p class="indent" >  A natural metric is deÔ¨Åned by the unique ‚Äòtarget‚Äô level of wealth that <a 
href="#XBufferStockTheory">Carroll</a>¬†(<a 
href="#XBufferStockTheory">Forthcoming</a>)
proves will exist in problems of this kind: The <img 
src="SolvingMicroDSOPs683x.svg" alt="Àám  " class="math";align="absmiddle"> such that
  <table 
class="equation"><tr><td><a 
 id="x1-33001r61"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs684x.svg" alt="ùîºt [mt+1 ‚àïmt ] = 1 if mt = Àám
" class="math-display" ></center></td><td class="equation-label">(61)</td></tr></table>
<!--l. 3018--><p class="nopar" >
where the <img 
src="SolvingMicroDSOPs685x.svg" alt="‚à® " class="math";align="absmiddle"> accent is meant to signify that this is the value that other <img 
src="SolvingMicroDSOPs686x.svg" alt="m  " class="math";align="absmiddle">‚Äôs ‚Äòpoint
to.‚Äô
                                                                                     
                                                                                     
<!--l. 3022--><p class="indent" >  Given a consumption rule <img 
src="SolvingMicroDSOPs687x.svg" alt="c(m )  " class="math";align="absmiddle"> it is straightforward to Ô¨Ånd the corresponding <img 
src="SolvingMicroDSOPs688x.svg" alt="Àám  " class="math";align="absmiddle">. So for
our problem, a solution is declared to have converged if the following criterion is met:
<img 
src="SolvingMicroDSOPs689x.svg" alt="|mÀát+1 ‚àí  Àámt| &#x003C; ùúñ  " class="math";align="absmiddle">, where <img 
src="SolvingMicroDSOPs690x.svg" alt="ùúñ  " class="math";align="absmiddle"> is a very small number and measures our degree of convergence
tolerance.
<!--l. 3028--><p class="indent" >  Similar criteria can obviously be speciÔ¨Åed for other problems. However, it is always wise to
plot successive function diÔ¨Äerences and to experiment a bit with convergence criteria to verify
that the function has converged for all practical purposes.
<!--l. 3085--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">8.2  </span> <a 
 id="x1-340008.2"></a>Coarse then Fine <img 
src="SolvingMicroDSOPs691x.svg" alt="ùúÉ   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span></h4>
<!--l. 3087--><p class="noindent" >The  speed  of  solution  is  roughly
proportionate<span class="footnote-mark"><a 
href="SolvingMicroDSOPs29.html#fn28x0"><sup class="textsuperscript">28</sup></a></span><a 
 id="x1-34001f28"></a>  
to the number of points used in approximating the distribution of shocks. At least 3 gridpoints
should probably be used as an initial minimum, and my experience is that increasing the
number of gridpoints beyond 7 generally yields only very small changes in the solution. The
program <span 
class="ectt-1200">multiperiodCon_infhor.m </span>begins with three gridpoints, and then solves for
successively Ô¨Åner <img 
src="SolvingMicroDSOPs692x.svg" alt="ùúÉ   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span>.
<!--l. 3101--><p class="indent" >  <a 
 id="StructuralEstimation"></a>
  <h3 class="sectionHead"><span class="titlemark">9  </span> <a 
 id="x1-350009"></a>Structural Estimation</h3>
<!--l. 3104--><p class="noindent" >This section describes how to use the methods developed above to structurally
estimate a life-cycle consumption model, following closely the work of
<a 
href="#XcagettiWprofiles">Cagetti</a>¬†(<a 
href="#XcagettiWprofiles">2003</a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs30.html#fn29x0"><sup class="textsuperscript">29</sup></a></span><a 
 id="x1-35001f29"></a>  
The key idea of structural estimation is to look for the parameter values (for the time
preference rate, relative risk aversion, or other parameters) which lead to the best possible
match between simulated and empirical moments. (The code for the structural estimation is in
the self-contained subfolder <span 
class="ectt-1200">StructuralEstimation </span>in the Matlab and <span 
class="ecti-1200">Mathematica</span>
directories.)
<!--l. 3116--><p class="indent" >  <a 
 id="LifeCycleModel"></a>
                                                                                     
                                                                                     
  <h4 class="subsectionHead"><span class="titlemark">9.1  </span> <a 
 id="x1-360009.1"></a>Life Cycle Model</h4>
<!--l. 3119--><p class="noindent" >The decision problem for the household at age <img 
src="SolvingMicroDSOPs693x.svg" alt="t  " class="math";align="absmiddle"> is:
  <table 
class="equation"><tr><td><a 
 id="x1-36001r62"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs694x.svg" alt="     {           [  T                         ]}
                   ‚àë     s‚àí t(  s    ÀÜ  )
max    u(ct) + ùîºt       ‚Ñ∂     Œ† i=t+1Œ≤i‚Ñµi  u(cs)
                  s=t+1
" class="math-display" ></center></td><td class="equation-label">(62)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 3126--><p class="indent" >  subject to the constraints
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs695x.svg" alt="   as = ms ‚àí  cs
m     = Ra  + Y
  s+1      s    s+1
 Ys+1 = ppps+1ùúÉs+1
 ppp    = Œì   ppp Œ®
  s+1    s+1 s  s+1
" class="math-display" ></center></td></tr></table>
<!--l. 3132--><p class="nopar" >
where
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs696x.svg" alt="‚Ñµ  :  probability alive (not dead ) until age s given alive at age s ‚àí 1
  s
Œ≤ÀÜs :           time-varying discount factor between age s ‚àí 1 and s

Œ®s :                          mean -one shock to permanent  income
 ‚Ñ∂ :                                  time-invariant discount  factor
" class="math-display" ></center></td></tr></table>
<!--l. 6--><p class="nopar" >
<!--l. 3143--><p class="indent" >  and all the other variables are deÔ¨Åned as in section <a 
href="#x1-20002">2<!--tex4ht:ref: sec:basicproblem --></a>.
<!--l. 3145--><p class="indent" >  Households start life at age <img 
src="SolvingMicroDSOPs697x.svg" alt="s = 25  " class="math";align="absmiddle"> and live with probability 1 until retirement (<img 
src="SolvingMicroDSOPs698x.svg" alt="s = 65  " class="math";align="absmiddle">).
Thereafter the survival probability shrinks every year and agents are dead by <img 
src="SolvingMicroDSOPs699x.svg" alt="s = 91  " class="math";align="absmiddle"> as
assumed by Cagetti. Note that in addition to a typical time-invariant discount factor <img 
src="SolvingMicroDSOPs700x.svg" alt="‚Ñ∂  " class="math";align="absmiddle">,
there is a time-varying discount factor <img 
src="SolvingMicroDSOPs701x.svg" alt="Œ≤ÀÜ
  s  " class="math";align="absmiddle"> in (<a 
href="#x1-36001r62">62<!--tex4ht:ref: eq:lifecyclemax --></a>) which captures the eÔ¨Äect of time-varying
demographic variables (e.g.¬†changes in family size).
<!--l. 3152--><p class="indent" >  Transitory and permanent shocks are distributed as follows:
  <table 
class="equation"><tr><td><a 
 id="x1-36002r63"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs702x.svg" alt="        {
   Œûs =   0      with probability ‚Ñò &#x003E; 0
          ùúÉs‚àï‚Ñò   with probability (1 ‚àí ‚Ñò ), where log ùúÉs ‚àΩ ùí© (‚àí œÉ2ùúÉ‚àï2,œÉ2ùúÉ)
                                                                              2     2
log œàs ‚àΩ                                                                 ùí© (‚àí œÉœà ‚àï2,œÉœà)
" class="math-display" ></center></td><td class="equation-label">(63)</td></tr></table>
<!--l. 3160--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs703x.svg" alt="‚Ñò  " class="math";align="absmiddle"> is the probability of unemployment (and unemployment shocks are turned oÔ¨Ä after
retirement).
<!--l. 3163--><p class="indent" >  The parameter values for the shocks are taken from Carroll¬†(<a 
href="#Xcarroll:brookings">1992</a>), <img 
src="SolvingMicroDSOPs704x.svg" alt="‚Ñò = 0.5‚àï100  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs705x.svg" alt="œÉ ùúÉ = 0.1  " class="math";align="absmiddle">, and
<img 
src="SolvingMicroDSOPs706x.svg" alt="œÉ œà = 0.1  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs31.html#fn30x0"><sup class="textsuperscript">30</sup></a></span><a 
 id="x1-36003f30"></a>   The income
growth proÔ¨Åle <img 
src="SolvingMicroDSOPs710x.svg" alt="Œì
  s  " class="math";align="absmiddle"> is from Carroll¬†(<a 
href="#XcarrollBSLCPIH">1997</a>) and the values of <img 
src="SolvingMicroDSOPs711x.svg" alt="‚Ñµ
 s  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs712x.svg" alt="ÀÜŒ≤
 s  " class="math";align="absmiddle"> are obtained from Cagetti¬†(<a 
href="#XcagettiWprofiles">2003</a>)
                                                                                     
                                                                                     
(Figure <a 
href="#x1-3600522">22<!--tex4ht:ref: fig:TimeVaryingParam --></a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs32.html#fn31x0"><sup class="textsuperscript">31</sup></a></span><a 
 id="x1-36004f31"></a>  
The interest rate is assumed to equal <img 
src="SolvingMicroDSOPs713x.svg" alt="1.03  " class="math";align="absmiddle">. The model parameters are included in Table
<a 
href="#x1-360061">1<!--tex4ht:ref: table:StrEstParams --></a>.
<!--l. 3166--><p class="indent" >  <a 
 id="PlotTimeVaryingParam"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3600522"></a>
                                                                                     
                                                                                     
<!--l. 3168--><p class="noindent" > <img 
src="./Figures/PlotTimeVaryingParam.png" alt="pict"  
 width="602.25pt" >
<figcaption class="caption" ><span class="id">Figure¬†22:</span><span  
class="content">Time Varying Parameters</span></figcaption><!--tex4ht:label?: x1-3600522 -->
                                                                                     
                                                                                     
  </div>
  <div class="table">
                                                                                     
                                                                                     
<!--l. 3173--><p class="indent" >  <a 
 id="x1-360061"></a><figure class="float" 
>
                                                                                     
                                                                                     
<figcaption class="caption" ><span class="id">Table¬†1:</span><span  
class="content">Parameter Values</span></figcaption><!--tex4ht:label?: x1-360061 -->
<div class="center" 
>
<!--l. 3175--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs714x.svg" alt="-----------------------------------
   œÉùúÉ      0.1     Carroll (1992)
  œÉ œà      0.1     Carroll (1992)

   ‚Ñò      0.005    Carroll (1992)
   Œì s   Ô¨Ågure 22  Carroll (1997)
 ÀÜŒ≤s,‚Ñµs   Ô¨Ågure 22  Cagetti (2003 )
   R       1.03    Cagetti (2003 )
-----------------------------------
" ></div></div>
                                                                                     
                                                                                     
  </figure>
  </div>
<!--l. 3189--><p class="indent" >  The parameters <img 
src="SolvingMicroDSOPs715x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs716x.svg" alt="œÅ  " class="math";align="absmiddle"> are structurally estimated following the procedure described
below.
  <h4 class="subsectionHead"><span class="titlemark">9.2  </span> <a 
 id="x1-370009.2"></a>Estimation</h4>
<!--l. 3193--><p class="noindent" >When economists say that they are performing ‚Äústructural estimation‚Äù of a model like this, they
mean that they have devised a formal procedure for searching for values for the parameters <img 
src="SolvingMicroDSOPs717x.svg" alt="‚Ñ∂  " class="math";align="absmiddle">
and <img 
src="SolvingMicroDSOPs718x.svg" alt="œÅ  " class="math";align="absmiddle"> at which some measure of the model‚Äôs outcome (like ‚Äúmedian wealth by age‚Äù) is as
close as possible to an empirical measure of the same thing. Here, we choose to match the
median of the wealth to permanent income ratio across 7 age groups, from age <img 
src="SolvingMicroDSOPs719x.svg" alt="26 ‚àí 30  " class="math";align="absmiddle"> up to
<img 
src="SolvingMicroDSOPs720x.svg" alt="56 ‚àí 60  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs33.html#fn32x0"><sup class="textsuperscript">32</sup></a></span><a 
 id="x1-37001f32"></a>  
The choice of matching the medians rather the means is motivated by the fact that the wealth
distribution is much more concentrated at the top than the model is capable of
explaining using a single set of parameter values. This means that in practice one
must pick some portion of the population who one wants to match well; since the
model has little hope of capturing the behavior of Bill Gates, but might conceivably
match the behavior of Homer Simpson, we choose to match medians rather than
means.
<!--l. 3215--><p class="indent" >  As explained in section <a 
href="#x1-30003">3<!--tex4ht:ref: sec:normalization --></a>, it is convenient to work with the normalized version the model
which can be written as:
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs721x.svg" alt="              {                                             }
                             ÀÜ                1‚àíœÅ
vt(mt) = maxct   u (ct) + ‚Ñ∂‚Ñµt+1Œ≤t+1 ùîºt[(œàt+1 Œì t+1)  vt+1 (mt+1 )]

      s.t.
    at = mt ‚àí  ct
           (     R    )
  mt+1 = at  ---------  + ùúÉt+1
           ‚óü-œàt+1‚óùŒì‚óú t+1-‚óû
               ‚â°‚Ñõt+1
" class="math-display" ></center></td></tr></table>
<!--l. 7--><p class="nopar" >
<!--l. 3226--><p class="indent" >  with the Ô¨Årst order condition:
  <table 
class="equation"><tr><td><a 
 id="x1-37002r64"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs722x.svg" alt=" ‚Ä≤            ÀÜ         ‚Ä≤
u (ct) = ‚Ñ∂‚Ñµt+1 Œ≤t+1R ùîºt [u (œàt+1Œì t+1ct+1(at‚Ñõt+1 + ùúÉt+1))].
" class="math-display" ></center></td><td class="equation-label">(64)</td></tr></table>
<!--l. 3230--><p class="nopar" >
<!--l. 3232--><p class="indent" >  The Ô¨Årst step is to solve for the consumption functions at each age using the routines
included in the <span 
class="ectt-1200">setup_ConsFn.m </span>Ô¨Åle. We need to discretize the shock distribution and solve
for the policy functions by backward induction using equation (<a 
href="#x1-37002r64">64<!--tex4ht:ref: eq:FOCLifeCycle --></a>) following the
procedure in sections <a 
href="#x1-50005">5<!--tex4ht:ref: sec:NextToLast --></a> and <a 
href="#x1-210006">6<!--tex4ht:ref: sec:recursion --></a> (<span 
class="ectt-1200">ConstructcFuncLife</span>). The latter routine is slightly
complicated by the fact that we are considering a life-cycle model and therefore
the growth rate of permanent income, the probability of death, the time-varying
discount factor and the distribution of shocks will be diÔ¨Äerent across the years. We
thus must ensure that at each backward iteration the right parameter values are
used.
<!--l. 3245--><p class="indent" >  Once we have the age varying consumption functions, we can proceed to generate the
simulated data and compute the simulated medians using the routines deÔ¨Åned in the
<span 
class="ectt-1200">setup_Sim.m </span>Ô¨Åle. We Ô¨Årst have to draw the shocks for each agent and period. This
involves discretizing the shock distribution for as many points as the number of
agents we want to simulate (<span 
class="ectt-1200">ConstructShockDistribution</span>). We then randomly
permute this shock vector as many times as we need to simulate the model for,
thus obtaining a time varying shock for each agent (<span 
class="ectt-1200">ConstructSimShocks</span>). This is
much more time eÔ¨Écient than drawing at each time from the shock distribution a
                                                                                     
                                                                                     
shock for each agent, and also ensures a stable distribution of shocks across the
simulation periods even for a small number of agents. (Similarly, in order to speed up the
process, at each backward iteration we compute the consumption function and other
variables as a vector at once.) Then, following Cagetti ¬†(<a 
href="#XcagettiWprofiles">2003</a>), we initialize the
wealth-to-income ratio of agents at age <img 
src="SolvingMicroDSOPs723x.svg" alt="25  " class="math";align="absmiddle"> by randomly assigning the equal probability
values to <img 
src="SolvingMicroDSOPs724x.svg" alt="0.17  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs725x.svg" alt="0.50  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs726x.svg" alt="0.83  " class="math";align="absmiddle"> and run the simulation (<span 
class="ectt-1200">Simulate</span>). In particular we
consider a population of agents at age 25 and follow their consumption and wealth
accumulation dynamics as they reach the age of <img 
src="SolvingMicroDSOPs727x.svg" alt="60  " class="math";align="absmiddle">, using the appropriate age-speciÔ¨Åc
consumption functions and the age-varying parameters. The simulated medians
are obtained by taking the medians of the wealth to income ratio of the <img 
src="SolvingMicroDSOPs728x.svg" alt="7  " class="math";align="absmiddle"> age
groups.
<!--l. 3270--><p class="indent" >  Given these simulated medians, we can estimate the model by calculating empirical medians
and measure the model‚Äôs success by calculating the diÔ¨Äerence between the empirical median
and the actual median. SpeciÔ¨Åcally, deÔ¨Åning <img 
src="SolvingMicroDSOPs729x.svg" alt="Œæ  " class="math";align="absmiddle"> as the set of parameters to be estimated (in
the current case <img 
src="SolvingMicroDSOPs730x.svg" alt="Œæ = {œÅ,‚Ñ∂ } " class="math";align="absmiddle">), we could search for the parameter values which solve
  <table 
class="equation"><tr><td><a 
 id="x1-37003r65"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs731x.svg" alt="      7
    ‚àë     œÑ   œÑ
minŒæ     |œÇ ‚àí s (Œæ)|
    œÑ=1
" class="math-display" ></center></td><td class="equation-label">(65)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 3282--><p class="indent" >  where <img 
src="SolvingMicroDSOPs732x.svg" alt="œÇœÑ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs733x.svg" alt="sœÑ  " class="math";align="absmiddle"> are respectively the empirical and simulated medians of the wealth to
permanent income ratio for age group <img 
src="SolvingMicroDSOPs734x.svg" alt="œÑ  " class="math";align="absmiddle">.
<!--l. 3284--><p class="indent" >  A drawback of proceeding in this way is that it treats the empirically estimated medians as
though they reÔ¨Çected perfect measurements of the truth. Imagine, however, that
one of the age groups happened to have (in the consumer survey) four times as
many data observations as another age group; then we would expect the median to
be more precisely estimated for the age group with more observations; yet (<a 
href="#x1-37003r65">65<!--tex4ht:ref: eq:naivePowell --></a>)
assigns equal importance to a deviation between the model and the data for all age
groups.
<!--l. 3293--><p class="indent" >  We can get around this problem (and a variety of others) by instead minimizing a slightly
more complex object:
                                                                                     
                                                                                     
  <table 
class="equation"><tr><td><a 
 id="x1-37004r66"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs735x.svg" alt="    ‚àëN
min     œâi|œÇœÑi ‚àí sœÑ(Œæ)|
 Œæ   i
" class="math-display" ></center></td><td class="equation-label">(66)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 3300--><p class="indent" >  where <img 
src="SolvingMicroDSOPs736x.svg" alt="œâi  " class="math";align="absmiddle">  is the weight of household <img 
src="SolvingMicroDSOPs737x.svg" alt="i  " class="math";align="absmiddle"> in the entire
population,<span class="footnote-mark"><a 
href="SolvingMicroDSOPs34.html#fn33x0"><sup class="textsuperscript">33</sup></a></span><a 
 id="x1-37005f33"></a>  
and <img 
src="SolvingMicroDSOPs738x.svg" alt="œÇiœÑ  " class="math";align="absmiddle"> is the empirical wealth-to-permanent-income ratio of household <img 
src="SolvingMicroDSOPs739x.svg" alt="i  " class="math";align="absmiddle"> whose head
belongs to age group <img 
src="SolvingMicroDSOPs740x.svg" alt="œÑ  " class="math";align="absmiddle">. <img 
src="SolvingMicroDSOPs741x.svg" alt="œâ
  i  " class="math";align="absmiddle"> is needed because unequal weight is assigned to each observation
in the Survey of Consumer Finances (SCF). The absolute value is used since the formula is
based on the fact that the median is the value that minimizes the sum of the absolute
deviations from itself.
<!--l. 3316--><p class="indent" >  The actual data are taken from several waves of the SCF and the medians and means for
each age category are plotted in Ô¨Ågure <a 
href="#x1-3700623">23<!--tex4ht:ref: fig:MeanMedianSCF --></a>. More details on the SCF data are included in
appendix <a 
href="#x1-39000A">A<!--tex4ht:ref: app:SCFdata --></a>. <a 
 id="PlotMeanMedianSCFcollegeGrads"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3700623"></a>
                                                                                     
                                                                                     
<!--l. 3320--><p class="noindent" > <img 
src="./Figures/PlotMeanMedianSCFcollegeGrads.png" alt="pict"  
 width="301.125pt" >
<figcaption class="caption" ><span class="id">Figure¬†23:</span><span  
class="content">Wealth to Permanent Income Ratios from SCF (means (dashed) and medians
(solid))</span></figcaption><!--tex4ht:label?: x1-3700623 -->
                                                                                     
                                                                                     
  </div>
<!--l. 3325--><p class="indent" >  The key function to perform structural estimation is deÔ¨Åned in the <span 
class="ectt-1200">setup_Estimation.m</span>
Ô¨Åle as follows:
  <table 
class="equation"><tr><td><a 
 id="x1-37007r67"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs742x.svg" alt="GapEmpiricalSimulatedMedians     [œÅ,‚Ñ∂ ]:=
[                   ConstructcFuncLife   [œÅ,‚Ñ∂ ];

Simulate;
 ‚àëN
    œâ  |œÇœÑ ‚àí sœÑ(Œæ)|
      i i
  i
];
" class="math-display" ></center></td></tr></table>
<!--l. 7--><p class="nopar" >
<!--l. 3336--><p class="indent" >  For a given pair of the parameters to be estimated, the <span 
class="ectt-1200">GapEmpiricalSimulatedMedians</span>
routine therefore:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-37009x1">solves for the consumption functions by calling <span 
class="ectt-1200">ConstructcFuncLife</span>
      </li>
      <li 
  class="enumerate" id="x1-37011x2">simulates the data and computes the simulated medians by calling <span 
class="ectt-1200">Simulate</span>
      </li>
      <li 
  class="enumerate" id="x1-37013x3">returns the value of equation (<a 
href="#x1-37004r66">66<!--tex4ht:ref: eq:StructEstim --></a>)</li></ol>
<!--l. 3343--><p class="indent" >  We delegate the task of Ô¨Ånding the coeÔ¨Écients that minimize the <span 
class="ectt-1200">GapEmpiricalSimulatedMedians</span>
function to the <span 
class="ecti-1200">Mathematica</span>¬† built-in numerical minimizer <span 
class="ectt-1200">FindMinimum</span>. This task can be
quite time demanding and rather problematic if the <span 
class="ectt-1200">GapEmpiricalSimulatedMedians</span>
function has very Ô¨Çat regions or sharp features. It is thus wise to verify the accuracy of the
solution, for example by experimenting with a variety of alternative starting values for the
parameter search.
<!--l. 3352--><p class="indent" >  Finally the standard errors are computed by bootstrap using the routines in the <span 
class="ectt-1200">setup_Bootstrap.m</span>
Ô¨Åle.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs35.html#fn34x0"><sup class="textsuperscript">34</sup></a></span><a 
 id="x1-37014f34"></a>  
                                                                                     
                                                                                     
This involves:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-37016x1">drawing new shocks for the simulation
      </li>
      <li 
  class="enumerate" id="x1-37018x2">drawing a random sample (with replacement) of actual data from the SCF
      </li>
      <li 
  class="enumerate" id="x1-37020x3">obtaining new estimates for <img 
src="SolvingMicroDSOPs743x.svg" alt="œÅ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs744x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"></li></ol>
<!--l. 3361--><p class="noindent" >We repeat the above procedure several times (<span 
class="ectt-1200">Bootstrap</span>) and take the standard deviation for
each of the estimated parameters across the various bootstrap iterations.
<!--l. 3363--><p class="indent" >  The Ô¨Åle <span 
class="ectt-1200">StructEstimation.m </span>produces our <img 
src="SolvingMicroDSOPs745x.svg" alt="œÅ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs746x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> estimates with standard errors using 10,000 simulated
agents.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs36.html#fn35x0"><sup class="textsuperscript">35</sup></a></span><a 
 id="x1-37021f35"></a>   Results are
reported in Table <a 
href="#x1-370232">2<!--tex4ht:ref: tab:EstResults --></a>.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs37.html#fn36x0"><sup class="textsuperscript">36</sup></a></span><a 
 id="x1-37022f36"></a>  
Figure <a 
href="#x1-3702424">24<!--tex4ht:ref: fig:PlotContourMedianStrEst --></a> shows the contour plot of the <span 
class="ectt-1200">GapEmpiricalSimulatedMedians </span>function and
the parameter estimates. The contour plot shows equally spaced isoquants of the
<span 
class="ectt-1200">GapEmpiricalSimulatedMedians </span>function, i.e.¬†the pairs of <img 
src="SolvingMicroDSOPs749x.svg" alt="œÅ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs750x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> which lead to the same
deviations between simulated and empirical medians (equivalent values of equation
(<a 
href="#x1-37004r66">66<!--tex4ht:ref: eq:StructEstim --></a>)). We can thus interestingly see that there is a large rather Ô¨Çat region, or more
formally speaking there exists a broad set of parameter pairs which leads to similar
simulated wealth to income ratios. Intuitively, the Ô¨Çatter and larger is this region,
the harder it is for the structural estimation procedure to precisely identify the
parameters.
<div class="table">
                                                                                     
                                                                                     
<!--l. 1--><p class="indent" >  <a 
 id="x1-370232"></a><figure class="float" 
>
                                                                                     
                                                                                     
<figcaption class="caption" ><span class="id">Table¬†2:</span><span  
class="content">Estimation Results</span></figcaption><!--tex4ht:label?: x1-370232 -->
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs751x.svg" alt="-----------------
---œÅ-------‚Ñ∂-----
  4.68    1.00
 (0.13)  (0.00)
-----------------
" ></div>
                                                                                     
                                                                                     
  </figure>
  </div>
<!--l. 3402--><p class="indent" >  <a 
 id="PlotContourMedianStrEst"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3702424"></a>
                                                                                     
                                                                                     
<!--l. 3404--><p class="noindent" > <img 
src="./Figures/PlotContourMedianStrEst.png" alt="pict"  
 width="301.125pt" >
<figcaption class="caption" ><span class="id">Figure¬†24:</span><span  
class="content">Contour Plot (larger values are shown lighter) with <img 
src="SolvingMicroDSOPs752x.svg" alt="{œÅ,‚Ñ∂ } " class="math";align="absmiddle"> Estimates (red
dot).</span></figcaption><!--tex4ht:label?: x1-3702424 -->
                                                                                     
                                                                                     
  </div>
  <h3 class="sectionHead"><span class="titlemark">10  </span> <a 
 id="x1-3800010"></a>Conclusion</h3>
<!--l. 3411--><p class="noindent" >There are many alternative choices that can be made for solving microeconomic dynamic
stochastic optimization problems. The set of techniques, and associated programs, described in
these notes represents an approach that I have found to be powerful, Ô¨Çexible, and eÔ¨Écient, but
other problems may require other techniques. For a much broader treatment of many of the
issues considered here, see Judd¬†(<a 
href="#Xjudd:book">1998</a>).
                                                                                     
                                                                                     
  <div  
class="centerline">                                             <span 
class="ecrm-2074">Appendices</span>                            </div>
  <h3 class="sectionHead"><span class="titlemark">A  </span> <a 
 id="x1-39000A"></a>Further Details on SCF Data</h3>
<!--l. 3427--><p class="noindent" >Data used in the estimation is constructed using the SCF 1992, 1995, 1998,
2001 and 2004 waves. The deÔ¨Ånition of wealth is net worth including housing
wealth, but excluding pensions and social securities. The data set contains
only households whose heads are aged 26-60 and excludes singles, following
Cagetti¬†(<a 
href="#XcagettiWprofiles">2003</a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs38.html#fn37x0"><sup class="textsuperscript">37</sup></a></span><a 
 id="x1-39001f37"></a>  
Furthermore, the data set contains only households whose heads are college graduates. The
total sample size is 4,774.
<!--l. 3429--><p class="indent" >  In the waves between 1995 and 2004 of the SCF, levels of <span 
class="ecti-1200">normal </span>income are reported. The
question in the questionnaire is &#x0022;About what would your income have been if it had been a
normal year?&#x0022; We consider the level of normal income as corresponding to the model‚Äôs
theoretical object <img 
src="SolvingMicroDSOPs753x.svg" alt="P  " class="math";align="absmiddle">, permanent noncapital income. Levels of normal income are not
reported in the 1992 wave. Instead, in this wave there is a variable which reports whether
the level of income is normal or not. Regarding the 1992 wave, only observations
which report that the level of income is normal are used, and the levels of income of
remaining observations in the 1992 wave are interpreted as the levels of permanent
income.
<!--l. 3441--><p class="indent" >  Normal income levels in the SCF are before-tax Ô¨Ågures. These before-tax permanent income
Ô¨Ågures must be rescaled so that the median of the rescaled permanent income of each age
group matches the median of each age group‚Äôs income which is assumed in the simulation.
This rescaled permanent income is interpreted as after-tax permanent income. This rescaling
is crucial since in the estimation empirical proÔ¨Åles are matched with simulated ones which are
generated using after-tax permanent income (remember the income process assumed in the
main text). Wealth / permanent income ratio is computed by dividing the level of
wealth by the level of (after-tax) permanent income, and this ratio is used for the
estimation.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs39.html#fn38x0"><sup class="textsuperscript">38</sup></a></span><a 
 id="x1-39002f38"></a>  
                                                                                     
                                                                                     
  <h3 class="likesectionHead"><a 
 id="x1-40000A"></a>References</h3>
<!--l. 6--><p class="noindent" >
  <div class="thebibliography">
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XAttanasioBanksMeghirWeber"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">A</span><span 
class="small-caps">t</span><span 
class="small-caps">t</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">o</span><span 
class="small-caps">,</span> <span 
class="small-caps">O</span><span 
class="small-caps">.</span><span 
class="small-caps">P</span><span 
class="small-caps">.</span><span 
class="small-caps">,</span> <span 
class="small-caps">J</span><span 
class="small-caps">.</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">B</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">k</span><span 
class="small-caps">s</span><span 
class="small-caps">,</span> <span 
class="small-caps">C</span><span 
class="small-caps">.</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">M</span><span 
class="small-caps">e</span><span 
class="small-caps">g</span><span 
class="small-caps">h</span><span 
class="small-caps">i</span><span 
class="small-caps">r</span><span 
class="small-caps">,</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> <span 
class="small-caps">G</span><span 
class="small-caps">.</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">W</span><span 
class="small-caps">e</span><span 
class="small-caps">b</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span> </span>(1999): ‚ÄúHumps and
  Bumps in Lifetime Consumption,‚Äù <span 
class="ecti-1200">Journal of Business and Economic Statistics</span>, 17(1),
  22‚Äì35.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XcagettiWprofiles"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">g</span><span 
class="small-caps">e</span><span 
class="small-caps">t</span><span 
class="small-caps">t</span><span 
class="small-caps">i</span><span 
class="small-caps">,</span>  <span 
class="small-caps">M</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">c</span><span 
class="small-caps">o</span>  </span>(2003):  ‚ÄúWealth  Accumulation  Over  the  Life  Cycle  and
  Precautionary Savings,‚Äù <span 
class="ecti-1200">Journal of Business and Economic Statistics</span>, 21(3), 339‚Äì353.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xcarroll:brookings"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">,</span> <span 
class="small-caps">C</span><span 
class="small-caps">h</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">D</span><span 
class="small-caps">.</span> </span>(1992): ‚ÄúThe BuÔ¨Äer-Stock Theory of Saving: Some
  Macroeconomic Evidence,‚Äù <span 
class="ecti-1200">Brookings Papers on Economic Activity</span>, 1992(2), 61‚Äì156,
  <a 
href="http://econ.jhu.edu/people/ccarroll/BufferStockBPEA.pdf" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/BufferStockBPEA.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XcarrollBSLCPIH"></a><span class="bibsp">¬†¬†¬†</span></span>__________<span 
class="eccc1200-">¬†              </span>(1997):                ‚ÄúBuÔ¨Äer                Stock                Saving
  and the Life Cycle/Permanent Income Hypothesis,‚Äù <span 
class="ecti-1200">Quarterly Journal of Economics</span>,
  CXII(1), 1‚Äì56, <a 
href="http://econ.jhu.edu/people/ccarroll/BSLCPIH.zip" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/BSLCPIH.zip</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XcarrollEGM"></a><span class="bibsp">¬†¬†¬†</span></span>__________<span 
class="eccc1200-">¬†      </span>(2006):       ‚ÄúThe       Method       of       Endogenous       Gridpoints
  for Solving Dynamic Stochastic Optimization Problems,‚Äù  <span 
class="ecti-1200">Economics Letters</span>, 91(3),
  312‚Äì320, <a 
href="http://econ.jhu.edu/people/ccarroll/EndogenousGridpoints.pdf" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/EndogenousGridpoints.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XMathFacts"></a><span class="bibsp">¬†¬†¬†</span></span>__________<span 
class="eccc1200-">¬† </span>(Current):  ‚ÄúMath  Facts  Useful  for  Graduate  Macroeconomics,‚Äù  Online
  Lecture Notes.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XBufferStockTheory"></a><span class="bibsp">¬†¬†¬†</span></span>__________<span 
class="eccc1200-">¬†  </span>(Forthcoming):   ‚ÄúTheoretical   Foundations   of   BuÔ¨Äer   Stock   Saving,‚Äù
  <span 
class="ecti-1200">Quantitative Economics</span>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xcarroll&kimball:concavity"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">,</span>               <span 
class="small-caps">C</span><span 
class="small-caps">h</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">D</span><span 
class="small-caps">.</span><span 
class="small-caps">,</span>               <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>               <span 
class="small-caps">M</span><span 
class="small-caps">i</span><span 
class="small-caps">l</span><span 
class="small-caps">e</span><span 
class="small-caps">s</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">S</span><span 
class="small-caps">.</span></span>
                                                                                     
                                                                                     
  <span 
class="eccc1200-"><span 
class="small-caps">K</span><span 
class="small-caps">i</span><span 
class="small-caps">m</span><span 
class="small-caps">b</span><span 
class="small-caps">a</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span> </span>(1996): ‚ÄúOn the Concavity of the Consumption Function,‚Äù <span 
class="ecti-1200">Econometrica</span>,
  64(4), 981‚Äì992, <a 
href="http://econ.jhu.edu/people/ccarroll/concavity.pdf" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/concavity.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xcarroll&samwick:nature"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">,</span> <span 
class="small-caps">C</span><span 
class="small-caps">h</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">D</span><span 
class="small-caps">.</span><span 
class="small-caps">,</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> <span 
class="small-caps">A</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">w</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">A</span><span 
class="small-caps">.</span> <span 
class="small-caps">S</span><span 
class="small-caps">a</span><span 
class="small-caps">m</span><span 
class="small-caps">w</span><span 
class="small-caps">i</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span> </span>(1997): ‚ÄúThe Nature
  of Precautionary Wealth,‚Äù <span 
class="ecti-1200">Journal of Monetary Economics</span>, 40(1), 41‚Äì71.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XdeatonLiqConstr"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">D</span><span 
class="small-caps">e</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span> <span 
class="small-caps">A</span><span 
class="small-caps">n</span><span 
class="small-caps">g</span><span 
class="small-caps">u</span><span 
class="small-caps">s</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">S</span><span 
class="small-caps">.</span> </span>(1991): ‚ÄúSaving and Liquidity Constraints,‚Äù <span 
class="ecti-1200">Econometrica</span>, 59,
  1221‚Äì1248, <a 
href="http://www.jstor.org/stable/2938366" class="url" ><span 
class="ectt-1200">http://www.jstor.org/stable/2938366</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XdenHaanMarcet:parameterized"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">d</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span>                      <span 
class="small-caps">H</span><span 
class="small-caps">a</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span>                      <span 
class="small-caps">W</span><span 
class="small-caps">o</span><span 
class="small-caps">u</span><span 
class="small-caps">t</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">J</span><span 
class="small-caps">,</span>                      <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span></span>
  <span 
class="eccc1200-"><span 
class="small-caps">A</span><span 
class="small-caps">l</span><span 
class="small-caps">b</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span> <span 
class="small-caps">M</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">c</span><span 
class="small-caps">e</span><span 
class="small-caps">t</span> </span>(1990): ‚ÄúSolving the Stochastic Growth Model by Parameterizing
  Expectations,‚Äù <span 
class="ecti-1200">Journal of Business and Economic Statistics</span>, 8(1), 31‚Äì34, Available at
  <a 
href="http://ideas.repec.org/a/bes/jnlbes/v8y1990i1p31-34.html" class="url" ><span 
class="ectt-1200">http://ideas.repec.org/a/bes/jnlbes/v8y1990i1p31-34.html</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XgpLifecycle"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">G</span><span 
class="small-caps">o</span><span 
class="small-caps">u</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">n</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">s</span><span 
class="small-caps">,</span> <span 
class="small-caps">P</span><span 
class="small-caps">i</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">-</span><span 
class="small-caps">O</span><span 
class="small-caps">l</span><span 
class="small-caps">i</span><span 
class="small-caps">v</span><span 
class="small-caps">i</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">,</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> <span 
class="small-caps">J</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span> <span 
class="small-caps">P</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">k</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span> </span>(2002): ‚ÄúConsumption
  Over the Life Cycle,‚Äù <span 
class="ecti-1200">Econometrica</span>, 70(1), 47‚Äì89.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XhorowitzBootstrap"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">H</span><span 
class="small-caps">o</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">w</span><span 
class="small-caps">i</span><span 
class="small-caps">t</span><span 
class="small-caps">z</span><span 
class="small-caps">,</span> <span 
class="small-caps">J</span><span 
class="small-caps">o</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">L</span><span 
class="small-caps">.</span> </span>(2001): ‚ÄúThe Bootstrap,‚Äù in <span 
class="ecti-1200">Handbook of Econometrics</span>, ed. by
  James¬†J. Heckman, and Edward Leamer, vol.¬†5. Elsevier/North Holland.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xjudd:book"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">J</span><span 
class="small-caps">u</span><span 
class="small-caps">d</span><span 
class="small-caps">d</span><span 
class="small-caps">,</span> <span 
class="small-caps">K</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span><span 
class="small-caps">n</span><span 
class="small-caps">e</span><span 
class="small-caps">t</span><span 
class="small-caps">h</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">L</span><span 
class="small-caps">.</span> </span>(1998): <span 
class="ecti-1200">Numerical Methods in Economics</span>. The MIT Press,
  Cambridge, Massachusetts.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xkopecky2010finite"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">K</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">e</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span><span 
class="small-caps">y</span><span 
class="small-caps">,</span>   <span 
class="small-caps">K</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">A</span><span 
class="small-caps">.</span><span 
class="small-caps">,</span>   <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>   <span 
class="small-caps">R</span><span 
class="small-caps">i</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">d</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">M</span><span 
class="small-caps">.</span><span 
class="small-caps">H</span><span 
class="small-caps">.</span>   <span 
class="small-caps">S</span><span 
class="small-caps">u</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span>  </span>(2010):   ‚ÄúFinite   State
  Markov-Chain Approximations To Highly Persistent Processes,‚Äù <span 
class="ecti-1200">Review of Economic</span>
  <span 
class="ecti-1200">Dynamics</span>, 13(3), 701‚Äì714, <a 
href="http://www.karenkopecky.net/RouwenhorstPaper.pdf" class="url" ><span 
class="ectt-1200">http://www.karenkopecky.net/RouwenhorstPaper.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xmerton:restat"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">M</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span> <span 
class="small-caps">R</span><span 
class="small-caps">o</span><span 
class="small-caps">b</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">C</span><span 
class="small-caps">.</span> </span>(1969): ‚ÄúLifetime Portfolio Selection under Uncertainty: The
  Continuous Time Case,‚Äù <span 
class="ecti-1200">Review of Economics and Statistics</span>, 51, 247‚Äì257.
                                                                                     
                                                                                     
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xpalumbo:medical"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">P</span><span 
class="small-caps">a</span><span 
class="small-caps">l</span><span 
class="small-caps">u</span><span 
class="small-caps">m</span><span 
class="small-caps">b</span><span 
class="small-caps">o</span><span 
class="small-caps">,</span> <span 
class="small-caps">M</span><span 
class="small-caps">i</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">G</span> </span>(1999): ‚ÄúUncertain Medical Expenses and Precautionary
  Saving Near the End of the Life Cycle,‚Äù <span 
class="ecti-1200">Review of Economic Studies</span>, 66(2), 395‚Äì421,
  Available at <a 
href="http://ideas.repec.org/a/bla/restud/v66y1999i2p395-421.html" class="url" ><span 
class="ectt-1200">http://ideas.repec.org/a/bla/restud/v66y1999i2p395-421.html</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xsamuelson:portfolio"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">S</span><span 
class="small-caps">a</span><span 
class="small-caps">m</span><span 
class="small-caps">u</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span><span 
class="small-caps">s</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span> <span 
class="small-caps">P</span><span 
class="small-caps">a</span><span 
class="small-caps">u</span><span 
class="small-caps">l</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">A</span><span 
class="small-caps">.</span> </span>(1969): ‚ÄúLifetime Portfolio Selection by Dynamic Stochastic
  Programming,‚Äù <span 
class="ecti-1200">Review of Economics and Statistics</span>, 51, 239‚Äì46.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xvalencia:2006"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">V</span><span 
class="small-caps">a</span><span 
class="small-caps">l</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span><span 
class="small-caps">c</span><span 
class="small-caps">i</span><span 
class="small-caps">a</span><span 
class="small-caps">,</span> <span 
class="small-caps">F</span><span 
class="small-caps">a</span><span 
class="small-caps">b</span><span 
class="small-caps">i</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span> </span>(2006): ‚ÄúBanks‚Äô Financial Structure and Business Cycles,‚Äù Ph.D.
  thesis, Johns Hopkins University.
</p>
  </div>
   
</body> 
</html>
                                                                                     


