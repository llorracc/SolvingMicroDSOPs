\input{@resources/tex-add-search-paths}\documentclass[SolvingMicroDSOPs]{subfiles}
\input{subfile-start}

\begin{document}
\hypertarget{normalization}{}
\section{Normalization}\label{sec:normalization}

The single most powerful method for speeding the solution of such models is to redefine the problem in a way that reduces the number of state variables (if at all possible).  In the consumption context, the obvious idea is to see whether the problem can be rewritten in terms of the ratio of various variables to permanent noncapital (`labor') income $\pLvl_{\prdt}$ (henceforth for brevity, `permanent income.')

In the last {\interval} of life $\prdT$, there is no future value, $\vFuncLvl_{\prdT+1} = 0$ (boldface $\vFuncLvl$ denotes the value function in \textit{levels}; the nonbold normalized counterpart $\vFunc$ is defined below), so the optimal plan is to consume everything:
\begin{equation}\begin{gathered}\begin{aligned}
      \vFuncLvl_{\prdT}(\mLvl_{\prdT},\pLvl_{\prdT})  & = \frac{\mLvl_{\prdT}^{1-\CRRA}}{1-\CRRA}. \label{eq:levelTm1}
\UnifiedNote{ùí±_T(mLvl, pLvl) in the un-normalized (level) MDP; normalization below maps this to ùí±_T(m) that the unified framework uses directly}
    \end{aligned}\end{gathered}\end{equation}
Now define nonbold variables as the bold variable divided by the level of permanent income in the same period, so that, for example, $\mNrm_{\prdT}=\mLvl_{\prdT}/\pLvl_{\prdT}$; and define $\vFunc_{\prdT}(\mNrm_{\prdT}) = \uFunc(\mNrm_{\prdT})$.\footnote{Nonbold value is bold value divided by $\pLvl^{1-\CRRA}$ rather than $\pLvl$.}  For our CRRA utility function, $\uFunc(xy)=x^{1-\CRRA}\uFunc(y)$, so (\ref{eq:levelTm1}) can be rewritten as
\begin{equation}\begin{gathered}\begin{aligned}
      \vFuncLvl_{\prdT}(\mLvl_{\prdT},\pLvl_{\prdT}) & = \pLvl_{\prdT}^{1-\CRRA}\frac{\mNrm_{\prdT}^{1-\CRRA}}{1-\CRRA}                       \\
%                                                & = (\pLvl_{\prdT-1}\PermGroFac_{\prdT})^{1-\CRRA}\frac{{\mNrm}_{\prdT}^{1-\CRRA}}{1-\CRRA} \\
                                                &= \pLvl_{\prdT-1}^{1-\CRRA}\PermGroFac_{\prdT}^{1-\CRRA}\vFunc_{\prdT}(\mNrm_{\prdT}). \label{eq:vT}
\UnifiedNote{change of variables from level MDP to normalized MDP ‚Äî ùí±^lvl_T(mLvl, p) = p^{1‚àíœÅ} ùí±_T(m) where m = mLvl/p; this is the factorization that eliminates p as a state variable}
    \end{aligned}\end{gathered}\end{equation}

% The intermediate variable \bNrm (`bank balances') has been eliminated
% to align with the bellman-ddsl unified framework
% (bellman-ddsl/docs/development/references/unified) in which no
% intermediate `b' variable appears.  The former two-step transition
%   \bNrm = (\Rfree/\PermGroFac)\kNrm, \mNrm = \bNrm + \tranShkEmp
% is collapsed into \mNrm = \RNrmByG\,\kNrm + \tranShkEmp.

Because we are dividing $\prdt+1$ level variables by $\pLvl_{\prdt+1}=\PermGroFac_{\prdt+1}\pLvl_{\prdt}$, a normalized return factor emerges:
\hypertarget{eq-RNrmByG}{}
\begin{equation}\begin{gathered}\begin{aligned}
      \RNrmByG_{\prdt+1} & \equiv \Rfree/\PermGroFac_{\prdt+1} \label{eq:RNrmByG}.
\UnifiedNote{normalized return factor R/Œì appearing in the arrival transition g‚Çê·µ•: (k, Œ∏) ‚Ü¶ m = (R/Œì)k + Œ∏ (connector g‚Çë‚Çê‚Çä: a ‚Üí k is a pure rename)}
    \end{aligned}\end{gathered}\end{equation}
(We treat $\Rfree$ as time-invariant and drop the {\interval} subscript that appeared in \eqref{eq:mLvl}.)

Now define a new optimization problem:
\hypertarget{eq-vNormed}{}
\begin{verbatimwrite}{./Equations/vNormed.tex}
  \begin{equation}\begin{gathered}\begin{aligned}
        \vFunc_{\prdt}(\mNrm_{\prdt}) & = \max_{{\cNrm}} ~~ \uFunc(\cNrm)+\DiscFac \Ex_{\prdt}[ \PermGroFac_{\prdt+1}^{1-\CRRA}\vFunc_{\prdt+1}(\mNrm_{\prdt+1})] \label{eq:vNormed}                   \\
                                         & \text{s.t.}                                                                                 \\
        \aNrm_{\prdt}                       & = \mNrm_{\prdt}-\cNrm_{\prdt}                                                                     \\
        \kNrm_{\prdt+1}                     & = \aNrm_{\prdt}                                                                                \\
        \mNrm_{\prdt+1}                        & = \RNrmByG_{\prdt+1}\kNrm_{\prdt+1}+\tranShkEmp_{\prdt+1}.
\UnifiedNote{normalized MDP (period-level composed Bellman); stages: [cons-with-shocks(Œ≤=1), disc(Œ≤)]; ùí±(m) = max_c u(c) + ‚Ñ∞_disc(a) where ‚Ñ∞_disc(a) = Œ≤¬∑ùíú‚Çä(a‚Üík) = Œ≤¬∑ùîº[Œì^{1‚àíœÅ} ùí±((R/Œì)a + Œ∏)]; g‚Çê·µ•: (k, Œ∏) ‚Ü¶ m = (R/Œì)k + Œ∏; g·µ•‚Çë: (m, c) ‚Ü¶ a = m ‚àí c; g‚Çë‚Çê‚Çä: a ‚Üí k (pure rename); tex vCntn ‚â° ‚Ñ∞_disc}
      \end{aligned}\end{gathered}\end{equation}
\end{verbatimwrite}
\input{./Equations/vNormed.tex}\unskip


\ifpseudo{ % pseudocode goes here
\lstinputlisting{./\snippetsPath/equiprobable-make.py}\nopagebreak
  }{}
  
Then it is easy to see that for $\prdt=\prdT-1$, we can write boldface (nonnormalized) $\vFuncLvl$ as a function of $\vFunc$ (normalized value) and permanent income:
\begin{equation}\begin{gathered}\begin{aligned}
      \vFuncLvl_{\prdt}(\mLvl_{\prdt},\pLvl_{\prdt}) & =  \pLvl_{\prdt}^{1-\CRRA}\vFunc_{\prdt}(\mNrm_{\prdt}), \label{eq:vLvlFromvFunc}
\UnifiedNote{recovery map ‚Äî given the normalized MDP solution ùí±(m), recover the level MDP value via ùí±^lvl(mLvl, p) = p^{1‚àíœÅ} ùí±(mLvl/p); the unified framework works with the normalized ùí±(m) directly}
    \end{aligned}\end{gathered}\end{equation}
and so on back to all earlier periods (by backward induction: if the factorization holds at $\prdt+1$, substituting into the Bellman equation at $\prdt$ and using the homogeneity of CRRA utility yields the same factorization at $\prdt$).  Hence, if we solve the problem \eqref{eq:vNormed} which has only a single state variable $\mNrm_{\prdt}$, we can obtain the levels of the value function from \eqref{eq:vLvlFromvFunc}, and of consumption and all other variables from the corresponding permanent-income-normalized solution objects by multiplying each by $\pLvl_{\prdt}$, e.g.\
\begin{equation*}\begin{gathered}\begin{aligned}
  \cFunc_{\prdt}(\mLvl_{\prdt},\pLvl_{\prdt})=\pLvl_{\prdt}\cFunc_{\prdt}(\overbrace{\mLvl_{\prdt}/\pLvl_{\prdt}}^{\mNrm_{\prdt}}).
    \end{aligned}\end{gathered}\end{equation*}
%(or, for the value function, $\vFuncLvl _{\prdt}(\mLvl_{\prdt},\pLvl_{\prdt}) = \pLvl_{\prdt}^{1-\CRRA}\vFunc_{\prdt}(\mNrm_{\prdt}))$.

We have thus reduced the problem from two continuous state variables to one (and thereby enormously simplified its solution).

For future reference it will be useful to write \eqref{eq:vNormed} in the traditional way, by substituting $\aNrm_{\prdt}$ and $\kNrm_{\prdt+1}$ into $\mNrm_{\prdt+1}$:
\hypertarget{eq-vusual}{}
\begin{equation}\begin{gathered}\begin{aligned}
      \vFunc_{\prdt}(\mNrm_{\prdt}) & = \max_{\cNrm} ~~ \uFunc(\cNrm)+ \DiscFac \Ex_{\prdt}[ \PermGroFac_{\prdt+1}^{1-\CRRA}\vFunc_{\prdt+1}(\overbrace{(\mNrm_{\prdt}-\cNrm)(\Rfree/\PermGroFac_{\prdt+1})+\tranShkEmp_{\prdt+1}}^{\mNrm_{\prdt+1}})] \label{eq:vusual}.
\UnifiedNote{same normalized MDP as eq:vNormed with transitions composed: m' = (m‚àíc)(R/Œì) + Œ∏ composes g·µ•‚Çë, g‚Çë‚Çê‚Çä, and g‚Çê·µ•; ùí±(m) = max_c u(c) + Œ≤ ùîº[Œì^{1‚àíœÅ} ùí±(m')]}
    \end{aligned}\end{gathered}\end{equation}

\end{document}
