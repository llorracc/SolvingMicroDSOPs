<!DOCTYPE html> 
<html lang="en" xml:lang="en" > 
<head>
  <title>Solution Methods for Microeconomic
Dynamic Stochastic Optimization Problems</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="SolvingMicroDSOPs.css" /> 
<meta name="src" content="SolvingMicroDSOPs.tex"> 
</head><body 
>
<!--l. 71--><p class="noindent" >                                                                  <span 
class="ecrm-0600">SolvingMicroDSOPs, March 17,</span>
<span 
class="ecrm-0600">2024</span>
  <div class="maketitle">
<h2 class="titleHead">Solution Methods for Microeconomic<br />
Dynamic Stochastic Optimization Problems</h2>
<div class="date" >2023-03-16</div>
<span 
class="ecrm-0600">¬†</span>
 <div class="author" ><span 
class="ecrm-1440">Christopher D. Carroll</span><sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup></div>
<br />
</div>
<!--l. 87--><p class="noindent" >Note: The code associated with this document should work (though the Matlab code may be
out of date), but has been superceded by the set of tools available in the <a 
href="https://github.com/econ-ark/HARK" >Econ-ARK</a> toolkit,
more speciÔ¨Åcally the <a 
href="https://github.com/econ-ark/HARK" >HARK Framework</a>. The SMM estimation code at the end has speciÔ¨Åcally
been superceded by the <a 
href="https://econ-ark.org/materials/solvingmicrodsops?launch" >SolvingMicroDSOPs</a> <a 
href="https://github.com/econ-ark/REMARK" >REMARK</a>
<!--l. 90--><p class="indent" >  <a 
 id="Abstract"></a> <section role="doc-abstract" class="abstract"> 

<!--l. 91--><p class="noindent" > <br 
class="newline" />_____________________________________________________________________________________
<!--l. 91--><p class="noindent" ><span 
class="ecbx-1200">Abstract</span><br 
class="newline" />   <span 
class="ecrm-1095">These notes describe tools for solving microeconomic dynamic stochastic optimization problems,</span>
<span 
class="ecrm-1095">and show how to use those tools for eÔ¨Éciently estimating a standard life cycle consumption/saving</span>
<span 
class="ecrm-1095">model using microeconomic data. No attempt is made at a systematic overview of the many possible</span>
<span 
class="ecrm-1095">technical choices; instead, I present a speciÔ¨Åc set of methods that have proven useful in my own work</span>
<span 
class="ecrm-1095">(and explain why other popular methods, such as value function iteration, are a bad idea). Paired</span>
<span 
class="ecrm-1095">with these notes is </span><span 
class="ecti-1095">Mathematica</span><span 
class="ecrm-1095">, Matlab, and Python software that solves the problems described in</span>
<span 
class="ecrm-1095">the text.   </span><br 
class="newline" />
        <blockquote class="quote">
                     <dl class="list2"><dt class="list">
<span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†Keywords</span><span 
class="ecbx-1200">¬†</span></dt><dd 
class="list">
                 <!--l. 93--><p class="noindent" >Dynamic  Stochastic  Optimization,  Method  of  Simulated
                   Moments, Structural Estimation
                                                                                     
                                                                                     
              </dd><dt class="list">
<span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†</span><span 
class="ecbx-1200">¬†JEL codes</span><span 
class="ecbx-1200">¬†</span></dt><dd 
class="list">
              <!--l. 93--><p class="noindent" >E21, F41</dd></dl>
      </blockquote>
</section>
<div class="center" 
>
<!--l. 96--><p class="noindent" >
<table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†PDF:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs.pdf" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs.pdf</span></a>
</td></tr></table>
<!--l. 98--><p class="noindent" ><table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†Slides:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs-Slides.pdf" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs-Slides.pdf</span></a></td></tr></table>
<!--l. 99--><p class="noindent" >                                <table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†Web:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://llorracc.github.io/SolvingMicroDSOPs" class="url" ><span 
class="ectt-1000">https://llorracc.github.io/SolvingMicroDSOPs</span></a></td></tr></table>
<!--l. 100--><p class="noindent" >              <table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†Code:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs/tree/master/Code" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs/tree/master/Code</span></a></td></tr></table>
<!--l. 101--><p class="noindent" >                               <table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">Archive:</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs</span></a></td></tr></table>
<!--l. 102--><p class="noindent" >     <table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬†</span><span 
class="ectt-1000">¬† </span></td><td  
class="tabbing"></td><td  
class="tabbing"><span 
class="ecti-1000">(Contains LaTeX code for this document and software producing Ô¨Ågures and results)</span></td></tr></table>
<!--l. 104--><p class="noindent" >
</div>
<!--l. 111--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
<!--l. 113--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
      <sup class="textsuperscript"></sup>
<!--l. 110--><p class="indent" >  <sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup><span 
class="ecrm-1000">Carroll: Department of Economics, Johns Hopkins University, Baltimore, MD,</span>
<a 
href="http://www.econ2.jhu.edu/people/ccarroll/" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/</span></a><span 
class="ecrm-1000">, </span><a 
href="mailto:ccarroll@jhu.edu" ><span 
class="ectt-1000">ccarroll@jhu.edu</span></a><span 
class="ecrm-1000">, Phone: (410) 516-7602</span><span 
class="ecrm-1000">¬†</span><span 
class="ecrm-1000">¬†</span><span 
class="ecrm-1000">¬†</span><span 
class="ecrm-1000">¬†</span>
      <sup class="textsuperscript"></sup><span 
class="ecrm-1000">The notes were originally written for my Advanced Topics in Macroeconomic Theory class at</span>
<span 
class="ecrm-1000">Johns Hopkins University; instructors elsewhere are welcome to use them for teaching purposes. Relative</span>
<span 
class="ecrm-1000">to earlier drafts, this version incorporates several improvements related to new results in the paper</span>
<a 
href="http://econ-ark.github.io/BufferStockTheory" ><span 
class="ecrm-1000">‚ÄúTheoretical Foundations of BuÔ¨Äer Stock Saving‚Äù</span></a> <span 
class="ecrm-1000">(especially tools for approximating the consumption</span>
<span 
class="ecrm-1000">and value functions). Like the last major draft, it also builds on material in ‚ÄúThe Method of Endogenous</span>
<span 
class="ecrm-1000">Gridpoints  for  Solving  Dynamic  Stochastic  Optimization  Problems‚Äù   published  in  </span><span 
class="ecti-1000">Economics</span>
<span 
class="ecti-1000">Letters</span><span 
class="ecrm-1000">,  available  at  </span><a 
href="http://www.econ2.jhu.edu/people/ccarroll/EndogenousArchive.zip" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/EndogenousArchive.zip</span></a><span 
class="ecrm-1000">,  and</span>
<span 
class="ecrm-1000">by  including  sample  code  for  a  method  of  simulated  moments  estimation  of  the  life  cycle</span>
<span 
class="ecrm-1000">model  </span><span 
class="ecti-1000">a  la  </span><a 
href="#XgpLifecycle"><span 
class="ecrm-1000">Gourinchas  and  Parker</span></a><span 
class="ecrm-1000">¬†(</span><a 
href="#XgpLifecycle"><span 
class="ecrm-1000">2002</span></a><span 
class="ecrm-1000">)  and  Cagetti</span><span 
class="ecrm-1000">¬†(</span><a 
href="#XcagettiWprofiles"><span 
class="ecrm-1000">2003</span></a><span 
class="ecrm-1000">).  Background  derivations,  notation,</span>
<span 
class="ecrm-1000">and   related   subjects   are   treated   in   my   class   notes   for   Ô¨Årst   year   macro,   available   at</span>
<a 
href="http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption</span></a><span 
class="ecrm-1000">.  I  am  grateful</span>
<span 
class="ecrm-1000">to several generations of graduate students in helping me to reÔ¨Åne these notes, to Marc Chan for help</span>
<span 
class="ecrm-1000">in updating the text and software to be consistent with </span><a 
href="#XcarrollEGM"><span 
class="ecrm-1000">Carroll</span></a><span 
class="ecrm-1000">¬†(</span><a 
href="#XcarrollEGM"><span 
class="ecrm-1000">2006</span></a><span 
class="ecrm-1000">), to Kiichi Tokuoka for drafting</span>
<span 
class="ecrm-1000">the section on structural estimation, to Damiano Sandri for exceptionally insightful help in revising and</span>
<span 
class="ecrm-1000">updating the method of simulated moments estimation section, and to Weifeng Wu and Metin Uyanik</span>
<span 
class="ecrm-1000">for revising to be consistent with the ‚Äòmethod of moderation‚Äô and other improvements. All errors are</span>
<span 
class="ecrm-1000">my own. This document can be cited as </span><a 
href="#XSolvingMicroDSOPs"><span 
class="ecrm-1000">Carroll</span></a><span 
class="ecrm-1000">¬†(</span><a 
href="#XSolvingMicroDSOPs"><span 
class="ecrm-1000">2023</span></a><span 
class="ecrm-1000">) in the references.</span>
                                                                                     
                                                                                     
<!--l. 122--><p class="indent" >  <a 
 id="Introduction"></a>
  <h3 class="sectionHead"><span class="titlemark">1  </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 125--><p class="noindent" >Calculating the mathematically optimal amount to save is remarkably diÔ¨Écult. Under
well-founded assumptions about the nature of risk (and attitudes toward risk), the problem
cannot be solved analytically; computational solutions are the only option. To avoid having to
solve this hard problem, past generations of economists showed impressive ingenuity in
reformulating the question. Budding graduate students are still taught a host of tricks
whose purpose is partly to avoid the resort to numerical solutions: Quadratic or
Constant Absolute Risk Aversion utility, perfect markets, perfect insurance, perfect
foresight, the ‚Äútimeless perspective,‚Äù the restriction of uncertainty to very special
kinds,<span class="footnote-mark"><a 
href="SolvingMicroDSOPs2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-1001f1"></a>  
and more.
<!--l. 127--><p class="indent" >  The motivation for these reformulations is to exchange an intractable general problem for a
tractable speciÔ¨Åc alternative. Unfortunately, the burgeoning literature on numerical solutions
has shown that the features that yield tractability also profoundly change the essence of the
solution. These tricks are excuses to solve a problem that has deÔ¨Åned away the central
diÔ¨Éculty: Understanding the proper role of uncertainty (and other complexities like
constraints) in optimal intertemporal choice.
<!--l. 137--><p class="indent" >  These points are not unique to the consumption/saving problem; the same propositions
apply to almost any question that involves both intertemporal choice and uncertainty,
including many aspects of the behavior of Ô¨Årms and governments.
<!--l. 144--><p class="indent" >  These lecture notes provide a gentle introduction to a particular set of solution tools and
show how they can be used to solve some canonical problems in consumption choice and
portfolio allocation. SpeciÔ¨Åcally, the notes describe and solve optimization problems for a
consumer facing uninsurable idiosyncratic risk to nonÔ¨Ånancial income (e.g., labor or transfer
income),<span class="footnote-mark"><a 
href="SolvingMicroDSOPs3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-1002f2"></a>  
with detailed intuitive discussion of the various mathematical and computational techniques
that, together, speed the solution by many orders of magnitude compared to ‚Äúbrute
force‚Äù methods. The problem is solved with and without liquidity constraints, and
the inÔ¨Ånite horizon solution is obtained as the limit of the Ô¨Ånite horizon solution.
After the basic consumption/saving problem with a deterministic interest rate is
                                                                                     
                                                                                     
described and solved, an extension with portfolio choice between a riskless and a
risky asset is also solved. Finally, a simple example is presented of how to use these
methods (via the statistical ‚Äòmethod of simulated moments‚Äô or MSM; sometimes called
‚Äòsimulated method of moments‚Äô or SMM) to estimate structural parameters like
the coeÔ¨Écient of relative risk aversion (<span 
class="ecti-1200">a la </span>Gourinchas and Parker¬†(<a 
href="#XgpLifecycle">2002</a>) and
Cagetti¬†(<a 
href="#XcagettiWprofiles">2003</a>)).
<!--l. 175--><p class="indent" >  <a 
 id="the-problem"></a>
  <h3 class="sectionHead"><span class="titlemark">2  </span> <a 
 id="x1-20002"></a>The Problem</h3>
<!--l. 1--><p class="noindent" >The usual analysis of dynamic stochastic programming problems packs a great many
events (intertemporal choice, stochastic shocks, intertemporal returns, income growth,
and more) into a small number of steps and variables. For the detailed analysis
here, we will be careful to disarticulate everything that happens in the problem
explicitly into separate steps so that each element can be scrutinized and understood in
isolation.
<!--l. 3--><p class="indent" >  We are interested in the behavior a consumer who begins period <img 
src="SolvingMicroDSOPs0x.svg" alt="t  " class="math";align="absmiddle"> with a certain amount
of ‚Äòcapital‚Äô <img 
src="SolvingMicroDSOPs1x.svg" alt="kt  " class="math";align="absmiddle">, which is immediately rewarded by a return factor <img 
src="SolvingMicroDSOPs2x.svg" alt="Rt  " class="math";align="absmiddle"> with the proceeds
deposited in a <span 
class="ecbx-1200">b</span>ank account <span 
class="ecbx-1200">b</span>alance:
  <table 
class="equation"><tr><td><a 
 id="x1-2001r1"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs3x.svg" alt="bt = ktRt.
" class="math-display" ></div>
  </td><td class="equation-label">(1)</td></tr></table>
<!--l. 6--><p class="nopar" >
<!--l. 9--><p class="indent" >  Simultaneously with the realization of the capital return, the consumer also receives
noncapital income <img 
src="SolvingMicroDSOPs4x.svg" alt="yt  " class="math";align="absmiddle">, which is determined by multiplying the consumer‚Äôs ‚Äòpermanent
income‚Äô <img 
src="SolvingMicroDSOPs5x.svg" alt="pt  " class="math";align="absmiddle"> by a transitory shock <img 
src="SolvingMicroDSOPs6x.svg" alt="ùúÉùúÉùúÉt  " class="math";align="absmiddle">:
  <table 
class="equation"><tr><td><a 
 id="x1-2002r2"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs7x.svg" alt="yt = ptùúÉùúÉùúÉt
" class="math-display" ></div>
  </td><td class="equation-label">(2)</td></tr></table>
<!--l. 12--><p class="nopar" >
whose whose expectation is 1 (that is, before realization of the transitory shock, the
consumer‚Äôs expectation is that actual income will on average be equal to permanent income
<img 
src="SolvingMicroDSOPs8x.svg" alt="pt  " class="math";align="absmiddle">).
<!--l. 15--><p class="indent" >  The combination of bank balances <img 
src="SolvingMicroDSOPs9x.svg" alt="b  " class="math";align="absmiddle"> and income <img 
src="SolvingMicroDSOPs10x.svg" alt="y  " class="math";align="absmiddle"> deÔ¨Åne‚Äôs the consumer‚Äôs ‚Äòmarket
resources‚Äô (sometimes called ‚Äòcash-on-hand‚Äô, following¬†<span 
class="ecbx-1200">?</span>):
  <table 
class="equation"><tr><td><a 
 id="x1-2003r3"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs11x.svg" alt="m  =  b +  y ,
  t    t    t
" class="math-display" ></div>
  </td><td class="equation-label">(3)</td></tr></table>
<!--l. 18--><p class="nopar" >
which are available to be spent on consumption <img 
src="SolvingMicroDSOPs12x.svg" alt="c
 t  " class="math";align="absmiddle">.
<!--l. 21--><p class="indent" >  The consumer‚Äôs goal is to maximize discounted utility from consumption over the rest of a
lifetime whose last period is date <img 
src="SolvingMicroDSOPs13x.svg" alt="T  " class="math";align="absmiddle">:
  <table 
class="equation"><tr><td><a 
 id="x1-2004r4"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs14x.svg" alt="        [T‚àë ‚àít          ]
max  ùîºt      Œ≤nu (ct+n ) .
          n=0
" class="math-display" ></div>
  </td><td class="equation-label">(4)</td></tr></table>
                                                                                     
                                                                                     
<!--l. 3--><p class="nopar" >
<!--l. 210--><p class="indent" >  For now, we will assume that income evolves according to:
  <table 
class="equation"><tr><td><a 
 id="x1-2005r5"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs15x.svg" alt="    pt+1 = ùí¢t+1pt- permanent  labor  income  dynamics
log  ùúÉùúÉùúÉ    ‚àº  ùí© (‚àí œÉ2‚àï2,œÉ2)                             - lognormal  transitory shocks  ‚àÄ n &#x003E; 0
     t+n          ùúÉùúÉùúÉ    ùúÉùúÉùúÉ
" class="math-display" ></div>
  </td><td class="equation-label">(5)</td></tr></table>
<!--l. 5--><p class="nopar" >
<!--l. 221--><p class="indent" >  Equation (<a 
href="#x1-2005r5">5<!--tex4ht:ref: eq:permincgrow --></a>) indicates that we are allowing for a predictable average proÔ¨Åle of income
growth over the lifetime <img 
src="SolvingMicroDSOPs16x.svg" alt="{ùí¢ }T0   " class="math";align="absmiddle"> (to capture typical career wage paths, pension arrangements,
etc).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-2006f3"></a>  
Finally, the utility function is of the Constant Relative Risk Aversion (CRRA), form,
<img 
src="SolvingMicroDSOPs17x.svg" alt="         1‚àí œÅ
u(‚àô ) = ‚àô   ‚àï(1 ‚àí œÅ )  " class="math";align="absmiddle">.
<!--l. 225--><p class="indent" >  It is well known that this problem can be rewritten in recursive (Bellman) form
  <table 
class="equation"><tr><td><a 
 id="x1-2007r6"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs18x.svg" alt="vt(mt, pt) = max  u(ct) + Œ≤ ùîºt[vt+1 (mt+1, pt+1)]
              ct
" class="math-display" ></div>
  </td><td class="equation-label">(6)</td></tr></table>
<!--l. 5--><p class="nopar" >
subject to the Dynamic Budget Constraint (DBC) implicitly deÔ¨Åned by equations¬†(<a 
href="#x1-2001r1">1<!--tex4ht:ref: eq:bLvl --></a>)-(<a 
href="#x1-2003r3">3<!--tex4ht:ref: eq:mLvl --></a>) and
the transition equation that deÔ¨Ånes next period‚Äôs initial capital as this period‚Äôs end-of-period
assets:
  <table 
class="equation"><tr><td><a 
 id="x1-2008r7"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs19x.svg" alt="kt+1 = at.
" class="math-display" ></div>
  </td><td class="equation-label">(7)</td></tr></table>
<!--l. 238--><p class="nopar" >
<!--l. 240--><p class="indent" >  <a 
 id="Normalization"></a>
  <h3 class="sectionHead"><span class="titlemark">3  </span> <a 
 id="x1-30003"></a>Normalization</h3>
<!--l. 242--><p class="noindent" >The single most powerful method for speeding the solution of such models is to redeÔ¨Åne the
problem in a way that reduces the number of state variables (if possible). Here, the obvious
idea is to see whether the problem can be rewritten in terms of the ratio of various variables to
permanent noncapital (‚Äòlabor‚Äô) income <img 
src="SolvingMicroDSOPs20x.svg" alt="pt  " class="math";align="absmiddle"> (henceforth for brevity referred to simply as
‚Äòpermanent income.‚Äô)
<!--l. 246--><p class="indent" >  In the last period of life, there is no future, <img 
src="SolvingMicroDSOPs21x.svg" alt="vT +1 = 0  " class="math";align="absmiddle">, so the optimal plan is to consume
everything:
  <table 
class="equation"><tr><td><a 
 id="x1-3001r8"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs22x.svg" alt="               m1 ‚àíœÅ
vT (mT ,pT ) = --T--.
               1 ‚àí œÅ
" class="math-display" ></div>
  </td><td class="equation-label">(8)</td></tr></table>
<!--l. 253--><p class="nopar" >
Now deÔ¨Åne nonbold variables as the bold variable divided by the level of permanent
income in the same period, so that, for example, <img 
src="SolvingMicroDSOPs23x.svg" alt="mT  =  mT ‚àïpT  " class="math";align="absmiddle">; and deÔ¨Åne
<img 
src="SolvingMicroDSOPs24x.svg" alt="vT (mT ) = u(mT )  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs5.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-3002f4"></a>  
For our CRRA utility function, <img 
src="SolvingMicroDSOPs27x.svg" alt="u(xy) = x1‚àí œÅu (y)  " class="math";align="absmiddle">, so equation (<a 
href="#x1-3001r8">8<!--tex4ht:ref: eq:levelTm1 --></a>) can be rewritten
as
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs28x.svg" alt="                1‚àíœÅ m1‚àíT œÅ
vT (mT ,pT ) = pT   ------
                    1 ‚àí œÅ    1‚àíœÅ
                        1‚àíœÅm-T---
             = (pT‚àí 1ùí¢T)   1 ‚àí œÅ
                1‚àíœÅ  1‚àíœÅ
             = pT ‚àí1ùí¢T  vT (mT ).
" class="math-display" ></div>
  </td></tr></table>
<!--l. 264--><p class="nopar" >
<!--l. 266--><p class="indent" >  Now deÔ¨Åne a new optimization problem:
  <table 
class="equation"><tr><td><a 
 id="x1-3003r9"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs29x.svg" alt="vt(mt ) = max  u (ct) + Œ≤ ùîºt[ùí¢1 ‚àíœÅvt+1(mt+1)]
           ct                t+1
      s.t.

     at = mt ‚àí ct
  mt+1 = (R ‚àïùí¢t+1)at + ùúÉùúÉùúÉt+1.
         ‚óü---‚óù‚óú--‚óû
           ‚â°‚Ñõt+1
" class="math-display" ></div>
  </td><td class="equation-label">(9)</td></tr></table>
<!--l. 7--><p class="nopar" >
where the last equation is the normalized version of the transition equation for
<img 
src="SolvingMicroDSOPs30x.svg" alt="mt+1   " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs6.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-3004f5"></a>  
Then it is easy to see that for <img 
src="SolvingMicroDSOPs32x.svg" alt="t = T ‚àí 1  " class="math";align="absmiddle">,
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs33x.svg" alt="vT ‚àí1(mT ‚àí1,pT ‚àí1) = p1T‚àí‚àíœÅ1vT‚àí1(mT ‚àí1)
" class="math-display" ></div>
                                                                                     
                                                                                     
  </td></tr></table>
<!--l. 286--><p class="nopar" >
and so on back to all earlier periods. Hence, if we solve the problem (<a 
href="#x1-3003r9">9<!--tex4ht:ref: vtNorm --></a>) which has
only a single state variable <img 
src="SolvingMicroDSOPs34x.svg" alt="m
  t  " class="math";align="absmiddle">, we can obtain the levels of the value function,
consumption, and all other variables from the corresponding permanent-income-normalized
solution objects by multiplying each by <img 
src="SolvingMicroDSOPs35x.svg" alt="pt  " class="math";align="absmiddle">, e.g.¬†<img 
src="SolvingMicroDSOPs36x.svg" alt="ccct(mt, pt) = ptct(mt ‚àïpt)  " class="math";align="absmiddle"> (or, for
the value function, <img 
src="SolvingMicroDSOPs37x.svg" alt="vt(mt, pt) = p1‚àít œÅvt(mt ))  " class="math";align="absmiddle">. We have thus reduced the problem
from two continuous state variables to one (and thereby enormously simpliÔ¨Åed its
solution).
<!--l. 295--><p class="indent" >  For some problems it will not be obvious that there is an appropriate ‚Äònormalizing‚Äô variable,
but many problems can be normalized if suÔ¨Écient thought is given. For example, <span 
class="ecbx-1200">? </span>shows
how a bank‚Äôs optimization problem can be normalized by the level of the bank‚Äôs
productivity.
<!--l. 301--><p class="indent" >  <a 
 id="The-Usual-Theory"></a>
  <h3 class="sectionHead"><span class="titlemark">4  </span> <a 
 id="x1-40004"></a>The Usual Theory, and A Bit More Notation</h3>
<!--l. 306--><p class="noindent" >The Ô¨Årst order condition for (<a 
href="#x1-3003r9">9<!--tex4ht:ref: vtNorm --></a>) with respect to <img 
src="SolvingMicroDSOPs38x.svg" alt="ct  " class="math";align="absmiddle"> is
  <table 
class="equation"><tr><td><a 
 id="x1-4001r10"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs39x.svg" alt=" c                 1‚àíœÅ m
u (ct) = ùîºt[Œ≤ ‚Ñõt+1ùí¢ t+1 vt+1(mt+1)]
      =  ùîº [Œ≤R     ùí¢ ‚àíœÅvm  (m    )]
          t        t+1  t+1   t+1
" class="math-display" ></div>
  </td><td class="equation-label">(10)</td></tr></table>
<!--l. 310--><p class="nopar" >
and because the <a 
href="https://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption/Envelope" ><span 
class="ectt-1200">Envelope</span></a> theorem tells us that
  <table 
class="equation"><tr><td><a 
 id="x1-4002r11"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs40x.svg" alt=" m               ‚àí œÅ m
vt (mt) = ùîºt[Œ≤R ùí¢t+1vt+1(mt+1 )]
" class="math-display" ></div>
  </td><td class="equation-label">(11)</td></tr></table>
<!--l. 314--><p class="nopar" >
we can substitute the LHS of (<a 
href="#x1-4002r11">11<!--tex4ht:ref: eq:envelope --></a>) for the RHS of (<a 
href="#x1-4001r10">10<!--tex4ht:ref: eq:upceqEvtp1 --></a>) to get
  <table 
class="equation"><tr><td><a 
 id="x1-4003r12"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs41x.svg" alt="uc(c) = vm (m  )
    t    t    t
" class="math-display" ></div>
  </td><td class="equation-label">(12)</td></tr></table>
<!--l. 3--><p class="nopar" >
and rolling this equation forward one period yields
  <table 
class="equation"><tr><td><a 
 id="x1-4004r13"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs42x.svg" alt="uc(ct+1 ) = vmt+1(at‚Ñõt+1 + ùúÉùúÉùúÉt+1)
" class="math-display" ></div>
  </td><td class="equation-label">(13)</td></tr></table>
<!--l. 326--><p class="nopar" >
while substituting the LHS in equation (<a 
href="#x1-4001r10">10<!--tex4ht:ref: eq:upceqEvtp1 --></a>) gives us the Euler equation for consumption
  <table 
class="equation"><tr><td><a 
 id="x1-4005r14"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs43x.svg" alt=" c              ‚àíœÅ  c
u (ct) = ùîºt[Œ≤R ùí¢ t+1u (ct+1)].
" class="math-display" ></div>
  </td><td class="equation-label">(14)</td></tr></table>
<!--l. 3--><p class="nopar" >
Although our focus so far has been on the consumer‚Äôs consumption problem once <img 
src="SolvingMicroDSOPs44x.svg" alt="m  " class="math";align="absmiddle"> is
known, for constructing the computational solution it will be useful to distinguish a sequence
of three moves (we use the word ‚Äòmoves‚Äô to capture the fact that we are not really thinking
of these as occurring at diÔ¨Äerent moments in time ‚Äì only that we are putting the
things that happen within a given moment into an ordered sequence). The Ô¨Årst
move captures calculations that need to be performed before the shocks are realized,
the middle move is after shocks have been realized but before the consumption
decision has been made (this corresponds to the timing of <img 
src="SolvingMicroDSOPs45x.svg" alt="v  " class="math";align="absmiddle"> in the treatment above),
and the Ô¨Ånal move captures the situation <span 
class="ecti-1200">after </span>the consumption decision has been
made.
<!--l. 1--><p class="indent" >  We need to deÔ¨Åne notation for these three moves within a period. We will use <img 
src="SolvingMicroDSOPs46x.svg" alt="‚àí t  " class="math";align="absmiddle"> as a
marker for the move before shocks have been realized, <img 
src="SolvingMicroDSOPs47x.svg" alt="‚àº t  " class="math";align="absmiddle"> to indicate the move in which the
choice is made, and <img 
src="SolvingMicroDSOPs48x.svg" alt="+ t  " class="math";align="absmiddle"> as the indicator for the situation once the choice has been made.
  <table 
class="equation"><tr><td><a 
 id="x1-4006r15"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs49x.svg" alt="                  ‚óú--=m‚óût‚óü--‚óù
v ‚àít(kt) = ùîº ‚àít[v‚àºt(kt‚Ñõt + ùúÉùúÉùúÉt)]
" class="math-display" ></div>
  </td><td class="equation-label">(15)</td></tr></table>
<!--l. 3--><p class="nopar" >
  <table 
class="equation"><tr><td><a 
 id="x1-4007r16"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs50x.svg" alt="v‚àºt(mt ) = u(ct(mt )) + v+t (at)
" class="math-display" ></div>
  </td><td class="equation-label">(16)</td></tr></table>
<!--l. 3--><p class="nopar" >
  <table 
class="equation"><tr><td><a 
 id="x1-4008r17"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs51x.svg" alt="v+t(at) = Œ≤v ‚àít(kt+1)
               ‚óü‚óù‚óú‚óû
               =at
" class="math-display" ></div>
  </td><td class="equation-label">(17)</td></tr></table>
<!--l. 3--><p class="nopar" >
where the last line illustrates the notation for addressing the beginning move of a future
period.
<!--l. 366--><p class="indent" >  Putting all this together, we can write the ‚Äòcontinuation value‚Äô function from the perspective
of the end of the period <img 
src="SolvingMicroDSOPs52x.svg" alt="t  " class="math";align="absmiddle"> as
  <table 
class="equation"><tr><td><a 
 id="x1-4009r18"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs53x.svg" alt="v  (a ) = ùîº [Œ≤ ùí¢1‚àíœÅv   (‚Ñõ    a + ùúÉùúÉùúÉ   )]
 +t  t     t   t+1 t+1   t+1  t   t+1
" class="math-display" ></div>
                                                                                     
                                                                                     
  </td><td class="equation-label">(18)</td></tr></table>
<!--l. 3--><p class="nopar" >
because it returns the expected <img 
src="SolvingMicroDSOPs54x.svg" alt="t + 1  " class="math";align="absmiddle"> value associated with ending period <img 
src="SolvingMicroDSOPs55x.svg" alt="t  " class="math";align="absmiddle"> with any given
amount of assets. DiÔ¨Äerentiating with respect to <img 
src="SolvingMicroDSOPs56x.svg" alt="a  " class="math";align="absmiddle">, we get
  <table 
class="equation"><tr><td><a 
 id="x1-4010r19"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs57x.svg" alt="va+t(at) = ùîºt[Œ≤R ùí¢‚àít+œÅ1vmt+1 (‚Ñõt+1at +  ùúÉùúÉùúÉt+1 )]
" class="math-display" ></div>
  </td><td class="equation-label">(19)</td></tr></table>
<!--l. 376--><p class="nopar" >
or, substituting from equation (<a 
href="#x1-4004r13">13<!--tex4ht:ref: eq:upctp1EqVpxtp1 --></a>),
  <table 
class="equation"><tr><td><a 
 id="x1-4011r20"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs58x.svg" alt=" a          [     ‚àíœÅ  c                    ]
v+t(at) = ùîºt Œ≤R ùí¢ t+1u  (ct+1(‚Ñõt+1at + ùúÉùúÉùúÉt+1)) .
" class="math-display" ></div>
  </td><td class="equation-label">(20)</td></tr></table>
<!--l. 380--><p class="nopar" >
Finally, note for future use that the Ô¨Årst order condition (<a 
href="#x1-4001r10">10<!--tex4ht:ref: eq:upceqEvtp1 --></a>) can now be rewritten compactly
as
  <table 
class="equation"><tr><td><a 
 id="x1-4012r21"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs59x.svg" alt=" c        a
u (ct) = v+t(mt ‚àí ct).
" class="math-display" ></div>
  </td><td class="equation-label">(21)</td></tr></table>
<!--l. 4--><p class="nopar" >
<!--l. 392--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">4.1  </span> <a 
 id="x1-50004.1"></a>Implementation in Python</h4>
<!--l. 394--><p class="noindent" >The code which implements the tasks outlined each of the sections to come are available in the
<span 
class="ectt-1200">SolvingMicroDSOPs </span>jupyter notebook, written in Python programming language. The
beneÔ¨Åts of Python lie in its utilization of object-oriented programming (OOP). The notebook
imports various modules, including the standard <span 
class="ectt-1200">numpy </span>and <span 
class="ectt-1200">scipy </span>modules used for numerical
methods in Python, as well as some user-deÔ¨Åned modules designed to provide numerical
solutions to the consumer‚Äôs problem from the previous section. Before delving into the
computational exercise, it is essential to touch on the practicality of these custom
modules.
<!--l. 396--><p class="noindent" >
  <h5 class="subsubsectionHead"><span class="titlemark">4.1.1  </span> <a 
 id="x1-60004.1.1"></a>Useful auxillary Ô¨Åles</h5>
<!--l. 398--><p class="noindent" >In this exercise, two primary user-deÔ¨Åned modules are frequently imported and
utilized. The Ô¨Årst is the <span 
class="ectt-1200">gothic_class </span>module, which contains functions describing the
end-of-period value functions found in equations (<a 
href="#x1-4006r15">15<!--tex4ht:ref: eq:vBegStge --></a>) - (<a 
href="#x1-4008r17">17<!--tex4ht:ref: eq:vEndStge --></a>) (and the subsequent Ô¨Årst and
second derivatives). The advantage of deÔ¨Åning functions in the code which decompose
the consumer‚Äôs optimal behavior in a given period will become evident in section
<a 
href="#x1-130005.6">5.6<!--tex4ht:ref: subsec:transformation --></a>
<!--l. 400--><p class="indent" >  The <span 
class="ectt-1200">resources </span>module is also used repeatedly throughout the notebook. This Ô¨Åle has three
primary objectives: (i) providing functions that discretize the continuous distributions from
the theoretical model that describe the uncertainty a consumer faces, (ii) deÔ¨Åning the utility
function over consumption under a number of speciÔ¨Åcations, and (iii) enhancing the grid
of end-of-period assets for which functions (such as those from the <span 
class="ectt-1200">gothic_class</span>
module) will be deÔ¨Åned. These objectives will be discussed in greater detail and
with respect to the numerical solution to the problem in subsequent sections of this
document.
<!--l. 402--><p class="indent" >  <a 
 id="Solving-the-Next-To-Last-Period"></a>
                                                                                     
                                                                                     
  <h3 class="sectionHead"><span class="titlemark">5  </span> <a 
 id="x1-70005"></a>Solving the Next-to-Last Period</h3>
<!--l. 404--><p class="noindent" >The problem in the second-to-last period of life is:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs60x.svg" alt="                                     [  1‚àíœÅ                          ]
vT‚àí1(mT ‚àí 1) = macTx‚àí1  u (cT ‚àí1) + Œ≤ ùîºT ‚àí1 ùí¢ T vT((mT ‚àí1 ‚àí cT‚àí 1)‚ÑõT  + ùúÉùúÉùúÉT ) ,
" class="math-display" ></div>
  </td></tr></table>
<!--l. 408--><p class="nopar" >
and using (1) the fact that <img 
src="SolvingMicroDSOPs61x.svg" alt="vT =  u(c)  " class="math";align="absmiddle">; (2) the deÔ¨Ånition of <img 
src="SolvingMicroDSOPs62x.svg" alt="u(c)  " class="math";align="absmiddle">; (3) the deÔ¨Ånition of the
expectations operator, and (4) the fact that <img 
src="SolvingMicroDSOPs63x.svg" alt="ùí¢T  " class="math";align="absmiddle"> is nonstochastic, this becomes
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs64x.svg" alt="                     c1‚àíœÅ          ‚à´ ‚àû ((m     ‚àí c    )‚Ñõ   + ùúÉùúÉùúÉ )1‚àíœÅ
vT‚àí1(mT ‚àí1) = max    -T‚àí1-+  Œ≤ùí¢1T‚àí œÅ    ----T‚àí-1---T‚àí-1--T-------- d‚Ñ± (ùúÉùúÉùúÉ)
               cT‚àí1   1 ‚àí œÅ          0             1 ‚àí œÅ
" class="math-display" ></div>
  </td></tr></table>
<!--l. 418--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs65x.svg" alt="‚Ñ± " class="math";align="absmiddle"> is the cumulative distribution function for <img 
src="SolvingMicroDSOPs66x.svg" alt="ùúÉùúÉùúÉ  " class="math";align="absmiddle">.
<!--l. 421--><p class="indent" >  In principle, the maximization implicitly deÔ¨Ånes a function <img 
src="SolvingMicroDSOPs67x.svg" alt="c   (m    )
 T‚àí1   T‚àí1  " class="math";align="absmiddle"> that yields optimal
consumption in period <img 
src="SolvingMicroDSOPs68x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> for any given level of resources <img 
src="SolvingMicroDSOPs69x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">. Unfortunately, there is
no general analytical solution to this maximization problem, and so for any given
<img 
src="SolvingMicroDSOPs70x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle"> we must use numerical computational tools to Ô¨Ånd the <img 
src="SolvingMicroDSOPs71x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> that maximizes
the expression. This is excruciatingly slow because for every potential <img 
src="SolvingMicroDSOPs72x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> to be
considered, the integral must be calculated numerically, and numerical integration is <span 
class="ecti-1200">very</span>
slow.
<!--l. 423--><p class="indent" >  <a 
 id="Discretizing-the-Distribution"></a>
                                                                                     
                                                                                     
  <h4 class="subsectionHead"><span class="titlemark">5.1  </span> <a 
 id="x1-80005.1"></a>Discretizing the Distribution</h4>
<!--l. 425--><p class="noindent" >Our Ô¨Årst time-saving trick is therefore to construct a discrete approximation to the lognormal
distribution that can be used in place of numerical integration. That is, we want to
approximate the expectation of a function <img 
src="SolvingMicroDSOPs73x.svg" alt="g(ùúÉùúÉùúÉ)  " class="math";align="absmiddle"> by value at set of <img 
src="SolvingMicroDSOPs74x.svg" alt="nùúÉùúÉùúÉ  " class="math";align="absmiddle"> points <img 
src="SolvingMicroDSOPs75x.svg" alt="ùúÉùúÉùúÉi  " class="math";align="absmiddle">, each of
which is given an associated probability weight <img 
src="SolvingMicroDSOPs76x.svg" alt="wi  " class="math";align="absmiddle">:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs77x.svg" alt="          ‚à´ ùúÉùúÉùúÉ
ùîº[g(ùúÉùúÉùúÉ)] =    g(ùúÉùúÉùúÉ)d‚Ñ± (ùúÉùúÉùúÉ)
           ùúÉùúÉùúÉ
          ‚àën
       ‚âà     wig (ùúÉùúÉùúÉi)
          ùúÉùúÉùúÉ=1
" class="math-display" ></div>
  </td></tr></table>
<!--l. 429--><p class="nopar" >
because adding <img 
src="SolvingMicroDSOPs78x.svg" alt="n  " class="math";align="absmiddle"> weighted values to each other is enormously faster than general-purpose
numerical integration.
<!--l. 432--><p class="indent" >  Such a procedure is called a ‚Äòquadrature‚Äô method of integration; <span 
class="ecbx-1200">? </span>survey a number of
options, but for our purposes here we choose the one which is perhaps easiest to understand:
An ‚Äòequiprobable‚Äô approximation (that is, one where each of the values of <img 
src="SolvingMicroDSOPs79x.svg" alt="ùúÉùúÉùúÉi  " class="math";align="absmiddle"> has an equal
probability, equal to <img 
src="SolvingMicroDSOPs80x.svg" alt="1‚àïnùúÉùúÉùúÉ  " class="math";align="absmiddle">).
<!--l. 434--><p class="indent" >  We calculate such an <img 
src="SolvingMicroDSOPs81x.svg" alt="n  " class="math";align="absmiddle">-point approximation as follows.
<!--l. 436--><p class="indent" >  DeÔ¨Åne a set of points from <img 
src="SolvingMicroDSOPs82x.svg" alt="‚ôØ0   " class="math";align="absmiddle"> to <img 
src="SolvingMicroDSOPs83x.svg" alt="‚ôØnùúÉ
  ùúÉùúÉ   " class="math";align="absmiddle"> on the <img 
src="SolvingMicroDSOPs84x.svg" alt="[0,1]  " class="math";align="absmiddle"> interval as the elements of the set
<img 
src="SolvingMicroDSOPs85x.svg" alt="‚ôØ = {0,1 ‚àïn,2‚àïn, ...,1} " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs7.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-8001f6"></a>  
Call the inverse of the <img 
src="SolvingMicroDSOPs87x.svg" alt="ùúÉùúÉùúÉ  " class="math";align="absmiddle"> distribution <img 
src="SolvingMicroDSOPs88x.svg" alt="  ‚àí1
‚Ñ±   " class="math";align="absmiddle">, and deÔ¨Åne the points <img 
src="SolvingMicroDSOPs89x.svg" alt=" ‚àí1     ‚àí1
‚ôØi  = ‚Ñ±   (‚ôØi)  " class="math";align="absmiddle">. Then the
conditional mean of <img 
src="SolvingMicroDSOPs90x.svg" alt="ùúÉùúÉùúÉ  " class="math";align="absmiddle"> in each of the intervals numbered 1 to <img 
src="SolvingMicroDSOPs91x.svg" alt="n  " class="math";align="absmiddle"> is:
  <table 
class="equation"><tr><td><a 
 id="x1-8002r22"></a>
  <div class="math-display" >
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs92x.svg" alt="                          ‚à´  ‚ôØ‚àíi1
ùúÉùúÉùúÉ  ‚â° ùîº [ùúÉùúÉùúÉ|‚ôØ‚àí1 ‚â§ ùúÉùúÉùúÉ &#x003C;  ‚ôØ‚àí 1] =      ùúó d‚Ñ± (ùúó ).
 i        i‚àí 1       i       ‚ôØ‚àíi1‚àí1
" class="math-display" ></div>
  </td><td class="equation-label">(22)</td></tr></table>
<!--l. 442--><p class="nopar" >
<!--l. 444--><p class="indent" >  The method is illustrated in Figure¬†<a 
href="#x1-80041">1<!--tex4ht:ref: fig:discreteapprox --></a>. The solid continuous curve represents the ‚Äútrue‚Äù CDF
<img 
src="SolvingMicroDSOPs93x.svg" alt="‚Ñ± (ùúÉùúÉùúÉ)  " class="math";align="absmiddle"> for a lognormal distribution such that <img 
src="SolvingMicroDSOPs94x.svg" alt="ùîº [ùúÉùúÉùúÉ ] = 1  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs95x.svg" alt="œÉùúÉùúÉùúÉ = 0.1  " class="math";align="absmiddle">. The short vertical line
segments represent the <img 
src="SolvingMicroDSOPs96x.svg" alt="nùúÉùúÉùúÉ  " class="math";align="absmiddle"> equiprobable values of <img 
src="SolvingMicroDSOPs97x.svg" alt="ùúÉùúÉùúÉi  " class="math";align="absmiddle"> which are used to approximate this
distribution.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs8.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-8003f7"></a>  
<a 
 id="discreteApprox"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-80041"></a>
                                                                                     
                                                                                     
<!--l. 3--><p class="noindent" > <img 
src="./Figures/discreteApprox.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†1:</span><span  
class="content">Equiprobable Discrete Approximation to Lognormal Distribution <img 
src="SolvingMicroDSOPs98x.svg" alt="‚Ñ± " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-80041 -->
                                                                                     
                                                                                     
  </div>
<!--l. 461--><p class="indent" >  Substituting into our deÔ¨Ånition of <img 
src="SolvingMicroDSOPs99x.svg" alt="v+t(at)  " class="math";align="absmiddle">, for <img 
src="SolvingMicroDSOPs100x.svg" alt="t = T ‚àí  1  " class="math";align="absmiddle">
  <table 
class="equation"><tr><td><a 
 id="x1-8005r23"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs101x.svg" alt="                     (   )  nùúÉùúÉùúÉ              1‚àíœÅ
                  1‚àí œÅ  1-- ‚àë   (‚Ñõt+1at-+-ùúÉùúÉùúÉi)---
vT+‚àí 1(aT ‚àí1) = Œ≤ùí¢ t+1   nùúÉùúÉùúÉ            1 ‚àí œÅ
                            i=1
" class="math-display" ></div>
  </td><td class="equation-label">(23)</td></tr></table>
<!--l. 3--><p class="nopar" >
so we can rewrite the maximization problem as
  <table 
class="equation"><tr><td><a 
 id="x1-8006r24"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs102x.svg" alt="                   {                             }
                     c1‚àíœÅ
vT‚àí1(mT ‚àí1) = max    -T‚àí-1-+ vT+‚àí 1(mT  ‚àí1 ‚àí cT ‚àí1)  .
              cT‚àí1   1 ‚àí œÅ
" class="math-display" ></div>
  </td><td class="equation-label">(24)</td></tr></table>
<!--l. 8--><p class="nopar" >
<!--l. 481--><p class="indent" >  In the <span 
class="ectt-1200">SolvingMicroDSOPs </span>notebook, the section ‚ÄúDiscretization of the Income Shock
Distribution‚Äù provides code which instantiates the <span 
class="ectt-1200">DiscreteApproximation </span>class deÔ¨Åned in
the <span 
class="ectt-1200">resources </span>module. This class creates a discretization of the continuous log-normal
distribution of transitory shocks to income by utilizing seven points, where the mean value is
<img 
src="SolvingMicroDSOPs103x.svg" alt="‚àí .5œÉ2   " class="math";align="absmiddle">, and the standard deviation is <img 
src="SolvingMicroDSOPs104x.svg" alt="œÉ =  .5  " class="math";align="absmiddle">.
<!--l. 483--><p class="indent" >  With a close look at the <span 
class="ectt-1200">DiscreteApproximation </span>class and its subclasses, one may notice
that the code is a computational implementation of the mathematical description of
equiprobable discrete approximation in this section. Moreover, the Python code
generates a graph of the discretized distribution, similar to the one depicted in Ô¨Ågure
                                                                                     
                                                                                     
1.
<!--l. 485--><p class="indent" >  <a 
 id="The-Approximate-Consumption-and-Value-Functions"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.2  </span> <a 
 id="x1-90005.2"></a>The Approximate Consumption and Value Functions</h4>
<!--l. 488--><p class="noindent" >Given a particular value of <img 
src="SolvingMicroDSOPs105x.svg" alt="m
  T‚àí1   " class="math";align="absmiddle">, a numerical maximization routine can now Ô¨Ånd the <img 
src="SolvingMicroDSOPs106x.svg" alt="c
 T‚àí1   " class="math";align="absmiddle">
that maximizes (<a 
href="#x1-8006r24">24<!--tex4ht:ref: eq:vEndTm1 --></a>) in a reasonable amount of time.
<!--l. 490--><p class="indent" >  The <span 
class="ectt-1200">SolvingMicroDSOPs </span>notebook follows a series of steps to achieve this. Initially,
parameter values for the coeÔ¨Écient of relative risk aversion (CRRA, <img 
src="SolvingMicroDSOPs107x.svg" alt="œÅ  " class="math";align="absmiddle">), the discount
factor (<img 
src="SolvingMicroDSOPs108x.svg" alt="Œ≤  " class="math";align="absmiddle">), the permanent income growth factor (<img 
src="SolvingMicroDSOPs109x.svg" alt="ùí¢ " class="math";align="absmiddle">), and the risk-free interest
rate (<img 
src="SolvingMicroDSOPs110x.svg" alt="R  " class="math";align="absmiddle">) are speciÔ¨Åed in ‚ÄúDeÔ¨Åne Parameters, Grids, and the Utility Function‚Äù.
Predictably, the CRRA utility function is deÔ¨Åned for the given value of <img 
src="SolvingMicroDSOPs111x.svg" alt="œÅ  " class="math";align="absmiddle"> here as
well.
<!--l. 492--><p class="indent" >  After deÔ¨Åning the utility function, the natural borrowing constraint is deÔ¨Åned to be
<img 
src="SolvingMicroDSOPs112x.svg" alt="aT  ‚àí 1 = ‚àí ùúÉùúÉùúÉ‚ÑõT ‚àí 1   " class="math";align="absmiddle">, which will be discussed in greater depth in section <a 
href="#x1-140005.7">5.7<!--tex4ht:ref: subsec:LiqConstrSelfImposed --></a>. Following the
reformulation of the maximization problem, an instance of the <span 
class="ectt-1200">gothic_class </span>is created using
the speciÔ¨Åcations and the discretized distribution described in the previous lines of code; this
is required to provide the numerical solution.
<!--l. 494--><p class="indent" >  The heart of the program responsible for computing an estimated consumption
function begins in ‚ÄúSolving the Model by Value Function Maximization‚Äù, where
a grid characterizing the possible values of market resources (<img 
src="SolvingMicroDSOPs113x.svg" alt="m  " class="math";align="absmiddle">) is initialized,
which is the Ô¨Årst step in computing the optimal consumption and value functions.
For each of the <img 
src="SolvingMicroDSOPs114x.svg" alt="m  " class="math";align="absmiddle"> values, the consumption values <img 
src="SolvingMicroDSOPs115x.svg" alt="c  " class="math";align="absmiddle"> that solve the minimization
problem equivalent to (<a 
href="#x1-8006r24">24<!--tex4ht:ref: eq:vEndTm1 --></a>) are computed using <span 
class="ectt-1200">scipy</span>‚Äôs minimize function. This level
of consumption is used to calculate the value function at each point in the grid
of market resources. The process is repeated until all <img 
src="SolvingMicroDSOPs116x.svg" alt="m  " class="math";align="absmiddle"> grid points have been
exhaused.
<!--l. 496--><p class="indent" >  Finally, the previously computed values of optimal consumption and the grid of market
resources are utilized to generate a graph of the approximated consumption function
for this speciÔ¨Åc instance of the problem. To reduce the computational expenses
of solving the problem, the process is repeated with a more sparse grid of market
resources.
<!--l. 499--><p class="indent" >  <a 
 id="an-interpolated-consumption-function"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.3  </span> <a 
 id="x1-100005.3"></a>An Interpolated Consumption Function</h4>
<!--l. 502--><p class="noindent" >Given a set of points on a function (in this case, the consumption function <img 
src="SolvingMicroDSOPs117x.svg" alt="cT‚àí1(m )  " class="math";align="absmiddle">), we can
create an object called an ‚Äòinterpolating function‚Äô which when applied to an input <img 
src="SolvingMicroDSOPs118x.svg" alt="m  " class="math";align="absmiddle"> will
yield the value of <img 
src="SolvingMicroDSOPs119x.svg" alt="c  " class="math";align="absmiddle"> that corresponds to a linear ‚Äòconnect-the-dots‚Äô interpolation of the value
of <img 
src="SolvingMicroDSOPs120x.svg" alt="c  " class="math";align="absmiddle"> from the points, creating a function that aims to provide an approximation of the
functions whose points have been sampled.
<!--l. 504--><p class="indent" >  This is accompished in ‚ÄúAn Interpolated Consumption Function‚Äù, where the
<span 
class="ectt-1200">InterpolatedUnivariateSpline </span>function is called from the <span 
class="ectt-1200">scipy </span>module to deÔ¨Åne an
                                                                                     
                                                                                     
approximation to the consumption function <img 
src="SolvingMicroDSOPs121x.svg" alt="`cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle">. That is, when called with an
<img 
src="SolvingMicroDSOPs122x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle"> that is equal to one of the points in <span 
class="ectt-1200">mVec_int </span>returns the associated value of <img 
src="SolvingMicroDSOPs123x.svg" alt="cT‚àí1,i  " class="math";align="absmiddle">,
and when called with a value of <img 
src="SolvingMicroDSOPs124x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> that is not exactly equal to one of the <span 
class="ectt-1200">mVec_int</span>,
returns the value of <img 
src="SolvingMicroDSOPs125x.svg" alt="c  " class="math";align="absmiddle"> that reÔ¨Çects a linear interpolation between the <img 
src="SolvingMicroDSOPs126x.svg" alt="c
 T‚àí 1,i  " class="math";align="absmiddle"> associated with
the two <span 
class="ectt-1200">mVec_int </span>points nearest to <img 
src="SolvingMicroDSOPs127x.svg" alt="mT  ‚àí1   " class="math";align="absmiddle">. Thus if the function is called with <img 
src="SolvingMicroDSOPs128x.svg" alt="mT  ‚àí1 = 1.75  " class="math";align="absmiddle">
and the nearest gridpoints  are <img 
src="SolvingMicroDSOPs129x.svg" alt="mj,T‚àí1 = 1  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs130x.svg" alt="mk,T‚àí 1 = 2  " class="math";align="absmiddle"> then the value of
<img 
src="SolvingMicroDSOPs131x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> returned by the function would be <img 
src="SolvingMicroDSOPs132x.svg" alt="(0.25cj,T‚àí 1 + 0.75ck,T‚àí1)  " class="math";align="absmiddle">. We can deÔ¨Åne a
numerical approximation to the value function <img 
src="SolvingMicroDSOPs133x.svg" alt="`vT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> in an exactly analogous
way.
<!--l. 507--><p class="indent" >  Figures <a 
href="#x1-100022">2<!--tex4ht:ref: fig:PlotcTm1Simple --></a> and¬†<a 
href="#x1-100033">3<!--tex4ht:ref: fig:PlotVTm1Simple --></a> show plots of the <img 
src="SolvingMicroDSOPs134x.svg" alt="`cT‚àí 1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs135x.svg" alt="`vT ‚àí1   " class="math";align="absmiddle"> <span 
class="ectt-1200">InterpolatedUnivariateSpline</span>
function calls. While the <img 
src="SolvingMicroDSOPs136x.svg" alt="`cT‚àí1   " class="math";align="absmiddle"> function looks very smooth, the fact that the <img 
src="SolvingMicroDSOPs137x.svg" alt="`vT‚àí 1   " class="math";align="absmiddle"> function is
a set of line segments is very evident. This Ô¨Ågure provides the beginning of the intuition
for why trying to approximate the value function directly is a bad idea (in this
context).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs9.html#fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-10001f8"></a>  
<!--l. 511--><p class="indent" >  <a 
 id="PlotcTm1Simple"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100022"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotcTm1Simple.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†2:</span><span  
class="content"><img 
src="SolvingMicroDSOPs138x.svg" alt="cT ‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs139x.svg" alt="`cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-100022 -->
                                                                                     
                                                                                     
  </div>
<!--l. 518--><p class="indent" >  <a 
 id="PlotvTm1Simple"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100033"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotVTm1Simple.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†3:</span><span  
class="content"><img 
src="SolvingMicroDSOPs140x.svg" alt="vT ‚àí1   " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs141x.svg" alt="`vT‚àí 1(mT ‚àí 1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-100033 -->
                                                                                     
                                                                                     
  </div>
<!--l. 525--><p class="indent" >  <a 
 id="Interpolating-Expectations"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.4  </span> <a 
 id="x1-110005.4"></a>Interpolating Expectations</h4>
<!--l. 530--><p class="noindent" >The <span 
class="ectt-1200">InterpolatedUnivariateSpline </span>function works well in the sense that it generates a
good approximation to the true optimal consumption function. However, there is a clear
ineÔ¨Éciency in the program: Since it uses equation (<a 
href="#x1-8006r24">24<!--tex4ht:ref: eq:vEndTm1 --></a>), for every value of <img 
src="SolvingMicroDSOPs142x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle"> the program
must calculate the utility consequences of various possible choices of <img 
src="SolvingMicroDSOPs143x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> as it searches for
the best choice.
<!--l. 536--><p class="indent" >  For any given value of <img 
src="SolvingMicroDSOPs144x.svg" alt="a
 T‚àí1   " class="math";align="absmiddle">, notice that there is a good chance that the program may end
up calculating the corresponding <img 
src="SolvingMicroDSOPs145x.svg" alt="v+t  " class="math";align="absmiddle"> many times while maximizing utility from diÔ¨Äerent
<img 
src="SolvingMicroDSOPs146x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">‚Äôs. For example, it is possible that the program will calculate the value of ending the
period with <img 
src="SolvingMicroDSOPs147x.svg" alt="aT ‚àí1 = 0  " class="math";align="absmiddle"> dozens of times. It would be much more eÔ¨Écient if the program
could make that calculation once and then merely recall the value when it is needed
again.
<!--l. 538--><p class="indent" >  This can be achieved using the same interpolation technique used above to construct
a direct numerical approximation to the value function: DeÔ¨Åne a grid of possible
values for saving at time <img 
src="SolvingMicroDSOPs148x.svg" alt="T ‚àí  1  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs149x.svg" alt="‚ÉóaT‚àí1   " class="math";align="absmiddle"> (<span 
class="ectt-1200">aVec </span>in the code), designating the speciÔ¨Åc
points <img 
src="SolvingMicroDSOPs150x.svg" alt="aT‚àí 1,i  " class="math";align="absmiddle">; for each of these values of <img 
src="SolvingMicroDSOPs151x.svg" alt="aT ‚àí1,i  " class="math";align="absmiddle">, calculate the vector <img 
src="SolvingMicroDSOPs152x.svg" alt="‚ÉóvT+‚àí 1   " class="math";align="absmiddle"> as the
collection of points <img 
src="SolvingMicroDSOPs153x.svg" alt="v +    = v  +  (a    )
 T ‚àí1,i   T  ‚àí1  T‚àí1,i  " class="math";align="absmiddle"> using equation (<a 
href="#x1-4009r18">18<!--tex4ht:ref: eq:vEndtdefn --></a>); then construct an
<span 
class="ectt-1200">InterpolatingUnivariateSpline </span>object <img 
src="SolvingMicroDSOPs154x.svg" alt="`vT+‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> by passing the lists <span 
class="ectt-1200">aVec </span>and
<span 
class="ectt-1200">gothicvVec </span>as arguments. These lists contain the points of the <img 
src="SolvingMicroDSOPs155x.svg" alt="‚ÉóaT‚àí1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs156x.svg" alt="‚ÉóvT+‚àí 1   " class="math";align="absmiddle"> vectors,
respectively.
<!--l. 552--><p class="indent" >  As seen in the section ‚ÄúInterpolating Expectations‚Äù, we are now interpolating for the
function that reveals the expected value of <span 
class="ecti-1200">ending </span>the period with a given amount of
assets.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs10.html#fn9x0"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-11001f9"></a>  
The problem is solved in the same block withthe remaining following lines of code. Figure¬†<a 
href="#x1-110024">4<!--tex4ht:ref: fig:PlotOTm1RawVSInt --></a>
compares the true value function to the approximation produced following the interpolation
procedure; the functions are of course identical at the gridpoints chosen for <img 
src="SolvingMicroDSOPs157x.svg" alt="aT ‚àí1   " class="math";align="absmiddle"> and they
appear reasonably close except in the region below <img 
src="SolvingMicroDSOPs158x.svg" alt="m     = 1
  T‚àí1  " class="math";align="absmiddle">.
<!--l. 564--><p class="indent" >  <a 
 id="PlotOTm1RawVSInt"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-110024"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotOTm1RawVSInt.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†4:</span><span  
class="content">End-Of-Period Value <img 
src="SolvingMicroDSOPs159x.svg" alt="vT+‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs160x.svg" alt="`vT+‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-110024 -->
                                                                                     
                                                                                     
  </div>
<!--l. 571--><p class="indent" >  <a 
 id="PlotComparecTm1AB"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-110035"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotComparecTm1AB.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†5:</span><span  
class="content"><img 
src="SolvingMicroDSOPs161x.svg" alt="cT ‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs162x.svg" alt="`cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-110035 -->
                                                                                     
                                                                                     
  </div>
<!--l. 578--><p class="indent" >  Nevertheless, the resulting consumption rule obtained when <img 
src="SolvingMicroDSOPs163x.svg" alt="v`T +‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> is used instead of
<img 
src="SolvingMicroDSOPs164x.svg" alt="vT +‚àí1(aT‚àí1)  " class="math";align="absmiddle"> is surprisingly bad, as shown in Ô¨Ågure <a 
href="#x1-110035">5<!--tex4ht:ref: fig:PlotComparecTm1AB --></a>. For example, when <img 
src="SolvingMicroDSOPs165x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> goes
from 2 to 3, <img 
src="SolvingMicroDSOPs166x.svg" alt="`c
 T‚àí1   " class="math";align="absmiddle"> goes from about 1 to about 2, yet when <img 
src="SolvingMicroDSOPs167x.svg" alt="m
  T ‚àí1   " class="math";align="absmiddle"> goes from 3 to
4, <img 
src="SolvingMicroDSOPs168x.svg" alt="`cT‚àí1   " class="math";align="absmiddle"> goes from about 2 to about 2.05. The function fails even to be strictly
concave, which is distressing because Carroll and Kimball¬†(<span 
class="ecbx-1200">?</span>) prove that the correct
consumption function is strictly concave in a wide class of problems that includes this
problem.
<!--l. 591--><p class="indent" >  <a 
 id="Value-Function-versus-First-Order-Condition"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.5  </span> <a 
 id="x1-120005.5"></a>Value Function versus First Order Condition</h4>
<!--l. 594--><p class="noindent" >Loosely speaking, our diÔ¨Éculty reÔ¨Çects the fact that the consumption choice is governed by
the <span 
class="ecti-1200">marginal </span>value function, not by the <span 
class="ecti-1200">level </span>of the value function (which is the object that we
approximated). To understand this point, recall that a quadratic utility function exhibits risk
aversion because with a stochastic <img 
src="SolvingMicroDSOPs169x.svg" alt="c  " class="math";align="absmiddle">,
  <table 
class="equation"><tr><td><a 
 id="x1-12001r25"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs170x.svg" alt="ùîº [‚àí (c ‚àí /c)2] &#x003C; ‚àí (ùîº[c] ‚àí /c)2
" class="math-display" ></div>
  </td><td class="equation-label">(25)</td></tr></table>
<!--l. 606--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs171x.svg" alt="/c  " class="math";align="absmiddle"> is the ‚Äòbliss point‚Äô. However, unlike the CRRA utility function, with quadratic utility
the consumption/saving <span 
class="ecti-1200">behavior </span>of consumers is unaÔ¨Äected by risk since behavior is
determined by the Ô¨Årst order condition, which depends on <span 
class="ecti-1200">marginal </span>utility, and when utility is
quadratic, marginal utility is unaÔ¨Äected by risk:
  <table 
class="equation"><tr><td><a 
 id="x1-12002r26"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs172x.svg" alt="ùîº[‚àí 2(c ‚àí /c)] = ‚àí 2(ùîº[c] ‚àí /c).
" class="math-display" ></div>
  </td><td class="equation-label">(26)</td></tr></table>
<!--l. 614--><p class="nopar" >
<!--l. 616--><p class="indent" >  Intuitively, if one‚Äôs goal is to accurately capture choices that are governed by marginal
value, numerical techniques that approximate the <span 
class="ecti-1200">marginal </span>value function will yield a more
accurate approximation to optimal behavior than techniques that approximate the <span 
class="ecti-1200">level </span>of the
value function.
<!--l. 623--><p class="indent" >  The Ô¨Årst order condition of the maximization problem in period <img 
src="SolvingMicroDSOPs173x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> is:
  <table 
class="equation"><tr><td><a 
 id="x1-12003r27"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs174x.svg" alt="uc(cT‚àí1) = Œ≤ ùîºT‚àí 1[ùí¢ ‚àíTœÅRuc(cT)]
              (   )  nùúÉùúÉùúÉ
     ‚àíœÅ         -1-  ‚àë    ‚àíœÅ                      ‚àíœÅ
    cT‚àí1 = RŒ≤   nùúÉùúÉùúÉ      ùí¢ T (R (mT  ‚àí1 ‚àí cT‚àí1) + ùúÉùúÉùúÉi)  .
                     i=1
" class="math-display" ></div>
  </td><td class="equation-label">(27)</td></tr></table>
<!--l. 4--><p class="nopar" >
<a 
 id="PlotuPrimeVSOPrime"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-120046"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotuPrimeVSOPrime.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†6:</span><span  
class="content"><img 
src="SolvingMicroDSOPs175x.svg" alt="uc (c)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs176x.svg" alt="vaT +‚àí1(3 ‚àí c),vaT+‚àí1(4 ‚àí c),`vaT+‚àí 1(3 ‚àí c),`vaT+ ‚àí1(4 ‚àí c)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-120046 -->
                                                                                     
                                                                                     
  </div>
<!--l. 639--><p class="indent" >  In the notebook, ‚ÄúValue Function versus the First Order Condition‚Äù completes the task of
Ô¨Ånding the values of consumption which satisfy the Ô¨Årst order condition in (<a 
href="#x1-12003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>) using
the <span 
class="ectt-1200">brentq </span>function from the <span 
class="ectt-1200">scipy </span>module. Notice that the use of <span 
class="ectt-1200">u.prime </span>and
<span 
class="ectt-1200">gothic.VP_Tminus1 </span>is possible since they are already deÔ¨Åned in the <span 
class="ectt-1200">resources </span>and
<span 
class="ectt-1200">gothic_class </span>modules.
<!--l. 645--><p class="indent" >  The downward-sloping curve in Figure <a 
href="#x1-120046">6<!--tex4ht:ref: fig:PlotuPrimeVSOPrime --></a> shows the value of <img 
src="SolvingMicroDSOPs177x.svg" alt="c‚àíTœÅ‚àí1   " class="math";align="absmiddle"> for our baseline
parameter values for <img 
src="SolvingMicroDSOPs178x.svg" alt="0 ‚â§ cT‚àí 1 ‚â§ 4  " class="math";align="absmiddle"> (the horizontal axis). The solid upward-sloping curve
shows the value of the RHS of (<a 
href="#x1-12003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>) as a function of <img 
src="SolvingMicroDSOPs179x.svg" alt="cT ‚àí1   " class="math";align="absmiddle"> under the assumption that
<img 
src="SolvingMicroDSOPs180x.svg" alt="mT ‚àí 1 = 3  " class="math";align="absmiddle">. Constructing this Ô¨Ågure is rather time-consuming, because for every value of
<img 
src="SolvingMicroDSOPs181x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> plotted we must calculate the RHS of (<a 
href="#x1-12003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>). The value of <img 
src="SolvingMicroDSOPs182x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> for which the RHS and
LHS of (<a 
href="#x1-12003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>) are equal is the optimal level of consumption given that <img 
src="SolvingMicroDSOPs183x.svg" alt="mT ‚àí1 = 3  " class="math";align="absmiddle">, so the
intersection of the downward-sloping and the upward-sloping curves gives the optimal value of
<img 
src="SolvingMicroDSOPs184x.svg" alt="cT‚àí 1   " class="math";align="absmiddle">. As we can see, the two curves intersect just below <img 
src="SolvingMicroDSOPs185x.svg" alt="cT ‚àí1 = 2  " class="math";align="absmiddle">. Similarly, the
upward-sloping dashed curve shows the expected value of the RHS of (<a 
href="#x1-12003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>) under the
assumption that <img 
src="SolvingMicroDSOPs186x.svg" alt="mT ‚àí1 = 4  " class="math";align="absmiddle">, and the intersection of this curve with <img 
src="SolvingMicroDSOPs187x.svg" alt="uc(cT‚àí 1)  " class="math";align="absmiddle"> yields the
optimal level of consumption if <img 
src="SolvingMicroDSOPs188x.svg" alt="mT  ‚àí1 = 4  " class="math";align="absmiddle">. These two curves intersect slightly below
<img 
src="SolvingMicroDSOPs189x.svg" alt="c    =  2.5
 T‚àí 1  " class="math";align="absmiddle">. Thus, increasing <img 
src="SolvingMicroDSOPs190x.svg" alt="m
  T‚àí1   " class="math";align="absmiddle"> from 3 to 4 increases optimal consumption by about
0.5.
<!--l. 666--><p class="indent" >  Now consider the derivative of our function <img 
src="SolvingMicroDSOPs191x.svg" alt="`vT+‚àí1(aT‚àí 1)  " class="math";align="absmiddle">. Because we have constructed
<img 
src="SolvingMicroDSOPs192x.svg" alt="`vT +‚àí1   " class="math";align="absmiddle"> as a linear interpolation, the slope of <img 
src="SolvingMicroDSOPs193x.svg" alt="`vT+‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> between any two adjacent points
<img 
src="SolvingMicroDSOPs194x.svg" alt="{aT ‚àí1,i,ai+1,T‚àí 1} " class="math";align="absmiddle"> is constant. The level of the slope immediately below any particular
gridpoint is diÔ¨Äerent, of course, from the slope above that gridpoint, a fact which implies that
the derivative of <img 
src="SolvingMicroDSOPs195x.svg" alt="`vT+‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> follows a step function.
<!--l. 676--><p class="indent" >  The solid-line step function in Figure <a 
href="#x1-120046">6<!--tex4ht:ref: fig:PlotuPrimeVSOPrime --></a> depicts the actual value of <img 
src="SolvingMicroDSOPs196x.svg" alt=" a
`vT+‚àí1(3 ‚àí cT‚àí1)  " class="math";align="absmiddle">. When
we attempt to Ô¨Ånd optimal values of <img 
src="SolvingMicroDSOPs197x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> given <img 
src="SolvingMicroDSOPs198x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> using <img 
src="SolvingMicroDSOPs199x.svg" alt="`vT +‚àí1(aT‚àí1)  " class="math";align="absmiddle">, the numerical
optimization routine will return the <img 
src="SolvingMicroDSOPs200x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> for which <img 
src="SolvingMicroDSOPs201x.svg" alt="uc(cT‚àí1) = `va+   (mT ‚àí1 ‚àí cT‚àí1)
            T  ‚àí1  " class="math";align="absmiddle">. Thus,
for <img 
src="SolvingMicroDSOPs202x.svg" alt="m     = 3
  T‚àí1  " class="math";align="absmiddle"> the program will return the value of <img 
src="SolvingMicroDSOPs203x.svg" alt="c
 T‚àí 1   " class="math";align="absmiddle"> for which the downward-sloping
<img 
src="SolvingMicroDSOPs204x.svg" alt=" c
u (cT‚àí 1)  " class="math";align="absmiddle"> curve intersects with the <img 
src="SolvingMicroDSOPs205x.svg" alt="  a
`v T+‚àí1(3 ‚àí cT‚àí1)  " class="math";align="absmiddle">; as the diagram shows, this value is
exactly equal to 2. Similarly, if we ask the routine to Ô¨Ånd the optimal <img 
src="SolvingMicroDSOPs206x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs207x.svg" alt="mT  ‚àí1 = 4  " class="math";align="absmiddle">, it
Ô¨Ånds the point of intersection of <img 
src="SolvingMicroDSOPs208x.svg" alt="uc(cT‚àí1)  " class="math";align="absmiddle"> with <img 
src="SolvingMicroDSOPs209x.svg" alt="`vaT+‚àí1(4 ‚àí cT‚àí1)  " class="math";align="absmiddle">; and as the diagram shows,
this intersection is only slightly above 2. Hence, this Ô¨Ågure illustrates why the numerical
consumption function plotted earlier returned values very close to <img 
src="SolvingMicroDSOPs210x.svg" alt="cT‚àí1 = 2  " class="math";align="absmiddle"> for both
<img 
src="SolvingMicroDSOPs211x.svg" alt="mT ‚àí 1 = 3  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs212x.svg" alt="mT ‚àí 1 = 4  " class="math";align="absmiddle">.
<!--l. 695--><p class="indent" >  We would obviously obtain much better estimates of the point of intersection
between <img 
src="SolvingMicroDSOPs213x.svg" alt="uc(cT‚àí1)  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs214x.svg" alt="vaT+‚àí1(mT ‚àí 1 ‚àí cT‚àí 1)  " class="math";align="absmiddle"> if our estimate of <img 
src="SolvingMicroDSOPs215x.svg" alt="`vaT+‚àí1   " class="math";align="absmiddle"> were not a
step function. In fact, we already know how to construct linear interpolations to
functions, so the obvious next step is to construct a linear interpolating approximation
to the <span 
class="ecti-1200">expected marginal value of end-of-period assets function</span> <img 
src="SolvingMicroDSOPs216x.svg" alt="  ‚Ä≤
v +t  " class="math";align="absmiddle">. That is, we
calculate
  <table 
class="equation"><tr><td><a 
 id="x1-12005r28"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs217x.svg" alt="                     (    ) ‚àënùúÉùúÉùúÉ
vaT+‚àí1(aT‚àí 1) = Œ≤R ùí¢ ‚àíœÅ -1-      (‚ÑõT  aT‚àí1 + ùúÉùúÉùúÉi)‚àí œÅ
                   T   n ùúÉùúÉùúÉ  i=1
" class="math-display" ></div>
  </td><td class="equation-label">(28)</td></tr></table>
<!--l. 705--><p class="nopar" >
at the points in <span 
class="ectt-1200">aVec </span>yielding <img 
src="SolvingMicroDSOPs218x.svg" alt="{{aT ‚àí1,1,va+    },{aT ‚àí1,2,va+    } ...}
          T  ‚àí1,1           T  ‚àí1,2 " class="math";align="absmiddle"> and construct
<img 
src="SolvingMicroDSOPs219x.svg" alt="`va    (a   )
 T +‚àí1  T‚àí1  " class="math";align="absmiddle"> as the linear interpolating function that Ô¨Åts this set of points.
<!--l. 712--><p class="indent" >  <a 
 id="PlotOPRawVSFOC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-120067"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotOPRawVSFOC.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†7:</span><span  
class="content"><img 
src="SolvingMicroDSOPs220x.svg" alt="vaT+‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs221x.svg" alt="`vaT+‚àí1(aT‚àí 1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-120067 -->
                                                                                     
                                                                                     
  </div>
<!--l. 720--><p class="indent" >  This is done by making a call to the <span 
class="ectt-1200">InterpolatedUnivariateSpline </span>function, passing it
<span 
class="ectt-1200">aVec </span>and <span 
class="ectt-1200">vpVec </span>as arguments. Note that in deÔ¨Åning the list of values <span 
class="ectt-1200">vpVec</span>, we again makes
use of the predeÔ¨Åned <span 
class="ectt-1200">gothic.VP_Tminus1 </span>function. These steps are the embodiment of
equation¬†(<a 
href="#x1-12005r28">28<!--tex4ht:ref: eq:vEndPrimeTm1 --></a>), and construct the interpolation of the expected marginal value of end-of-period
assets as described above.
<!--l. 725--><p class="indent" >  The results are shown in Figure <a 
href="#x1-120067">7<!--tex4ht:ref: fig:PlotOPRawVSFOC --></a>. The linear interpolating approximation looks roughly as
good (or bad) for the <span 
class="ecti-1200">marginal </span>value function as it was for the level of the value function.
However, Figure <a 
href="#x1-120078">8<!--tex4ht:ref: fig:PlotcTm1ABC --></a> shows that the new consumption function (long dashes) is a
considerably better approximation of the true consumption function (solid) than was the
consumption function obtained by approximating the level of the value function (short
dashes).
<!--l. 735--><p class="indent" >  <a 
 id="PlotcTm1ABC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-120078"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotcTm1ABC.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†8:</span><span  
class="content"><img 
src="SolvingMicroDSOPs222x.svg" alt="cT ‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (solid) Versus Two Methods for Constructing <img 
src="SolvingMicroDSOPs223x.svg" alt="`cT‚àí1(mT ‚àí 1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-120078 -->
                                                                                     
                                                                                     
  </div>
<!--l. 742--><p class="indent" >  <a 
 id="Transformation"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.6  </span> <a 
 id="x1-130005.6"></a>Transformation</h4>
<!--l. 745--><p class="noindent" >Even the new-and-improved consumption function diverges notably from the true solution,
especially at lower values of <img 
src="SolvingMicroDSOPs224x.svg" alt="m  " class="math";align="absmiddle">. That is because the linear interpolation does an increasingly
poor job of capturing the nonlinearity of <img 
src="SolvingMicroDSOPs225x.svg" alt=" a
vT+‚àí 1(aT ‚àí1)  " class="math";align="absmiddle"> at lower and lower levels of
<img 
src="SolvingMicroDSOPs226x.svg" alt="a  " class="math";align="absmiddle">.
<!--l. 751--><p class="indent" >  This is where we unveil our next trick. To understand the logic, start by considering the
case where <img 
src="SolvingMicroDSOPs227x.svg" alt="‚Ñõ   =  Œ≤ = ùí¢  =  1
  T         T  " class="math";align="absmiddle"> and there is no uncertainty  (that is, we know for sure that
income next period will be <img 
src="SolvingMicroDSOPs228x.svg" alt="ùúÉùúÉùúÉT = 1  " class="math";align="absmiddle">). The Ô¨Ånal Euler equation is then:
  <table 
class="equation"><tr><td><a 
 id="x1-13001r29"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs229x.svg" alt="c‚àíœÅ  = c‚àí œÅ.
 T‚àí1    T
" class="math-display" ></div>
  </td><td class="equation-label">(29)</td></tr></table>
<!--l. 759--><p class="nopar" >
<!--l. 761--><p class="indent" >  In the case we are now considering with no uncertainty and no liquidity constraints, the
optimizing consumer does not care whether a unit of income is scheduled to be received in the
future period <img 
src="SolvingMicroDSOPs230x.svg" alt="T  " class="math";align="absmiddle"> or the current period <img 
src="SolvingMicroDSOPs231x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">; there is perfect certainty that the income will
be received, so the consumer treats it as equivalent to a unit of current wealth. Total resources
therefore are comprised of two types: current market resources <img 
src="SolvingMicroDSOPs232x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> and ‚Äòhuman wealth‚Äô
(the PDV of future income) of <img 
src="SolvingMicroDSOPs233x.svg" alt="ùî•T‚àí1 = 1  " class="math";align="absmiddle"> (where we use the Gothic font to signify that this is
the expectation, as of the END of the period, of the income that will be received in future
periods; it does not include current income, which has already been incorporated into
<img 
src="SolvingMicroDSOPs234x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">).
<!--l. 774--><p class="indent" >  The optimal solution is to spend half of total lifetime resources in period <img 
src="SolvingMicroDSOPs235x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">
and the remainder in period <img 
src="SolvingMicroDSOPs236x.svg" alt="T  " class="math";align="absmiddle">. Since total resources are known with certainty
to be <img 
src="SolvingMicroDSOPs237x.svg" alt="mT ‚àí 1 + ùî•T ‚àí1 = mT ‚àí1 + 1  " class="math";align="absmiddle">, and since <img 
src="SolvingMicroDSOPs238x.svg" alt=" m              c
vT‚àí1(mT ‚àí1) = u (cT‚àí 1)  " class="math";align="absmiddle"> this implies
that
  <table 
class="equation"><tr><td><a 
 id="x1-13002r30"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs239x.svg" alt="               ( m    +  1) ‚àíœÅ
vmT ‚àí1(mT ‚àí1) =   --T‚àí1-----   .
                     2
" class="math-display" ></div>
  </td><td class="equation-label">(30)</td></tr></table>
<!--l. 785--><p class="nopar" >
Of course, this is a highly nonlinear function. However, if we raise both sides of (<a 
href="#x1-13002r30">30<!--tex4ht:ref: eq:vPLin --></a>) to the
power <img 
src="SolvingMicroDSOPs240x.svg" alt="(‚àí 1 ‚àïœÅ)  " class="math";align="absmiddle"> the result is a linear function:
  <table 
class="equation"><tr><td><a 
 id="x1-13003r31"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs241x.svg" alt="[vmT ‚àí1(mT ‚àí1)]‚àí 1‚àïœÅ =  mT-‚àí1 +-1.
                        2
" class="math-display" ></div>
  </td><td class="equation-label">(31)</td></tr></table>
<!--l. 791--><p class="nopar" >
This is a speciÔ¨Åc example of a general phenomenon: A theoretical literature cited in¬†<span 
class="ecbx-1200">?</span>
establishes that under perfect certainty, if the period-by-period marginal utility function is of
the form <img 
src="SolvingMicroDSOPs242x.svg" alt="c‚àí œÅ
 t  " class="math";align="absmiddle">, the marginal value function will be of the form <img 
src="SolvingMicroDSOPs243x.svg" alt="(Œ≥m  +  Œ∂)‚àíœÅ
    t  " class="math";align="absmiddle"> for some
constants <img 
src="SolvingMicroDSOPs244x.svg" alt="{Œ≥, Œ∂} " class="math";align="absmiddle">. This means that if we were solving the perfect foresight problem
numerically, we could always calculate a numerically exact (because linear) interpolation. To
put this in intuitive terms, the problem we are facing is that the marginal value function is
highly nonlinear. But we have a compelling solution to that problem, because the
nonlinearity springs largely from the fact that we are raising something to the power
<img 
src="SolvingMicroDSOPs245x.svg" alt="‚àí œÅ  " class="math";align="absmiddle">. In eÔ¨Äect, we can ‚Äòunwind‚Äô all of the nonlinearity owing to that operation
and the remaining nonlinearity will not be nearly so great. SpeciÔ¨Åcally, applying
the foregoing insights to the end-of-period value function <img 
src="SolvingMicroDSOPs246x.svg" alt="vaT +‚àí1(aT‚àí1)  " class="math";align="absmiddle">, we can
deÔ¨Åne
  <table 
class="equation"><tr><td><a 
 id="x1-13004r32"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs247x.svg" alt="               ( a          )‚àí1‚àïœÅ
cT+ ‚àí1(aT‚àí1) ‚â°  vT+ ‚àí1(aT‚àí1)
" class="math-display" ></div>
  </td><td class="equation-label">(32)</td></tr></table>
<!--l. 809--><p class="nopar" >
which would be linear in the perfect foresight case. Thus, our procedure is to calculate the
values of <img 
src="SolvingMicroDSOPs248x.svg" alt="cT +‚àí1,i  " class="math";align="absmiddle"> at each of the <img 
src="SolvingMicroDSOPs249x.svg" alt="aT ‚àí1,i  " class="math";align="absmiddle"> gridpoints, with the idea that we will construct
<img 
src="SolvingMicroDSOPs250x.svg" alt="`cT+ ‚àí1   " class="math";align="absmiddle"> as the interpolating function connecting these points.
<!--l. 818--><p class="indent" >  <a 
 id="The-Natural-Borrowing-Constraint-and-the-a-Lower-Bound"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.7  </span> <a 
 id="x1-140005.7"></a>The ‚ÄòNatural‚Äô Borrowing Constraint and the <img 
src="SolvingMicroDSOPs251x.svg" alt="aT‚àí1   " class="math";align="absmiddle"> Lower Bound</h4>
<!--l. 822--><p class="noindent" >This is the appropriate moment to ask an awkward question we have so far neglected: How
should a function like <img 
src="SolvingMicroDSOPs252x.svg" alt="`cT+ ‚àí1   " class="math";align="absmiddle"> be evaluated outside the range of points spanned by
<img 
src="SolvingMicroDSOPs253x.svg" alt="{aT ‚àí1,1,...,aT‚àí 1,n} " class="math";align="absmiddle"> for which we have calculated the corresponding <img 
src="SolvingMicroDSOPs254x.svg" alt="cT +‚àí1,i  " class="math";align="absmiddle"> gridpoints
used to produce our linearly interpolating approximation <img 
src="SolvingMicroDSOPs255x.svg" alt="`cT+‚àí 1   " class="math";align="absmiddle"> (as described in
section¬†<a 
href="#x1-100005.3">5.3<!--tex4ht:ref: subsec:LinInterp --></a>)?
<!--l. 829--><p class="indent" >  The natural answer would seem to be linear extrapolation; for example, we could
use
  <table 
class="equation"><tr><td><a 
 id="x1-14001r33"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs256x.svg" alt="   +             +              a
`cT  ‚àí1(aT‚àí1) = `cT  ‚àí1(aT‚àí1,1) + `cT+‚àí 1(aT ‚àí1,1)(aT‚àí1 ‚àí aT‚àí 1,1)
" class="math-display" ></div>
  </td><td class="equation-label">(33)</td></tr></table>
<!--l. 832--><p class="nopar" >
for values of <img 
src="SolvingMicroDSOPs257x.svg" alt="a    &#x003C;  a
 T‚àí 1    T‚àí1,1   " class="math";align="absmiddle">, where <img 
src="SolvingMicroDSOPs258x.svg" alt="`ca   (a     )
 T+‚àí1  T‚àí 1,1  " class="math";align="absmiddle"> is the derivative of the <img 
src="SolvingMicroDSOPs259x.svg" alt="`c +
 T ‚àí 1   " class="math";align="absmiddle">
function at the bottommost gridpoint (see below). Unfortunately, this approach
will lead us into diÔ¨Éculties. To see why, consider what happens to the true (not
approximated) <img 
src="SolvingMicroDSOPs260x.svg" alt="vaT +‚àí1(aT‚àí1)  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs261x.svg" alt="aT‚àí 1   " class="math";align="absmiddle"> approaches the value <img 
src="SolvingMicroDSOPs262x.svg" alt="aT‚àí1 = ‚àí ùúÉùúÉùúÉ‚Ñõ ‚àíT1  " class="math";align="absmiddle">. From (<a 
href="#x1-12005r28">28<!--tex4ht:ref: eq:vEndPrimeTm1 --></a>) we
have
                                                                                     
                                                                                     
  <table 
class="equation"><tr><td><a 
 id="x1-14002r34"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs263x.svg" alt="                                     ‚àíœÅ ( 1 ) ‚àënùúÉùúÉùúÉ               ‚àíœÅ
   lim    vaT+ ‚àí1(aT‚àí1) =    lim    Œ≤R ùí¢T    ---     (aT‚àí1‚ÑõT  + ùúÉùúÉùúÉi)  .
aT‚àí1‚ÜìaT‚àí1               aT‚àí1‚ÜìaT‚àí 1         nùúÉùúÉùúÉ  i=1
" class="math-display" ></div>
  </td><td class="equation-label">(34)</td></tr></table>
<!--l. 842--><p class="nopar" >
<!--l. 845--><p class="indent" >  But since <img 
src="SolvingMicroDSOPs264x.svg" alt="ùúÉùúÉùúÉ-= ùúÉùúÉùúÉ1   " class="math";align="absmiddle">, exactly at <img 
src="SolvingMicroDSOPs265x.svg" alt="aT‚àí1 = aT ‚àí1   " class="math";align="absmiddle"> the Ô¨Årst term in the summation would be
<img 
src="SolvingMicroDSOPs266x.svg" alt="(‚àí ùúÉùúÉùúÉ + ùúÉùúÉùúÉ )‚àíœÅ = 1‚àï0œÅ
   --   1  " class="math";align="absmiddle"> which is inÔ¨Ånity. The reason is simple: <img 
src="SolvingMicroDSOPs267x.svg" alt="‚àí a
  -T ‚àí1   " class="math";align="absmiddle"> is the PDV, as of
<img 
src="SolvingMicroDSOPs268x.svg" alt="T ‚àí  1  " class="math";align="absmiddle">, of the minimum possible realization of income in period <img 
src="SolvingMicroDSOPs269x.svg" alt="T  " class="math";align="absmiddle"> (<img 
src="SolvingMicroDSOPs270x.svg" alt="‚ÑõT  aT‚àí1 = ‚àí ùúÉùúÉùúÉ1   " class="math";align="absmiddle">). Thus,
if the consumer borrows an amount greater than or equal to <img 
src="SolvingMicroDSOPs271x.svg" alt="   ‚àí1
ùúÉùúÉùúÉ‚Ñõ T  " class="math";align="absmiddle"> (that is, if the consumer
ends <img 
src="SolvingMicroDSOPs272x.svg" alt="T ‚àí  1  " class="math";align="absmiddle"> with <img 
src="SolvingMicroDSOPs273x.svg" alt="aT‚àí 1 ‚â§ ‚àí ùúÉùúÉùúÉ-‚Ñõ‚àíT 1  " class="math";align="absmiddle">) and then draws the worst possible income shock in period
<img 
src="SolvingMicroDSOPs274x.svg" alt="T  " class="math";align="absmiddle">, they will have to consume zero in period <img 
src="SolvingMicroDSOPs275x.svg" alt="T  " class="math";align="absmiddle"> (or a negative amount), which
yields <img 
src="SolvingMicroDSOPs276x.svg" alt="‚àí ‚àû " class="math";align="absmiddle"> utility and <img 
src="SolvingMicroDSOPs277x.svg" alt="‚àû " class="math";align="absmiddle"> marginal utility (or undeÔ¨Åned utility and marginal
utility).
<!--l. 859--><p class="indent" >  These reÔ¨Çections lead us to the conclusion that the consumer faces a ‚Äòself-imposed‚Äô liquidity
constraint (which results from the precautionary motive): They will never borrow an amount
greater than or equal to <img 
src="SolvingMicroDSOPs278x.svg" alt="ùúÉùúÉùúÉ‚Ñõ ‚àí1
    T  " class="math";align="absmiddle"> (that is, assets will never reach the lower bound of
<img 
src="SolvingMicroDSOPs279x.svg" alt="a
-T ‚àí1 " class="math";align="absmiddle">).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs11.html#fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-14003f10"></a>  
The constraint is ‚Äòself-imposed‚Äô in the sense that if the utility function were diÔ¨Äerent (say,
Constant Absolute Risk Aversion), the consumer would be willing to borrow more than <img 
src="SolvingMicroDSOPs280x.svg" alt="   ‚àí1
ùúÉùúÉùúÉ‚Ñõ T  " class="math";align="absmiddle">
because a choice of zero or negative consumption in period <img 
src="SolvingMicroDSOPs281x.svg" alt="T  " class="math";align="absmiddle"> would yield some Ô¨Ånite amount
of utility.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs12.html#fn11x0"><sup class="textsuperscript">11</sup></a></span><a 
 id="x1-14004f11"></a>  
<!--l. 876--><p class="indent" >  This self-imposed constraint cannot be captured well when the <img 
src="SolvingMicroDSOPs282x.svg" alt="va
 T+‚àí 1   " class="math";align="absmiddle"> function is
approximated by a piecewise linear function like <img 
src="SolvingMicroDSOPs283x.svg" alt=" m
`vT+‚àí 1   " class="math";align="absmiddle">, because a linear approximation can
never reach the correct gridpoint for <img 
src="SolvingMicroDSOPs284x.svg" alt="  a
v T+‚àí1(aT‚àí 1) = ‚àû.  " class="math";align="absmiddle"> To see what will happen instead,
note Ô¨Årst that if we are approximating <img 
src="SolvingMicroDSOPs285x.svg" alt="vaT+‚àí1   " class="math";align="absmiddle"> the smallest value in <span 
class="ectt-1200">aVec </span>must be greater than
<img 
src="SolvingMicroDSOPs286x.svg" alt="a-
 T ‚àí1 " class="math";align="absmiddle"> (because the expectation for any gridpoint <img 
src="SolvingMicroDSOPs287x.svg" alt="‚â§ a-
    T‚àí1   " class="math";align="absmiddle"> is undeÔ¨Åned). Then when the
approximating <img 
src="SolvingMicroDSOPs288x.svg" alt="va
 T+ ‚àí1   " class="math";align="absmiddle"> function is evaluated at some value less than the Ô¨Årst element in <span 
class="ectt-1200">aVec</span>,
                                                                                     
                                                                                     
the approximating function will linearly extrapolate the slope that characterized the lowest
segment of the piecewise linear approximation (between <span 
class="ectt-1200">aVec[0] </span>and <span 
class="ectt-1200">aVec[1]</span>), a procedure
that will return a positive Ô¨Ånite number, even if the requested <img 
src="SolvingMicroDSOPs289x.svg" alt="aT‚àí 1   " class="math";align="absmiddle"> point is below
<img 
src="SolvingMicroDSOPs290x.svg" alt="a
-T ‚àí1 " class="math";align="absmiddle">. This means that the precautionary saving motive is understated, and by an
arbitrarily large amount as the level of assets approaches its true theoretical minimum
<img 
src="SolvingMicroDSOPs291x.svg" alt="aT ‚àí1 " class="math";align="absmiddle">.
<!--l. 895--><p class="indent" >  The foregoing logic demonstrates that the marginal value of saving approaches inÔ¨Ånity as
<img 
src="SolvingMicroDSOPs292x.svg" alt="aT ‚àí1 ‚Üì a   =  ‚àí ùúÉùúÉùúÉ-‚Ñõ ‚àí1
        T ‚àí1        T  " class="math";align="absmiddle">. But this implies that <img 
src="SolvingMicroDSOPs293x.svg" alt="lima    ‚Üìa   cT+‚àí1(aT‚àí 1) = (va +  (aT‚àí 1))‚àí1‚àïœÅ = 0
    T‚àí1 T‚àí 1                 T ‚àí1  " class="math";align="absmiddle">;
that is, as <img 
src="SolvingMicroDSOPs294x.svg" alt="a  " class="math";align="absmiddle"> approaches its minimum possible value, the corresponding amount of <img 
src="SolvingMicroDSOPs295x.svg" alt="c  " class="math";align="absmiddle"> must
approach <span 
class="ecti-1200">its </span>minimum possible value: zero.
<!--l. 902--><p class="indent" >  The upshot of this discussion is a realization that all we need to do is to augment each of
the <img 
src="SolvingMicroDSOPs296x.svg" alt="‚ÉóaT‚àí 1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs297x.svg" alt="‚ÉócT‚àí 1   " class="math";align="absmiddle"> vectors with an extra point so that the Ô¨Årst element in the list
used to produce our interpolation function is <img 
src="SolvingMicroDSOPs298x.svg" alt="{aT ‚àí1,0,cT‚àí1,0} = {a-  ,0.}
                    T‚àí1 " class="math";align="absmiddle">. This is
done in section ‚ÄúThe Self-Imposed ‚ÄòNatural‚Äô Borrowing Constraint and the <img 
src="SolvingMicroDSOPs299x.svg" alt="aT ‚àí1   " class="math";align="absmiddle">
Lower Bound‚Äù of the notebook, which can be seen in the deÔ¨Åned lists <span 
class="ectt-1200">aVecBot </span>and
<span 
class="ectt-1200">cVec3Bot</span>.
<!--l. 910--><p class="indent" >  <a 
 id="GothVInvVSGothC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-140059"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/GothVInvVSGothC.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†9:</span><span  
class="content"><img 
src="SolvingMicroDSOPs300x.svg" alt="cT +‚àí1(aT‚àí1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs301x.svg" alt="`cT+ ‚àí1(aT‚àí1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-140059 -->
                                                                                     
                                                                                     
  </div>
<!--l. 918--><p class="indent" >  From there, we plot the lists that have been appended with the natural borrowing contraint
and the associated minimal level of consumption. The subseqeunt Ô¨Ågure <a 
href="#x1-140059">9<!--tex4ht:ref: fig:GothVInvVSGothC --></a> shows the result of
this procedure. The solid line calculates the exact numerical value of <img 
src="SolvingMicroDSOPs302x.svg" alt="c +  (a    )
 T ‚àí1  T ‚àí1  " class="math";align="absmiddle"> while the
dashed line is the linear interpolating approximation <img 
src="SolvingMicroDSOPs303x.svg" alt="`cT+ ‚àí1(aT‚àí1).  " class="math";align="absmiddle"> This Ô¨Ågure illustrates the
value of the transformation: The true function is close to linear, and so the linear
approximation is almost indistinguishable from the true function except at the very lowest
values of <img 
src="SolvingMicroDSOPs304x.svg" alt="aT ‚àí1   " class="math";align="absmiddle">.
<!--l. 920--><p class="indent" >  Figure¬†<a 
href="#x1-1400610">10<!--tex4ht:ref: fig:GothVVSGothCInv --></a> similarly shows that when we generate <img 
src="SolvingMicroDSOPs305x.svg" alt="`‚Ä≤
`vT+‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs306x.svg" alt="   +         ‚àí œÅ
[`cT ‚àí 1(aT ‚àí1)]  " class="math";align="absmiddle">
(dashed line) we obtain a <span 
class="ecti-1200">much </span>closer approximation to the true function <img 
src="SolvingMicroDSOPs307x.svg" alt=" a
vT+‚àí1(aT ‚àí1)  " class="math";align="absmiddle"> (solid
line) than we did in the previous program which did not do the transformation (Figure¬†<a 
href="#x1-120067">7<!--tex4ht:ref: fig:PlotOPRawVSFOC --></a>).
The calculation of marginal value using the transformation is performed and the associated
Ô¨Ågure is produced.
<!--l. 929--><p class="indent" >  <a 
 id="GothVVSGothCInv"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1400610"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/GothVVSGothCInv.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†10:</span><span  
class="content"><img 
src="SolvingMicroDSOPs308x.svg" alt="vaT+‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> vs. <img 
src="SolvingMicroDSOPs309x.svg" alt="``v‚Ä≤T +‚àí1(aT‚àí1)  " class="math";align="absmiddle"> Constructed Using <img 
src="SolvingMicroDSOPs310x.svg" alt="`cT+ ‚àí1(aT‚àí1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-1400610 -->
                                                                                     
                                                                                     
  </div>
<!--l. 938--><p class="indent" >  <a 
 id="The-Method-of-Endogenous-Gridpoints"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.8  </span> <a 
 id="x1-150005.8"></a>The Method of Endogenous Gridpoints</h4>
<!--l. 941--><p class="noindent" >Our solution procedure for <img 
src="SolvingMicroDSOPs311x.svg" alt="c
 T‚àí1   " class="math";align="absmiddle"> still requires us, for each point in <img 
src="SolvingMicroDSOPs312x.svg" alt="‚Éóm
  T‚àí1   " class="math";align="absmiddle"> (<span 
class="ectt-1200">mVec </span>in the
code), to use a numerical rootÔ¨Ånding algorithm to search for the value of <img 
src="SolvingMicroDSOPs313x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> that
solves <img 
src="SolvingMicroDSOPs314x.svg" alt=" c          a
u (cT‚àí1) = vT+‚àí 1(mT ‚àí 1 ‚àí cT‚àí 1)  " class="math";align="absmiddle">. Unfortunately, rootÔ¨Ånding is a notoriously
computation-intensive (that is, slow!) operation.
<!--l. 948--><p class="indent" >  Our next trick lets us completely skip the rootÔ¨Ånding step. The method can be understood
by noting that any arbitrary value of <img 
src="SolvingMicroDSOPs315x.svg" alt="a
 T‚àí 1,i  " class="math";align="absmiddle"> (greater than its lower bound value <img 
src="SolvingMicroDSOPs316x.svg" alt="a
-T‚àí1   " class="math";align="absmiddle">) will
be associated with <span 
class="ecti-1200">some </span>marginal valuation as of the end of period <img 
src="SolvingMicroDSOPs317x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">, and the further
observation that it is trivial to Ô¨Ånd the value of <img 
src="SolvingMicroDSOPs318x.svg" alt="c  " class="math";align="absmiddle"> that yields the same marginal valuation,
using the Ô¨Årst order condition,
  <table 
class="equation"><tr><td><a 
 id="x1-15001r35"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs319x.svg" alt=" c           a
u (cT‚àí1,i) = vT +‚àí1(aT‚àí1,i)
    cT‚àí1,i = uc‚àí1(vaT +‚àí1(aT‚àí1,i))
              a            ‚àí1‚àïœÅ
          = (vT+ ‚àí1(aT‚àí1,i))
          ‚â° cT+ ‚àí1(aT‚àí1,i)
          ‚â° c +    .
             T  ‚àí1,i
" class="math-display" ></div>
  </td><td class="equation-label">(35)</td></tr></table>
<!--l. 962--><p class="nopar" >
<!--l. 964--><p class="indent" >  But with mutually consistent values of <img 
src="SolvingMicroDSOPs320x.svg" alt="cT ‚àí1,i  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs321x.svg" alt="aT ‚àí1,i  " class="math";align="absmiddle"> (consistent, in the
sense that they are the unique optimal values that correspond to the solution to the
problem in a single state), we can obtain the <img 
src="SolvingMicroDSOPs322x.svg" alt="mT ‚àí1,i  " class="math";align="absmiddle"> that corresponds to both of them
from
  <table 
class="equation"><tr><td><a 
 id="x1-15002r36"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs323x.svg" alt="mT ‚àí1,i = cT‚àí 1,i + aT ‚àí1,i.
" class="math-display" ></div>
  </td><td class="equation-label">(36)</td></tr></table>
<!--l. 969--><p class="nopar" >
<!--l. 971--><p class="indent" >  These <img 
src="SolvingMicroDSOPs324x.svg" alt="mT ‚àí1   " class="math";align="absmiddle"> gridpoints are ‚Äúendogenous‚Äù in contrast to the usual solution method of
specifying some <span 
class="ecti-1200">ex-ante </span>grid of values of <img 
src="SolvingMicroDSOPs325x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle"> and then using a rootÔ¨Ånding routine to locate
the corresponding optimal <img 
src="SolvingMicroDSOPs326x.svg" alt="cT‚àí1   " class="math";align="absmiddle">. This routine is performed in ‚ÄúEndogenous Gridpoints‚Äù .
First, the <span 
class="ectt-1200">gothic.C_Tminus1 </span>function is called for each of the pre-specÔ¨Åed values of
end-of-period assets stored in <span 
class="ectt-1200">aVec</span>. These values of consumption and assets are used to
produce the list of endogenous gridpoints, stored in the object <span 
class="ectt-1200">mVec_egm</span>. With the
<img 
src="SolvingMicroDSOPs327x.svg" alt="‚Éóc +
 T  ‚àí1   " class="math";align="absmiddle"> values in hand, we can generate a set of <img 
src="SolvingMicroDSOPs328x.svg" alt="mT ‚àí1,i  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs329x.svg" alt="cT‚àí1,i  " class="math";align="absmiddle"> pairs that can be
interpolated between in order to yield <img 
src="SolvingMicroDSOPs330x.svg" alt="`c(mT ‚àí 1)  " class="math";align="absmiddle"> at virtually zero computational
cost!<span class="footnote-mark"><a 
href="SolvingMicroDSOPs13.html#fn12x0"><sup class="textsuperscript">12</sup></a></span><a 
 id="x1-15003f12"></a>  
This is done in the Ô¨Ånal line of code in this block, and the following code block produces the
graph of the interpolated consumption function using this procedure.
<!--l. 983--><p class="indent" >  One might worry about whether the <img 
src="SolvingMicroDSOPs331x.svg" alt="{m, c} " class="math";align="absmiddle"> points obtained in this way will provide a good
representation of the consumption function as a whole, but in practice there are good reasons
why they work well (basically, this procedure generates a set of gridpoints that is
naturally dense right around the parts of the function with the greatest nonlinearity). <a 
 id="PlotComparecTm1AD"></a>
<div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1500411"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotComparecTm1AD.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†11:</span><span  
class="content"><img 
src="SolvingMicroDSOPs332x.svg" alt="cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs333x.svg" alt="`cT‚àí1(mT ‚àí1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-1500411 -->
                                                                                     
                                                                                     
  </div>
<!--l. 994--><p class="indent" >  Figure¬†<a 
href="#x1-1500411">11<!--tex4ht:ref: fig:ComparecTm1AD --></a> plots the actual consumption function <img 
src="SolvingMicroDSOPs334x.svg" alt="cT‚àí1   " class="math";align="absmiddle"> and the approximated consumption
function <img 
src="SolvingMicroDSOPs335x.svg" alt="`cT‚àí1   " class="math";align="absmiddle"> derived by the method of endogenous grid points. Compared to the
approximate consumption functions illustrated in Figure¬†<a 
href="#x1-120078">8<!--tex4ht:ref: fig:PlotcTm1ABC --></a>, <img 
src="SolvingMicroDSOPs336x.svg" alt="`c
 T‚àí 1   " class="math";align="absmiddle"> is quite close to the actual
consumption function.
<!--l. 1003--><p class="indent" >  <a 
 id="Improving-the-a-Grid"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.9  </span> <a 
 id="x1-160005.9"></a>Improving the <img 
src="SolvingMicroDSOPs337x.svg" alt="a  " class="math";align="absmiddle"> Grid</h4>
<!--l. 1006--><p class="noindent" >Thus far, we have arbitrarily used <img 
src="SolvingMicroDSOPs338x.svg" alt="a  " class="math";align="absmiddle"> gridpoints of <img 
src="SolvingMicroDSOPs339x.svg" alt="{0.,1.,2.,3.,4.} " class="math";align="absmiddle"> (augmented in
the last subsection by <img 
src="SolvingMicroDSOPs340x.svg" alt="a
-T‚àí1   " class="math";align="absmiddle">). But it has been obvious from the Ô¨Ågures that the
approximated <img 
src="SolvingMicroDSOPs341x.svg" alt="`cT +‚àí1   " class="math";align="absmiddle"> function tends to be farthest from its true value <img 
src="SolvingMicroDSOPs342x.svg" alt="cT +‚àí1   " class="math";align="absmiddle"> at
low values of <img 
src="SolvingMicroDSOPs343x.svg" alt="a  " class="math";align="absmiddle">. Combining this with our insight that <img 
src="SolvingMicroDSOPs344x.svg" alt="aT‚àí1   " class="math";align="absmiddle"> is a lower bound, we
are now in position to deÔ¨Åne a more deliberate method for constructing gridpoints
for <img 
src="SolvingMicroDSOPs345x.svg" alt="aT‚àí1   " class="math";align="absmiddle"> ‚Äì a method that yields values that are more densely spaced than the
uniform grid at low values of <img 
src="SolvingMicroDSOPs346x.svg" alt="a  " class="math";align="absmiddle">. A pragmatic choice that works well is to Ô¨Ånd the
values such that (1) the last value <span 
class="ecti-1200">exceeds the lower bound </span>by the same amount
<img 
src="SolvingMicroDSOPs347x.svg" alt="¬ØaT ‚àí1   " class="math";align="absmiddle"> as our original maximum gridpoint (in our case, 4.); (2) we have the same
number of gridpoints as before; and (3) the <span 
class="ecti-1200">multi-exponential growth rate </span>(that is,
<img 
src="SolvingMicroDSOPs348x.svg" alt="   ...
eee   " class="math";align="absmiddle"> for some number of exponentiations <img 
src="SolvingMicroDSOPs349x.svg" alt="n ùúÉùúÉùúÉ  " class="math";align="absmiddle">) from each point to the next point is
constant (instead of, as previously, imposing constancy of the absolute gap between
points).
<!--l. 1023--><p class="indent" >  <a 
 id="GothVInvVSGothCEEE"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1600112"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/GothVInvVSGothCEEE.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure¬†12:</span><span  
class="content"><img 
src="SolvingMicroDSOPs350x.svg" alt="cT+‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs351x.svg" alt="`cT+ ‚àí1(aT‚àí1)  " class="math";align="absmiddle">, Multi-Exponential <span 
class="ectt-1200">aVec</span></span></figcaption><!--tex4ht:label?: x1-1600112 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1032--><p class="indent" >  <a 
 id="GothVVSGothCInvEEE"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1600213"></a>
                                                                                     
                                                                                     
<!--l. 1034--><p class="noindent" > <img 
src="./Figures/GothVVSGothCInvEEE.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†13:</span><span  
class="content"><img 
src="SolvingMicroDSOPs352x.svg" alt="vaT+‚àí1(aT‚àí 1)  " class="math";align="absmiddle"> vs. <img 
src="SolvingMicroDSOPs353x.svg" alt="``v‚Ä≤T +‚àí1(aT‚àí1)  " class="math";align="absmiddle">, Multi-Exponential <span 
class="ectt-1200">aVec</span></span></figcaption><!--tex4ht:label?: x1-1600213 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1040--><p class="indent" >  Section ‚ÄúImprove the <img 
src="SolvingMicroDSOPs354x.svg" alt="ùî∏grid  " class="math";align="absmiddle">‚Äù begins by deÔ¨Åning a function which takes as arguments the
speciÔ¨Åcations of an initial grid of assets (captured by the arguments <span 
class="ectt-1200">minval</span>, <span 
class="ectt-1200">maxval</span>, and
<span 
class="ectt-1200">size</span>) and returns the new grid incorporating the multi-exponential approach outlined above.
Then, a call is made to this function and the improved grid of assets is stored in the object
<span 
class="ectt-1200">aVec_eee</span>. Lastly, the endogenous gridpoint method described in the previous section is
performed using this new grid of assets. Notice that the graphs depicted in Figures¬†<a 
href="#x1-1600112">12<!--tex4ht:ref: fig:GothVInvVSGothCEE --></a> and <a 
href="#x1-1600213">13<!--tex4ht:ref: fig:GothVVSGothCInvEE --></a>
are notably closer to their respective truths than the corresponding Ô¨Ågures that used the
original grid.
<!--l. 1050--><p class="indent" >  <a 
 id="The-Method-of-Moderation"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.10  </span> <a 
 id="x1-170005.10"></a>The Method of Moderation</h4>
<!--l. 2--><p class="noindent" >Unfortunately, this endogenous gridpoints solution is not very well-behaved outside the
original range of gridpoints targeted by the solution method. (Though other common solution
methods are no better outside their own predeÔ¨Åned ranges). Figure¬†<a 
href="#x1-1700114">14<!--tex4ht:ref: fig:ExtrapProblem --></a> demonstrates the point
by plotting the amount of precautionary saving implied by a linear extrapolation of our
approximated consumption rule (the consumption of the perfect foresight consumer
<img 
src="SolvingMicroDSOPs355x.svg" alt="¬ØcT‚àí 1 " class="math";align="absmiddle"> minus our approximation to optimal consumption under uncertainty, <img 
src="SolvingMicroDSOPs356x.svg" alt="`cT‚àí 1   " class="math";align="absmiddle">).
Although theory proves that precautionary saving is always positive, the linearly
extrapolated numerical approximation eventually predicts negative precautionary
saving (at the point in the Ô¨Ågure where the extrapolated locus crosses the horizontal
axis).
<!--l. 16--><p class="indent" >  <a 
 id="ExtrapProblemPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1700114"></a>
                                                                                     
                                                                                     
<!--l. 18--><p class="noindent" > <img 
src="./Figures/ExtrapProblemPlot.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†14:</span><span  
class="content">For  Large  Enough  <img 
src="SolvingMicroDSOPs357x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">,  Predicted  Precautionary  Saving  is  Negative
(Oops!)</span></figcaption><!--tex4ht:label?: x1-1700114 -->
                                                                                     
                                                                                     
  </div>
<!--l. 23--><p class="indent" >  This error cannot be Ô¨Åxed by extending the upper gridpoint; in the presence of
serious uncertainty, the consumption rule will need to be evaluated outside of <span 
class="ecti-1200">any</span>
prespeciÔ¨Åed grid (because starting from the top gridpoint, a large enough realization
of the uncertain variable will push next period‚Äôs realization of assets above that
top; a similar argument applies below the bottom gridpoint). While a judicious
extrapolation technique can prevent this problem from being fatal (for example by carefully
excluding negative precautionary saving), the problem is often dealt with using
inelegant methods whose implications for the accuracy of the solution are diÔ¨Écult to
gauge.
<!--l. 1--><p class="indent" >  As a preliminary to our solution, deÔ¨Åne <img 
src="SolvingMicroDSOPs358x.svg" alt="ùî•t  " class="math";align="absmiddle"> as end-of-period human wealth (the present
discounted value of future labor income) for a perfect foresight version of the problem of a ‚Äòrisk
optimist:‚Äô a consumer who believes with perfect conÔ¨Ådence that the shocks will always take the
value 1, <img 
src="SolvingMicroDSOPs359x.svg" alt="ùúÉùúÉùúÉt+n = ùîº [ùúÉùúÉùúÉ] = 1 ‚àÄ n &#x003E; 0  " class="math";align="absmiddle">. The solution to a perfect foresight problem of this kind takes
the form<span class="footnote-mark"><a 
href="SolvingMicroDSOPs14.html#fn13x0"><sup class="textsuperscript">13</sup></a></span><a 
 id="x1-17002f13"></a>  
  <table 
class="equation"><tr><td><a 
 id="x1-17003r37"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs362x.svg" alt="¬Øct(mt ) = (mt + ùî•t)Œ∫t
" class="math-display" ></div>
  </td><td class="equation-label">(37)</td></tr></table>
<!--l. 3--><p class="nopar" >
for a constant minimal marginal propensity to consume <img 
src="SolvingMicroDSOPs363x.svg" alt="Œ∫t  " class="math";align="absmiddle"> given below.
<!--l. 1--><p class="indent" >  We similarly deÔ¨Åne <img 
src="SolvingMicroDSOPs364x.svg" alt="ùî•-
 t  " class="math";align="absmiddle"> as ‚Äòminimal human wealth,‚Äô the present discounted value
of labor income if the shocks were to take on their worst possible value in every
future period <img 
src="SolvingMicroDSOPs365x.svg" alt="ùúÉ      ùúÉ
ùúÉùúÉt+n = ùúÉùúÉ-‚àÄ n &#x003E; 0  " class="math";align="absmiddle"> (which we deÔ¨Åne as corresponding to the beliefs of a
‚Äòpessimist‚Äô).
<!--l. 10--><p class="indent" >  We will call a ‚Äòrealist‚Äô the consumer who correctly perceives the true probabilities of the
future risks and optimizes accordingly.
<!--l. 12--><p class="indent" >  A Ô¨Årst useful point is that, for the realist, a lower bound for the level of market resources is
<img 
src="SolvingMicroDSOPs366x.svg" alt="mt  = ‚àí ùî•t  " class="math";align="absmiddle">, because if <img 
src="SolvingMicroDSOPs367x.svg" alt="mt  " class="math";align="absmiddle"> equalled this value then there would be a positive Ô¨Ånite chance
(however small) of receiving <img 
src="SolvingMicroDSOPs368x.svg" alt="ùúÉùúÉùúÉt+n = ùúÉùúÉùúÉ-  " class="math";align="absmiddle"> in every future period, which would require the
                                                                                     
                                                                                     
consumer to set <img 
src="SolvingMicroDSOPs369x.svg" alt="ct  " class="math";align="absmiddle"> to zero in order to guarantee that the intertemporal budget constraint
holds¬†(this is the multiperiod generalization of the discussion in section <a 
href="#x1-140005.7">5.7<!--tex4ht:ref: subsec:LiqConstrSelfImposed --></a> about <img 
src="SolvingMicroDSOPs370x.svg" alt="aT‚àí 1   " class="math";align="absmiddle">).
Since consumption of zero yields negative inÔ¨Ånite utility, the solution to realist consumer‚Äôs
problem is not well deÔ¨Åned for values of <img 
src="SolvingMicroDSOPs371x.svg" alt="m  &#x003C; m
  t  --t  " class="math";align="absmiddle">, and the limiting value of the realist‚Äôs <img 
src="SolvingMicroDSOPs372x.svg" alt="c
 t  " class="math";align="absmiddle"> is
zero as <img 
src="SolvingMicroDSOPs373x.svg" alt="mt ‚Üì mt  " class="math";align="absmiddle">.
<!--l. 28--><p class="indent" >  Given this result, it will be convenient to deÔ¨Åne ‚Äòexcess‚Äô market resources as the amount by
which actual resources exceed the lower bound, and ‚Äòexcess‚Äô human wealth as the
amount by which mean expected human wealth exceeds guaranteed minimum human
wealth:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs374x.svg" alt="             =‚óú‚àí‚óûm‚óüt‚óù
‚ñ¥mt  = mt +   ùî•
              -t
 ‚ñ¥ùî•t = ùî•t ‚àí ùî•t.
" class="math-display" ></div>
  </td></tr></table>
<!--l. 35--><p class="nopar" >
<!--l. 37--><p class="indent" >  We can now transparently deÔ¨Åne the optimal consumption rules for the two perfect foresight
problems, those of the ‚Äòoptimist‚Äô and the ‚Äòpessimist.‚Äô The ‚Äòpessimist‚Äô perceives human wealth
to be equal to its minimum feasible value <img 
src="SolvingMicroDSOPs375x.svg" alt="ùî•-
 t  " class="math";align="absmiddle"> with certainty, so consumption is given by the
perfect foresight solution
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs376x.svg" alt="ct(mt ) = (mt  + ùî•t)Œ∫t
      =  ‚ñ¥m  Œ∫ .
            t-t
" class="math-display" ></div>
  </td></tr></table>
                                                                                     
                                                                                     
<!--l. 46--><p class="nopar" >
<!--l. 48--><p class="indent" >  The ‚Äòoptimist,‚Äô on the other hand, pretends that there is no uncertainty about future
income, and therefore consumes
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs377x.svg" alt="¬Øct(mt ) = (mt + ùî•t ‚àí ùî•t + ùî•t)Œ∫t

       = (‚ñ¥mt  + ‚ñ¥ ùî•t)Œ∫t
       = ct(mt ) + ‚ñ¥ùî•tŒ∫t.
" class="math-display" ></div>
  </td></tr></table>
<!--l. 55--><p class="nopar" >
<!--l. 57--><p class="indent" >  It seems obvious that the spending of the realist will be strictly greater than that of the
pessimist and strictly less than that of the optimist. Figure¬†<a 
href="#x1-1700415">15<!--tex4ht:ref: fig:IntExpFOCInvPesReaOptNeedHiPlot --></a> illustrates the proposition for
the consumption rule in period <img 
src="SolvingMicroDSOPs378x.svg" alt="T ‚àí  1  " class="math";align="absmiddle">.
<a 
 id="IntExpFOCInvPesReaOptNeedHiPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1700415"></a>
                                                                                     
                                                                                     
<!--l. 3--><p class="noindent" > <img 
src="./Figures/IntExpFOCInvPesReaOptNeedHiPlot.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†15:</span><span  
class="content">Moderation Illustrated: <img 
src="SolvingMicroDSOPs379x.svg" alt="cT‚àí 1 &#x003C; `cT ‚àí1 &#x003C; ¬ØcT‚àí1   " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-1700415 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2--><p class="indent" >  The proof is more diÔ¨Écult than might be imagined, but the necessary work is done in <span 
class="ecbx-1200">? </span>so
we will take the proposition as a fact and proceed by manipulating the inequality:
<div class="center" 
>
<!--l. 1--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs380x.svg" alt="  ‚ñ¥m  Œ∫  &#x003C;    c (m   + ‚ñ¥m  ) &#x003C; (‚ñ¥m   + ‚ñ¥ ùî• )Œ∫
     t-t       t--t      t         t     t-t
‚àí ‚ñ¥mt Œ∫t &#x003E;            ‚àí ct(mt + ‚ñ¥mt )           &#x003E; ‚àí (‚ñ¥mt  + ‚ñ¥ ùî•t)Œ∫t
   ‚ñ¥ùî•tŒ∫t &#x003E;   ( ¬Øct(mt +  ‚ñ¥mt ) ‚àí ct(mt + ‚ñ¥mt  ))   &#x003E; 0
               ¬Øct(mt-+--‚ñ¥mt-) ‚àí-ct(mt-+-‚ñ¥mt--)
       1 &#x003E;                ‚ñ¥ ùî• Œ∫                 &#x003E; 0
             ‚óü--------------‚óùt‚óú-t------------‚óû
                            ‚â°ÀÜœôt
" ></div></div>
<!--l. 1--><p class="noindent" >where the fraction in the middle of the last inequality is the ratio of actual precautionary saving
(the numerator is the diÔ¨Äerence between perfect-foresight consumption and optimal
consumption in the presence of uncertainty) to the maximum conceivable amount of
precautionary saving (the amount that would be undertaken by the pessimist who consumes
nothing out of any future income beyond the perfectly certain component).
<!--l. 1--><p class="indent" >  DeÔ¨Åning <img 
src="SolvingMicroDSOPs381x.svg" alt="Œºt = log ‚ñ¥mt  " class="math";align="absmiddle"> (which can range from <img 
src="SolvingMicroDSOPs382x.svg" alt="‚àí  ‚àû " class="math";align="absmiddle"> to <img 
src="SolvingMicroDSOPs383x.svg" alt="‚àû " class="math";align="absmiddle">), the object in the middle of
the last inequality is
  <table 
class="equation"><tr><td><a 
 id="x1-17005r38"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs384x.svg" alt="         (¬Øct(mt + eŒºt) ‚àí ct(mt  + eŒºt))
ÀÜœôt(Œºt) ‚â°  --------------------------   ,
                     ‚ñ¥ùî•tŒ∫t
" class="math-display" ></div>
  </td><td class="equation-label">(38)</td></tr></table>
<!--l. 5--><p class="nopar" >
and we now deÔ¨Åne
  <table 
class="equation"><tr><td><a 
 id="x1-17006r39"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs385x.svg" alt="            ( 1 ‚àí ÀÜœô (Œºt) )
ÀÜœáœáœát(Œºt) = log   -----t----
                ÀÜœôt(Œºt)
      =  log (1‚àïÀÜœôt(Œºt) ‚àí 1 )
" class="math-display" ></div>
  </td><td class="equation-label">(39)</td></tr></table>
<!--l. 10--><p class="nopar" >
which has the virtue that it is linear in the limit as <img 
src="SolvingMicroDSOPs386x.svg" alt="Œºt  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs387x.svg" alt="+  ‚àû " class="math";align="absmiddle">.
<!--l. 3--><p class="indent" >  Given <img 
src="SolvingMicroDSOPs388x.svg" alt="ÀÜœáœáœá  " class="math";align="absmiddle">, the consumption function can be recovered from
  <table 
class="equation"><tr><td><a 
 id="x1-17007r40"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs389x.svg" alt="                =ÀÜœôt
         ‚óú(------‚óû‚óü-----‚óù)
           -----1------
ÀÜct = ¬Øct ‚àí  1 + exp (œáœáÀÜœát)  ‚ñ¥ùî•tŒ∫t.
" class="math-display" ></div>
  </td><td class="equation-label">(40)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 2--><p class="indent" >  Thus, the procedure is to calculate <img 
src="SolvingMicroDSOPs390x.svg" alt="ÀÜœáœáœá
  t  " class="math";align="absmiddle"> at the points <img 
src="SolvingMicroDSOPs391x.svg" alt="‚ÉóŒº
 t  " class="math";align="absmiddle"> corresponding to the log of the
<img 
src="SolvingMicroDSOPs392x.svg" alt="‚ñ¥ ‚Éómt  " class="math";align="absmiddle"> points deÔ¨Åned above, and then using these to construct an interpolating approximation
<img 
src="SolvingMicroDSOPs393x.svg" alt="`ÀÜœáœáœát " class="math";align="absmiddle"> from which we indirectly obtain our approximated consumption rule <img 
src="SolvingMicroDSOPs394x.svg" alt="`ÀÜct  " class="math";align="absmiddle"> by substituting
<img 
src="SolvingMicroDSOPs395x.svg" alt="`ÀÜœáœáœát " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs396x.svg" alt="ÀÜœáœáœá  " class="math";align="absmiddle"> in equation (<a 
href="#x1-17007r40">40<!--tex4ht:ref: eq:cFuncHi --></a>).
<!--l. 8--><p class="indent" >  Because this method relies upon the fact that the problem is easy to solve if the decision
maker has unreasonable views (either in the optimistic or the pessimistic direction), and
because the correct solution is always between these immoderate extremes, we call our
solution procedure the ‚Äòmethod of moderation.‚Äô
<!--l. 14--><p class="indent" >  Results are shown in Figure¬†<a 
href="#x1-1700816">16<!--tex4ht:ref: fig:ExtrapProblemSolved --></a>; a reader with very good eyesight might be able to detect
the barest hint of a discrepancy between the Truth and the Approximation at the far
righthand edge of the Ô¨Ågure ‚Äì a stark contrast with the calamitous divergence evident in
                                                                                     
                                                                                     
Figure¬†<a 
href="#x1-1700114">14<!--tex4ht:ref: fig:ExtrapProblem --></a>. <a 
 id="ExtrapProblemSolvedPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1700816"></a>
                                                                                     
                                                                                     
<!--l. 21--><p class="noindent" > <img 
src="./Figures/ExtrapProblemSolvedPlot.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†16:</span><span  
class="content">Extrapolated <img 
src="SolvingMicroDSOPs397x.svg" alt="`ÀÜcT‚àí 1   " class="math";align="absmiddle"> Constructed Using the Method of Moderation</span></figcaption><!--tex4ht:label?: x1-1700816 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1263--><p class="indent" >  <a 
 id="Approximating-the-Slope-Too"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.11  </span> <a 
 id="x1-180005.11"></a>Approximating the Slope Too</h4>
<!--l. 1267--><p class="noindent" >Until now, we have calculated the level of consumption at various diÔ¨Äerent gridpoints and used
linear interpolation (either directly for <img 
src="SolvingMicroDSOPs398x.svg" alt="cT ‚àí1   " class="math";align="absmiddle"> or indirectly for, say, <img 
src="SolvingMicroDSOPs399x.svg" alt="ÀÜœáœáœáT‚àí 1   " class="math";align="absmiddle">). But the resulting
piecewise linear approximations have the unattractive feature that they are not diÔ¨Äerentiable
at the ‚Äòkink points‚Äô that correspond to the gridpoints where the slope of the function changes
discretely.
<!--l. 1276--><p class="indent" >  <span 
class="ecbx-1200">? </span>shows that the true consumption function for this problem is ‚Äòsmooth:‚Äô It exhibits a
well-deÔ¨Åned unique marginal propensity to consume at every positive value of <img 
src="SolvingMicroDSOPs400x.svg" alt="m  " class="math";align="absmiddle">. This
suggests that we should calculate, not just the level of consumption, but also the
marginal propensity to consume (henceforth <img 
src="SolvingMicroDSOPs401x.svg" alt="Œ∫  " class="math";align="absmiddle">) at each gridpoint, and then Ô¨Ånd an
interpolating approximation that smoothly matches both the level and the slope at those
points.
<!--l. 1286--><p class="indent" >  This requires us to diÔ¨Äerentiate (<a 
href="#x1-17005r38">38<!--tex4ht:ref: eq:koppa --></a>) and (<a 
href="#x1-17006r39">39<!--tex4ht:ref: eq:chi --></a>), yielding
  <table 
class="equation"><tr><td><a 
 id="x1-18001r41"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs402x.svg" alt="                      (       --‚â°Œ∫Œ∫Œ∫t(mt)---)
 Œº               ‚àí1 Œºt(      ‚óúm   ‚óû‚óü  Œºt‚óù)
ÀÜœôt (Œºt) = (‚ñ¥ ùî•tŒ∫t)  e    Œ∫t ‚àí ct (mt + e )
         (             )
 Œº          ‚àí ÀÜœô Œºt(Œºt)‚àï ÀÜœô2
ÀÜœáœáœát (Œºt) =   -----------t
           1‚àïœôÀÜt(Œºt) ‚àí 1
" class="math-display" ></div>
  </td><td class="equation-label">(41)</td></tr></table>
<!--l. 1290--><p class="nopar" >
and (dropping arguments) with some algebra these can be combined to yield
  <table 
class="equation"><tr><td><a 
 id="x1-18002r42"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs403x.svg" alt="      (                         )
  Œº        Œ∫t‚ñ¥mt ‚ñ¥ ùî•t(Œ∫t ‚àí Œ∫t)
œáœáœáÀÜt =   ------------------------- .
        (¬Øct ‚àí ct)(¬Øct ‚àí ct ‚àí Œ∫t‚ñ¥ ùî•t)
" class="math-display" ></div>
  </td><td class="equation-label">(42)</td></tr></table>
<!--l. 1295--><p class="nopar" >
<!--l. 1297--><p class="indent" >  To compute the vector of values of (<a 
href="#x1-18001r41">41<!--tex4ht:ref: eq:koppaPrime --></a>) corresponding to the points in <img 
src="SolvingMicroDSOPs404x.svg" alt="‚ÉóŒºt  " class="math";align="absmiddle">, we need the
marginal propensities to consume (designated <img 
src="SolvingMicroDSOPs405x.svg" alt="Œ∫  " class="math";align="absmiddle">) at each of the gridpoints, <img 
src="SolvingMicroDSOPs406x.svg" alt="cmt  " class="math";align="absmiddle"> (the vector of
such values is <img 
src="SolvingMicroDSOPs407x.svg" alt="‚ÉóŒ∫
 t  " class="math";align="absmiddle">). These can be obtained by diÔ¨Äerentiating the Euler equation (<a 
href="#x1-4012r21">21<!--tex4ht:ref: eq:upEqbetaOp --></a>) (where
we deÔ¨Åne <img 
src="SolvingMicroDSOPs408x.svg" alt="ùî™t(a) ‚â° c+t(a) + a  " class="math";align="absmiddle">):
  <table 
class="equation"><tr><td><a 
 id="x1-18003r43"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs409x.svg" alt="uc(c ) = vÀÜ a(ùî™  ‚àí  c)
    t     +t   t    t
" class="math-display" ></div>
  </td><td class="equation-label">(43)</td></tr></table>
<!--l. 1306--><p class="nopar" >
with respect to <img 
src="SolvingMicroDSOPs410x.svg" alt="a  " class="math";align="absmiddle">, yielding a marginal propensity to <span 
class="ecti-1200">have consumed</span> <img 
src="SolvingMicroDSOPs411x.svg" alt="ca
 t  " class="math";align="absmiddle"> at each
gridpoint:
  <table 
class="equation"><tr><td><a 
 id="x1-18004r44"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs412x.svg" alt="u‚Ä≤‚Ä≤(c+t)ca+t = vÀÜ+ta(ùî™t ‚àí ct)
       ca =  vÀÜ a(ùî™  ‚àí c)‚àïu ‚Ä≤‚Ä≤(c )
        +t    +t   t    t      +t
" class="math-display" ></div>
  </td><td class="equation-label">(44)</td></tr></table>
<!--l. 1312--><p class="nopar" >
and the marginal propensity to consume at the beginning of the period is obtained from the
marginal propensity to have consumed by noting that
  <table 
class="equation-star"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs413x.svg" alt="     ùî† = ùî™ ‚àí  a
 a         a
ùî†  + 1 = ùî™
" class="math-display" ></div>
  </td></tr></table>
<!--l. 1318--><p class="nopar" >
which, together with the chain rule <img 
src="SolvingMicroDSOPs414x.svg" alt="ùî†a = cm ùî™a  " class="math";align="absmiddle">, yields the MPC from
  <table 
class="equation"><tr><td><a 
 id="x1-18005r45"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs415x.svg" alt="       a
   ‚óú=ùî™‚óû‚óü-‚óù
cm(ùî†a + 1) = ùî†a
        m    a       a
       c  =  ùî†‚àï(1 + ùî† ).
" class="math-display" ></div>
  </td><td class="equation-label">(45)</td></tr></table>
<!--l. 1324--><p class="nopar" >
<!--l. 1327--><p class="indent" >  Designating <img 
src="SolvingMicroDSOPs416x.svg" alt="`ÀÜcT‚àí1   " class="math";align="absmiddle"> as the approximated consumption rule obtained using an interpolating
polynomial approximation to <img 
src="SolvingMicroDSOPs417x.svg" alt="œáœáœáÀÜ  " class="math";align="absmiddle"> that matches both the level and the Ô¨Årst derivative at
the gridpoints, Figure¬†<a 
href="#x1-1800617">17<!--tex4ht:ref: fig:IntExpFOCInvPesReaOptGapPlot --></a> plots the diÔ¨Äerence between this latest approximation
and the true consumption rule for period <img 
src="SolvingMicroDSOPs418x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> up to the same large value (far
beyond the largest gridpoint) used in prior Ô¨Ågures. Of course, at the gridpoints
the approximation will match the true function; but this Ô¨Ågure illustrates that the
approximation is quite accurate far beyond the last gridpoint (which is the last point
at which the diÔ¨Äerence touches the horizontal axis). (We plot here the diÔ¨Äerence
between the two functions rather than the level plotted in previous Ô¨Ågures, because in
levels the approximation error would not be detectable even to the most eagle-eyed
reader.)
<!--l. 1331--><p class="indent" >  <a 
 id="IntExpFOCInvPesReaOptGapPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1800617"></a>
                                                                                     
                                                                                     
<!--l. 1333--><p class="noindent" > <img 
src="./Figures/IntExpFOCInvPesReaOptGapPlot.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†17:</span><span  
class="content">DiÔ¨Äerence Between True <img 
src="SolvingMicroDSOPs419x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs420x.svg" alt="`ÀÜcT‚àí 1   " class="math";align="absmiddle"> Is Minuscule</span></figcaption><!--tex4ht:label?: x1-1800617 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1341--><p class="indent" >  <a 
 id="Value"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.12  </span> <a 
 id="x1-190005.12"></a>Value</h4>
<!--l. 2--><p class="noindent" >Often it is useful to know the value function as well as the consumption rule. Fortunately,
many of the tricks used when solving for the consumption rule have a direct analogue in
approximation of the value function.
<!--l. 4--><p class="indent" >  Consider the perfect foresight (or ‚Äúoptimist‚Äôs‚Äù) problem in period <img 
src="SolvingMicroDSOPs421x.svg" alt="T ‚àí 1  " class="math";align="absmiddle">:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs422x.svg" alt="¬Øv    (m    ) ‚â° u(c   ) + Œ≤u (c  )
 T ‚àí1   T‚àí1       T‚àí1 (      T            )
            =  u(cT‚àí1)  1 + Œ≤ ((Œ≤TR )1‚àïœÅ)1‚àíœÅ
                      (            1‚àïœÅ‚àí1)
            =  u(cT‚àí1)( 1 + Œ≤ (Œ≤TR )  )
            =  u(cT‚àí1)  1 + (Œ≤T R)1‚àïœÅ‚àïR
                           T
            =  u(cT‚àí1)P‚óüDV--t-(c‚óù)‚óú‚àïcT-‚àí1‚óû
                            ‚â°‚ÑÇT
                              t
" class="math-display" ></div>
  </td></tr></table>
<!--l. 11--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs423x.svg" alt="‚ÑÇTt =  PDVTt (c)  " class="math";align="absmiddle"> is the present discounted value of consumption. A similar function
can be constructed recursively for earlier periods, yielding the general expression <a 
 id="vFuncPF"></a>
  <table 
class="equation"><tr><td><a 
 id="x1-19001r46"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs424x.svg" alt="¬Øvt(mt ) = u(¬Øct)‚ÑÇT
               ‚àít1
       =  u(¬Øct)Œ∫t
       =  u((‚ñ¥mt +  ‚ñ¥ùî•t)Œ∫t)Œ∫‚àít1
                        1‚àíœÅ  ‚àí1
       =  u(‚ñ¥mt +  ‚ñ¥ùî•t)Œ∫t  Œ∫-t
       =  u(‚ñ¥m  +  ‚ñ¥ùî• )Œ∫‚àí œÅ
               t      t-t
" class="math-display" ></div>
  </td><td class="equation-label">(46)</td></tr></table>
<!--l. 7--><p class="nopar" >
where the second line uses the fact demonstrated in <span 
class="ecbx-1200">? </span>that <img 
src="SolvingMicroDSOPs425x.svg" alt="      ‚àí1
‚ÑÇt = Œ∫t  " class="math";align="absmiddle">.
<!--l. 10--><p class="indent" >  This can be transformed as
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs426x.svg" alt="¬ØŒõ ‚â°  ((1 ‚àí œÅ)¬Øv )1‚àï(1‚àíœÅ)
 t           t
  =  ct(‚ÑÇTt )1‚àï(1‚àíœÅ)
                  ‚àíœÅ‚àï(1‚àíœÅ)
  =  (‚ñ¥mt  + ‚ñ¥ ùî•t)Œ∫t
" class="math-display" ></div>
  </td></tr></table>
<!--l. 15--><p class="nopar" >
with derivative
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs427x.svg" alt="¬ØŒõmt =  (‚ÑÇTt )1‚àï(1‚àíœÅ)Œ∫t,
       ‚àíœÅ‚àï(1‚àí œÅ)
   =  Œ∫t
" class="math-display" ></div>
  </td></tr></table>
                                                                                     
                                                                                     
<!--l. 5--><p class="nopar" >
and since <img 
src="SolvingMicroDSOPs428x.svg" alt="‚ÑÇTt  " class="math";align="absmiddle"> is a constant while the consumption function is linear, <img 
src="SolvingMicroDSOPs429x.svg" alt="¬ØŒõt  " class="math";align="absmiddle"> will also be
linear.
<!--l. 9--><p class="indent" >  We apply the same transformation to the value function for the problem with uncertainty
(the ‚Äúrealist‚Äôs‚Äù problem) and diÔ¨Äerentiate
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs430x.svg" alt=" ¬ØŒõt = ((1 ‚àí œÅ)¬Øvt(mt ))1‚àï(1‚àí œÅ)
                    ‚àí 1+1 ‚àï(1‚àíœÅ)
¬ØŒõmt =  ((1 ‚àí œÅ)¬Øvt(mt ))         ¬Øvmt (mt)
" class="math-display" ></div>
  </td></tr></table>
<!--l. 13--><p class="nopar" >
and an excellent approximation to the value function can be obtained by calculating the values
of <img 
src="SolvingMicroDSOPs431x.svg" alt="¬ØŒõ   " class="math";align="absmiddle"> at the same gridpoints used by the consumption function approximation, and
interpolating among those points.
<!--l. 18--><p class="indent" >  However, as with the consumption approximation, we can do even better if we realize that
the <img 
src="SolvingMicroDSOPs432x.svg" alt="¬ØŒõ   " class="math";align="absmiddle"> function for the optimist‚Äôs problem is an upper bound for the <img 
src="SolvingMicroDSOPs433x.svg" alt="Œõ   " class="math";align="absmiddle"> function in the
presence of uncertainty, and the value function for the pessimist is a lower bound. Analogously
to (<a 
href="#x1-17005r38">38<!--tex4ht:ref: eq:koppa --></a>), deÔ¨Åne an upper-case
  <table 
class="equation"><tr><td><a 
 id="x1-19002r47"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs434x.svg" alt="         (                           )
           ¬ØŒõt(mt + eŒºt) ‚àí Œõt(mt + e Œºt)
ÀÜœòt(Œºt) =   -------------T-1‚àï(1‚àíœÅ)------
                ‚ñ¥ ùî•tŒ∫t(‚ÑÇ t )
" class="math-display" ></div>
  </td><td class="equation-label">(47)</td></tr></table>
<!--l. 24--><p class="nopar" >
with derivative (dropping arguments)
  <table 
class="equation"><tr><td><a 
 id="x1-19003r48"></a>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs435x.svg" alt=" ÀÜŒº            T 1‚àï(1‚àíœÅ) ‚àí1 Œºt  m    m
œò t = (‚ñ¥ùî•tŒ∫t(‚ÑÇ t )     )  e  (¬ØŒõt ‚àí Œõt )
" class="math-display" ></div>
  </td><td class="equation-label">(48)</td></tr></table>
<!--l. 29--><p class="nopar" >
and an upper-case version of the <img 
src="SolvingMicroDSOPs436x.svg" alt="œáœáœá  " class="math";align="absmiddle"> equation in (<a 
href="#x1-17006r39">39<!--tex4ht:ref: eq:chi --></a>):
  <table 
class="equation"><tr><td><a 
 id="x1-19004r49"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs437x.svg" alt="            (           )
              1 ‚àí ÀÜœòt(Œºt)
ÀÜXt(Œºt) = log  ----------
                œòÀÜt(Œºt)
            (   ÀÜ         )
       = log  1‚àïœòt(Œºt) ‚àí 1
" class="math-display" ></div>
  </td><td class="equation-label">(49)</td></tr></table>
<!--l. 34--><p class="nopar" >
with corresponding derivative
  <table 
class="equation"><tr><td><a 
 id="x1-19005r50"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs438x.svg" alt="     (     Œº  2 )
ÀÜŒº     -‚àíœòÀÜt‚àïÀÜœòt-
Xt =   1‚àï ÀÜœò ‚àí 1
           t
" class="math-display" ></div>
  </td><td class="equation-label">(50)</td></tr></table>
                                                                                     
                                                                                     
<!--l. 38--><p class="nopar" >
and if we approximate these objects then invert them (as above with the <img 
src="SolvingMicroDSOPs439x.svg" alt="ÀÜœô  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs440x.svg" alt="œáœáÀÜœá  " class="math";align="absmiddle"> functions)
we obtain a very high-quality approximation to our inverted value function at the same points
for which we have our approximated value function:
  <table 
class="equation"><tr><td><a 
 id="x1-19006r51"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs441x.svg" alt="         ‚óú------=‚óûÀÜœò‚óüt-----‚óù
         (             )
ÀÜŒõ =  ¬ØŒõ ‚àí   ------1-----  ‚ñ¥ ùî• Œ∫ (‚ÑÇT)1‚àï(1‚àí œÅ)
 t    t    1 + exp (ÀÜXt)     t-t  t
" class="math-display" ></div>
  </td><td class="equation-label">(51)</td></tr></table>
<!--l. 45--><p class="nopar" >
from which we obtain our approximation to the value function and its derivatives¬†as
<a 
 id="vHatFunc"></a>
  <table 
class="equation"><tr><td><a 
 id="x1-19007r52"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs442x.svg" alt="  ÀÜvt = u(ÀÜŒõt)
  m     c     m
 ÀÜvt =  u (ÀÜŒõt)ÀÜŒõ
ÀÜvmtm =  ucc(ÀÜŒõt)(ÀÜŒõm )2 + uc(ÀÜŒõt)ÀÜŒõmm.
" class="math-display" ></div>
  </td><td class="equation-label">(52)</td></tr></table>
<!--l. 52--><p class="nopar" >
<!--l. 54--><p class="indent" >  Although a linear interpolation that matches the level of <img 
src="SolvingMicroDSOPs443x.svg" alt="Œõ   " class="math";align="absmiddle"> at the gridpoints is simple, a
Hermite interpolation that matches both the level and the derivative of the <img 
src="SolvingMicroDSOPs444x.svg" alt="¬ØŒõt  " class="math";align="absmiddle"> function at the
gridpoints has the considerable virtue that the <img 
src="SolvingMicroDSOPs445x.svg" alt="¬Øvt  " class="math";align="absmiddle"> derived from it numerically satisÔ¨Åes
the envelope theorem at each of the gridpoints for which the problem has been
solved.
                                                                                     
                                                                                     
<!--l. 68--><p class="indent" >  If we use the double-derivative calculated above to produce a higher-order Hermite
polynomial, our approximation will also match marginal propensity to consume at the
gridpoints; this would guarantee that the consumption function generated from the value
function would match both the level of consumption and the marginal propensity to consume
at the gridpoints; the numerical diÔ¨Äerences between the newly constructed consumption
function and the highly accurate one constructed earlier would be negligible within the
grid.
<!--l. 1452--><p class="indent" >  <a 
 id="Refinement-A-Tighter-Upper-Bound"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.13  </span> <a 
 id="x1-200005.13"></a>ReÔ¨Ånement: A Tighter Upper Bound</h4>
<!--l. 1--><p class="noindent" ><span 
class="ecbx-1200">? </span>derives an upper limit <img 
src="SolvingMicroDSOPs446x.svg" alt="Œ∫¬Øt  " class="math";align="absmiddle"> for the MPC as <img 
src="SolvingMicroDSOPs447x.svg" alt="mt  " class="math";align="absmiddle"> approaches its lower bound. Using this
fact plus the strict concavity of the consumption function yields the proposition
that
  <table 
class="equation"><tr><td><a 
 id="x1-20001r53"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs448x.svg" alt="ct(mt + ‚ñ¥mt ) &#x003C; ¬ØŒ∫t‚ñ¥mt.
" class="math-display" ></div>
  </td><td class="equation-label">(53)</td></tr></table>
<!--l. 7--><p class="nopar" >
<!--l. 9--><p class="indent" >  The solution method described above does not guarantee that approximated consumption
will respect this constraint between gridpoints, and a failure to respect the constraint can
occasionally cause computational problems in solving or simulating the model. Here,
we describe a method for constructing an approximation that always satisÔ¨Åes the
constraint.
<!--l. 1--><p class="indent" >  DeÔ¨Åning <img 
src="SolvingMicroDSOPs449x.svg" alt="  #
m t  " class="math";align="absmiddle"> as the ‚Äòcusp‚Äô point where the two upper bounds intersect:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs450x.svg" alt="(           )
    #                    #
 ‚ñ¥m t +  ‚ñ¥ùî•t  Œ∫t = ¬ØŒ∫t‚ñ¥m  t
              #      Œ∫t‚ñ¥ ùî•t
           ‚ñ¥m t  = ----------
                   (1 ‚àí Œ∫t)¬ØŒ∫t
              #    -Œ∫tùî•t ‚àí-ùî•t
             mt  = (1 ‚àí Œ∫ )¬ØŒ∫ ,
                        -t  t
" class="math-display" ></div>
  </td></tr></table>
<!--l. 7--><p class="nopar" >
we want to construct a consumption function for <img 
src="SolvingMicroDSOPs451x.svg" alt="mt ‚àà (mt, m#t ]  " class="math";align="absmiddle"> that respects the tighter
upper bound:
<div class="center" 
>
<!--l. 3--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs452x.svg" alt="       ‚ñ¥mt Œ∫t &#x003C;  ct(mt + ‚ñ¥mt  ) &#x003C; ¬ØŒ∫t‚ñ¥mt
‚ñ¥mt (¬ØŒ∫t ‚àí Œ∫-) &#x003E;   ¬ØŒ∫t‚ñ¥mt ‚àí  ct(mt +  ‚ñ¥mt )  &#x003E;  0
           t        (¬ØŒ∫t‚ñ¥mt‚àíct(mt+‚ñ¥mt ))
            1 &#x003E;      ---‚ñ¥mt(¬ØŒ∫t‚àíŒ∫t)----     &#x003E;  0.
" ></div></div>
<!--l. 1--><p class="indent" >  Again deÔ¨Åning <img 
src="SolvingMicroDSOPs453x.svg" alt="Œºt =  log ‚ñ¥mt  " class="math";align="absmiddle">, the object in the middle of the inequality is
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs454x.svg" alt="         ¬ØŒ∫t ‚àí ct(mt + eŒºt)e‚àíŒºt
Àáœôt(Œºt) ‚â° ---------------------
                ¬ØŒ∫t ‚àí Œ∫t
 Œº       ct(mt-+-eŒºt)e‚àíŒºt ‚àí-Œ∫Œ∫Œ∫mt (mt-+-eŒºt)
Àáœôt(Œºt) =             ¬ØŒ∫t ‚àí Œ∫-             .
                           t
" class="math-display" ><a 
 id="x1-200005.13"></a></div>
  </td></tr></table>
<!--l. 5--><p class="nopar" >
<!--l. 1--><p class="indent" >  As <img 
src="SolvingMicroDSOPs455x.svg" alt="mt  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs456x.svg" alt="‚àí mt  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs457x.svg" alt="Àáœôt(Œºt)  " class="math";align="absmiddle"> converges to zero, while as <img 
src="SolvingMicroDSOPs458x.svg" alt="mt  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs459x.svg" alt="+ ‚àû " class="math";align="absmiddle">,
<img 
src="SolvingMicroDSOPs460x.svg" alt="Àáœôt(Œºt)  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs461x.svg" alt="1  " class="math";align="absmiddle">.
                                                                                     
                                                                                     
<!--l. 5--><p class="indent" >  As before, we can derive an approximated consumption function; call it <img 
src="SolvingMicroDSOPs462x.svg" alt="`Àáct  " class="math";align="absmiddle">. This
function will clearly do a better job approximating the consumption function for low
values of <img 
src="SolvingMicroDSOPs463x.svg" alt="mt  " class="math";align="absmiddle"> while the previous approximation will perform better for high values of
<img 
src="SolvingMicroDSOPs464x.svg" alt="m
  t  " class="math";align="absmiddle">.
<!--l. 10--><p class="indent" >  For middling values of <img 
src="SolvingMicroDSOPs465x.svg" alt="m  " class="math";align="absmiddle"> it is not clear which of these functions will perform better.
However, an alternative is available which performs well. DeÔ¨Åne the highest gridpoint below
<img 
src="SolvingMicroDSOPs466x.svg" alt="m#t  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs467x.svg" alt="¬ØÀám#t  " class="math";align="absmiddle"> and the lowest gridpoint above <img 
src="SolvingMicroDSOPs468x.svg" alt="m#t  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs469x.svg" alt="ÀÜm#t  " class="math";align="absmiddle">. Then there will be a unique
interpolating polynomial that matches the level and slope of the consumption function at
these two points. Call this function <img 
src="SolvingMicroDSOPs470x.svg" alt="Àúct(m )  " class="math";align="absmiddle">.
<!--l. 18--><p class="indent" >  Using indicator functions that are zero everywhere except for speciÔ¨Åed intervals,
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs471x.svg" alt="                     #
 111Lo(m ) = 1 if m ‚â§ m¬ØÀát
111Mid(m ) = 1 if     ¬ØÀám#  &#x003C; m  &#x003C; ÀÜm#
                      t          t#
 111Hi(m ) = 1 if                ÀÜm-t ‚â§ m
" class="math-display" ></div>
  </td></tr></table>
<!--l. 5--><p class="nopar" >
we can deÔ¨Åne a well-behaved approximating consumption function
  <table 
class="equation"><tr><td><a 
 id="x1-20002r54"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs472x.svg" alt="`ct = 111Lo`Àáct + 111Mid`Àúct + 111Hi`ÀÜct.
" class="math-display" ></div>
  </td><td class="equation-label">(54)</td></tr></table>
                                                                                     
                                                                                     
<!--l. 9--><p class="nopar" >
<!--l. 1--><p class="indent" >  This just says that, for each interval, we use the approximation that is most appropriate.
The function is continuous and once-diÔ¨Äerentiable everywhere, and is therefore well behaved
for computational purposes.
<!--l. 15--><p class="indent" >  We now construct an upper-bound value function implied for a consumer whose spending
behavior is consistent with the reÔ¨Åned upper-bound consumption rule.
<!--l. 18--><p class="indent" >  For <img 
src="SolvingMicroDSOPs473x.svg" alt="        #
mt  ‚â• m t  " class="math";align="absmiddle">, this consumption rule is the same as before, so the constructed upper-bound
value function is also the same. However, for values <img 
src="SolvingMicroDSOPs474x.svg" alt="        #
mt  &#x003C; m t  " class="math";align="absmiddle"> matters are slightly more
complicated.
<!--l. 22--><p class="indent" >  Start with the fact that at the cusp point,
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs475x.svg" alt="    #           #    T
¬Øvt(mt ) = u(¬Øct(m t ))‚ÑÇt
       =  u(‚ñ¥m#  ¬ØŒ∫t)‚ÑÇT .
                t    t
" class="math-display" ></div>
  </td></tr></table>
<!--l. 27--><p class="nopar" >
<!--l. 29--><p class="indent" >  But for <span 
class="ecti-1200">all</span> <img 
src="SolvingMicroDSOPs476x.svg" alt="mt  " class="math";align="absmiddle">,
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs477x.svg" alt="¬Øvt(m ) = u(¬Øct(m )) + v¬Ø+t(m ‚àí ¬Øct(m )),
" class="math-display" ></div>
  </td></tr></table>
<!--l. 32--><p class="nopar" >
and we assume that for the consumer below the cusp point consumption is given by <img 
src="SolvingMicroDSOPs478x.svg" alt="¬ØŒ∫‚ñ¥m
     t  " class="math";align="absmiddle"> so
for <img 
src="SolvingMicroDSOPs479x.svg" alt="       #
mt &#x003C; m t  " class="math";align="absmiddle">
                                                                                     
                                                                                     
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs480x.svg" alt="¬Øv (m ) = u(¬ØŒ∫ ‚ñ¥m  ) + v¬Ø ((1 ‚àí ¬ØŒ∫ )‚ñ¥m ),
 t          t        +t       t
" class="math-display" ></div>
  </td></tr></table>
<!--l. 36--><p class="nopar" >
which is easy to compute because <img 
src="SolvingMicroDSOPs481x.svg" alt="v¬Ø+t(at) = Œ≤¬Øvt+1(at‚Ñõ + 1)  " class="math";align="absmiddle"> where <img 
src="SolvingMicroDSOPs482x.svg" alt="¬Øvt  " class="math";align="absmiddle"> is as deÔ¨Åned above
because a consumer who ends the current period with assets exceeding the lower bound will
not expect to be constrained next period. (Recall again that we are merely constructing an
object that is guaranteed to be an <span 
class="ecti-1200">upper bound </span>for the value that the ‚Äòrealist‚Äô consumer will
experience.) At the gridpoints deÔ¨Åned by the solution of the consumption problem can then
construct
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs483x.svg" alt="                       1‚àï(1‚àíœÅ)
¬ØŒõt(m ) = ((1 ‚àí œÅ)¬Øvt(m ))
" class="math-display" ></div>
  </td></tr></table>
<!--l. 43--><p class="nopar" >
and its derivatives which yields the appropriate vector for constructing <img 
src="SolvingMicroDSOPs484x.svg" alt="ÀáX  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs485x.svg" alt="Àáœò  " class="math";align="absmiddle">. The rest
of the procedure is analogous to that performed for the consumption rule and is thus omitted
for brevity.
<!--l. 1616--><p class="indent" >  <a 
 id="Extension-A-Stochastic-Interest-Factor"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.14  </span> <a 
 id="x1-210005.14"></a>Extension: A Stochastic Interest Factor</h4>
<!--l. 1620--><p class="noindent" >Thus far we have assumed that the interest factor is constant at <img 
src="SolvingMicroDSOPs486x.svg" alt="R  " class="math";align="absmiddle">. Extending the previous
derivations to allow for a perfectly forecastable time-varying interest factor <img 
src="SolvingMicroDSOPs487x.svg" alt="R
  t  " class="math";align="absmiddle"> would be
trivial. Allowing for a stochastic interest factor is less trivial.
                                                                                     
                                                                                     
<!--l. 1625--><p class="indent" >  The easiest case is where the interest factor is i.i.d.,
  <table 
class="equation"><tr><td><a 
 id="x1-21001r55"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs488x.svg" alt="                        2     2
log Rt+n ‚àº   ùí© (r + œï ‚àí œÉr‚àï2,œÉr) ‚àÄ n &#x003E; 0
" class="math-display" ></div>
  </td><td class="equation-label">(55)</td></tr></table>
<!--l. 3--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs489x.svg" alt="œï  " class="math";align="absmiddle"> is the risk premium and the <img 
src="SolvingMicroDSOPs490x.svg" alt=" 2
œÉr‚àï2  " class="math";align="absmiddle"> adjustment to the mean log return guarantees
that an increase in <img 
src="SolvingMicroDSOPs491x.svg" alt="œÉ2r  " class="math";align="absmiddle"> constitutes a mean-preserving spread in the level of the
return.
<!--l. 1635--><p class="indent" >  This case is reasonably straightforward because <a 
href="#Xmerton:restat">Merton</a>¬†(<a 
href="#Xmerton:restat">1969</a>) and <a 
href="#Xsamuelson:portfolio">Samuelson</a>¬†(<a 
href="#Xsamuelson:portfolio">1969</a>)
showed that for a consumer without labor income (or with perfectly forecastable
labor income) the consumption function is linear, with an inÔ¨Ånite-horizon
MPC<span class="footnote-mark"><a 
href="SolvingMicroDSOPs15.html#fn14x0"><sup class="textsuperscript">14</sup></a></span><a 
 id="x1-21002f14"></a>  
  <table 
class="equation"><tr><td><a 
 id="x1-21003r56"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs492x.svg" alt="        (          )1‚àïœÅ
Œ∫ = 1 ‚àí  Œ≤ ùîºt[R1t+‚àí1œÅ]
" class="math-display" ></div>
  </td><td class="equation-label">(56)</td></tr></table>
<!--l. 1640--><p class="nopar" >
and in this case the previous analysis applies once we substitute this MPC for the one that
characterizes the perfect foresight problem without rate-of-return risk.
<!--l. 1644--><p class="indent" >  The more realistic case where the interest factor has some serial correlation is more
complex. We consider the simplest case that captures the main features of empirical interest
rate dynamics: An AR(1) process. Thus the speciÔ¨Åcation is
                                                                                     
                                                                                     
  <table 
class="equation"><tr><td><a 
 id="x1-21004r57"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs493x.svg" alt="r   ‚àí r = (r  ‚àí r)Œ≥ + ùúñ
 t+1         t          t+1
" class="math-display" ></div>
  </td><td class="equation-label">(57)</td></tr></table>
<!--l. 1649--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs494x.svg" alt="r  " class="math";align="absmiddle"> is the long-run mean log interest factor, <img 
src="SolvingMicroDSOPs495x.svg" alt="0 &#x003C;  Œ≥ &#x003C; 1  " class="math";align="absmiddle"> is the AR(1) serial correlation
coeÔ¨Écient, and <img 
src="SolvingMicroDSOPs496x.svg" alt="ùúñt+1   " class="math";align="absmiddle"> is the stochastic shock.
<!--l. 1653--><p class="indent" >  The consumer‚Äôs problem in this case now has two state variables, <img 
src="SolvingMicroDSOPs497x.svg" alt="mt  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs498x.svg" alt="rt  " class="math";align="absmiddle">, and is
described by
  <table 
class="equation"><tr><td><a 
 id="x1-21005r58"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs499x.svg" alt="v (m  ,r ) = max  u(c ) + ùîº [Œ≤   ùí¢1‚àí œÅv   (m    ,r   )]
 t  t  t     ct     t     t t+1  t+1  t+1   t+1  t+1
         s.t.

       at = mt ‚àí ct
 rt+1 ‚àí r = (rt ‚àí r)Œ≥ + ùúñt+1

    Rt+1 =  exp(rt+1)
    mt+1 =  (Rt+1‚àïùí¢t+1) at + ùúÉùúÉùúÉt+1.
            ‚óü---‚óù‚óú----‚óû
               ‚â°‚Ñõt+1
" class="math-display" ><a 
 id="x1-21005r57"></a></div>
  </td></tr></table>
<!--l. 1663--><p class="nopar" >
<!--l. 1668--><p class="indent" >  We approximate the AR(1) process by a Markov transition matrix using standard
techniques. The stochastic interest factor is allowed to take on 11 values centered around the
steady-state value <img 
src="SolvingMicroDSOPs500x.svg" alt="r  " class="math";align="absmiddle">. Given this Markov transition matrix, <span 
class="ecti-1200">conditional </span>on the Markov AR(1)
state the consumption functions for the ‚Äòoptimist‚Äô and the ‚Äòpessimist‚Äô will still be linear, with
                                                                                     
                                                                                     
identical MPC‚Äôs that are computed numerically. Given these MPC‚Äôs, the (conditional) realist‚Äôs
consumption function can be computed for each Markov state, and the converged consumption
rules constitute the solution contingent on the dynamics of the stochastic interest rate
process.
<!--l. 1674--><p class="indent" >  In principle, this reÔ¨Ånement should be combined with the previous one; further exposition of
this combination is omitted here because no new insights spring from the combination of the
two techniques.
<!--l. 1680--><p class="indent" >  <a 
 id="Imposing-Artificial-Borrowing-Constraints"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.15  </span> <a 
 id="x1-220005.15"></a>Imposing ‚ÄòArtiÔ¨Åcial‚Äô Borrowing Constraints</h4>
<!--l. 1683--><p class="noindent" >Optimization problems often come with additional constraints that must
be satisÔ¨Åed. Particularly common is an ‚ÄòartiÔ¨Åcial‚Äô liquidity constraint that
prevents the consumer‚Äôs net worth from falling below some value, often
zero.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs16.html#fn15x0"><sup class="textsuperscript">15</sup></a></span><a 
 id="x1-22001f15"></a>  
The problem then becomes
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs501x.svg" alt="vT‚àí1(mT ‚àí1) = max   u(cT‚àí 1) + ùîºT ‚àí1[Œ≤ùí¢1T‚àí œÅvT(mT )]
              cT‚àí1
           s.t.

       aT‚àí1 = mT ‚àí1 ‚àí cT‚àí 1
        mT  = ‚ÑõT aT ‚àí1 + ùúÉùúÉùúÉT
       a    ‚â• 0.
        T‚àí1
" class="math-display" ><a 
 id="x1-220005.15"></a></div>
  </td></tr></table>
<!--l. 1695--><p class="nopar" >
<!--l. 1699--><p class="indent" >  By deÔ¨Ånition, the constraint will bind if the unconstrained consumer would choose a level of
spending that would violate the constraint. Here, that means that the constraint binds if the
<img 
src="SolvingMicroDSOPs502x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> that satisÔ¨Åes the unconstrained FOC
                                                                                     
                                                                                     
  <table 
class="equation"><tr><td><a 
 id="x1-22002r58"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs503x.svg" alt="c‚àíœÅ  = va +  (m     ‚àí c   )
 T‚àí1     T ‚àí1   T‚àí1    T‚àí1
" class="math-display" ></div>
  </td><td class="equation-label">(58)</td></tr></table>
<!--l. 1705--><p class="nopar" >
is greater than <img 
src="SolvingMicroDSOPs504x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle">. Call <img 
src="SolvingMicroDSOPs505x.svg" alt="`c‚àó
 T‚àí1   " class="math";align="absmiddle"> the approximated function returning the level of <img 
src="SolvingMicroDSOPs506x.svg" alt="cT‚àí 1   " class="math";align="absmiddle"> that
satisÔ¨Åes (<a 
href="#x1-22002r58">58<!--tex4ht:ref: eq:cUnc --></a>). Then the approximated constrained optimal consumption function will be
  <table 
class="equation"><tr><td><a 
 id="x1-22003r59"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs507x.svg" alt="                          ‚àó
`cT‚àí1(mT ‚àí1) = min [mT ‚àí1,`cT‚àí1(mT ‚àí1)].
" class="math-display" ></div>
  </td><td class="equation-label">(59)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 1721--><p class="indent" >  The introduction of the constraint also introduces a sharp nonlinearity in all of the
functions at the point where the constraint begins to bind. As a result, to get solutions that
are anywhere close to numerically accurate it is useful to augment the grid of values of the
state variable to include the exact value at which the constraint ceases to bind. Fortunately,
this is easy to calculate. We know that when the constraint is binding the consumer is saving
nothing, which yields marginal value of <img 
src="SolvingMicroDSOPs508x.svg" alt=" a
vT+‚àí 1(0)  " class="math";align="absmiddle">. Further, when the constraint
is binding, <img 
src="SolvingMicroDSOPs509x.svg" alt="cT‚àí 1 = mT ‚àí1   " class="math";align="absmiddle">. Thus, the largest value of consumption for which the
constraint is binding will be the point for which the marginal utility of consumption is
exactly equal to the (expected, discounted) marginal value of saving 0. We know this
because the marginal utility of consumption is a downward-sloping function and
so if the consumer were to consume <img 
src="SolvingMicroDSOPs510x.svg" alt="ùúñ  " class="math";align="absmiddle"> more, the marginal utility of that extra
                                                                                     
                                                                                     
consumption would be <span 
class="ecti-1200">below </span>the (discounted, expected) marginal utility of saving, and
thus the consumer would engage in positive saving and the constraint would no
longer be binding. Thus the level of <img 
src="SolvingMicroDSOPs511x.svg" alt="mT ‚àí 1   " class="math";align="absmiddle"> at which the constraint stops binding
is:<span class="footnote-mark"><a 
href="SolvingMicroDSOPs17.html#fn16x0"><sup class="textsuperscript">16</sup></a></span><a 
 id="x1-22004f16"></a>  
  <table 
class="equation"><tr><td><a 
 id="x1-22005r60"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs512x.svg" alt=" c           a
u (mT ‚àí1) = vT+‚àí 1(0 )
    m     = (va   (0))(‚àí1‚àïœÅ)
      T‚àí1     T+‚àí 1
          = cT+‚àí 1(0).
" class="math-display" ><a 
 id="x1-22005r59"></a></div>
  </td></tr></table>
<!--l. 1744--><p class="nopar" >
<!--l. 1746--><p class="indent" >  <a 
 id="cVScCon"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-2200618"></a>
                                                                                     
                                                                                     
<!--l. 1748--><p class="noindent" > <img 
src="./Figures/cVScCon.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†18:</span><span  
class="content">Constrained (solid) and Unconstrained (dashed) Consumption</span></figcaption><!--tex4ht:label?: x1-2200618 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1753--><p class="indent" >  The constrained problem is solved in section ‚ÄúArtiÔ¨Åcal Borrowing Constraint‚Äù of the
notebook, where the variable <span 
class="ectt-1200">constrained </span>is set to be a boolean type object. If the value of
<span 
class="ectt-1200">constrained </span>is true, then the constraint is binding and their consumption behavior is
computed to match (<a 
href="#x1-22003r59">59<!--tex4ht:ref: eq:LiqCons --></a>). The resulting consumption rule is shown in Figure <a 
href="#x1-2200618">18<!--tex4ht:ref: fig:cVScCon --></a>. For
comparison purposes, the approximate consumption rule from Figure <a 
href="#x1-2200618">18<!--tex4ht:ref: fig:cVScCon --></a> is reproduced here as
the solid line; this is accomplished by setting the boolean value of <span 
class="ectt-1200">constrained </span>to
false.
<!--l. 1762--><p class="indent" >  The presence of the liquidity constraint requires three changes to the procedures outlined
above:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-22008x1">We redeÔ¨Åne <img 
src="SolvingMicroDSOPs513x.svg" alt="ùî•t  " class="math";align="absmiddle">, which now is the PDV of receiving <img 
src="SolvingMicroDSOPs514x.svg" alt="ùúÉùúÉùúÉt+1 = ùúÉùúÉùúÉ-  " class="math";align="absmiddle"> next period and
      <img 
src="SolvingMicroDSOPs515x.svg" alt="ùúÉùúÉùúÉt+n = 0 ‚àÄ n &#x003E; 1  " class="math";align="absmiddle"> ‚Äì that is, the pessimist believes he will receive nothing beyond
      period <img 
src="SolvingMicroDSOPs516x.svg" alt="t + 1  " class="math";align="absmiddle">
      </li>
      <li 
  class="enumerate" id="x1-22010x2">We augment the end-of-period <span 
class="ectt-1200">aVec </span>with zero and with a point with a small
      positive value so that the generated <span 
class="ectt-1200">mVec </span>will the binding point <img 
src="SolvingMicroDSOPs517x.svg" alt="  #
m   " class="math";align="absmiddle"> and a point
      just above it (so that we can better capture the curvature around that point)
      </li>
      <li 
  class="enumerate" id="x1-22012x3">We redeÔ¨Åne the optimal consumption rule as in equation (<a 
href="#x1-22003r59">59<!--tex4ht:ref: eq:LiqCons --></a>). This ensures that
      the liquidity-constrained ‚Äòrealist‚Äô will consume more than the redeÔ¨Åned ‚Äòpessimist,‚Äô
      so that we will have <img 
src="SolvingMicroDSOPs518x.svg" alt="œô  " class="math";align="absmiddle"> still between <img 
src="SolvingMicroDSOPs519x.svg" alt="0  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs520x.svg" alt="1  " class="math";align="absmiddle"> and the ‚Äòmethod of moderation‚Äô
      will proceed smoothly.</li></ol>
<!--l. 1780--><p class="indent" >  As expected, the liquidity constraint only causes a divergence between the two functions at
the point where the optimal unconstrained consumption rule runs into the 45 degree
line.
<!--l. 1785--><p class="indent" >  <a 
 id="Recursions"></a>
  <h3 class="sectionHead"><span class="titlemark">6  </span> <a 
 id="x1-230006"></a>Recursion</h3>
<!--l. 1787--><p class="noindent" ><a 
 id="Theory"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.1  </span> <a 
 id="x1-240006.1"></a>Theory</h4>
<!--l. 1789--><p class="noindent" >Before we solve for periods earlier than <img 
src="SolvingMicroDSOPs521x.svg" alt="T ‚àí  1  " class="math";align="absmiddle">, we assume for convenience that in each such
period a liquidity constraint exists of the kind discussed above, preventing <img 
src="SolvingMicroDSOPs522x.svg" alt="c  " class="math";align="absmiddle"> from exceeding
<img 
src="SolvingMicroDSOPs523x.svg" alt="m  " class="math";align="absmiddle">. This simpliÔ¨Åes things a bit because now we can always consider an <span 
class="ectt-1200">aVec </span>that starts with
zero as its smallest element.
<!--l. 1795--><p class="indent" >  Recall now equations¬†(<a 
href="#x1-4011r20">20<!--tex4ht:ref: eq:vEndPrimetOfc --></a>) and (<a 
href="#x1-4012r21">21<!--tex4ht:ref: eq:upEqbetaOp --></a>):
  <table 
class="equation-star"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs524x.svg" alt="va (a ) = ùîº [Œ≤R ùí¢‚àíœÅ uc(c  (‚Ñõ    a + ùúÉùúÉùúÉ  ))]
 +tc t     ‚Ä≤t    t+1    t+1   t+1 t    t+1
  u (ct) = v+t(mt ‚àí ct).
" class="math-display" ></div>
  </td></tr></table>
<!--l. 1800--><p class="nopar" >
Assuming that the problem has been solved up to period <img 
src="SolvingMicroDSOPs525x.svg" alt="t + 1  " class="math";align="absmiddle"> (and thus assuming that we
have an approximated <img 
src="SolvingMicroDSOPs526x.svg" alt="`ct+1 (mt+1 )  " class="math";align="absmiddle">), our solution method essentially involves using
these two equations in succession to work back progressively from period <img 
src="SolvingMicroDSOPs527x.svg" alt="T ‚àí 1  " class="math";align="absmiddle"> to
the beginning of life. Stated generally, the method is as follows. (Here, we use the
original, rather than the ‚ÄúreÔ¨Åned,‚Äù method for constructing consumption functions;
the generalization of the algorithm below to use the reÔ¨Åned method presents no
diÔ¨Éculties.)
<!--l. 1809--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-24002x1">For the grid of values <img 
src="SolvingMicroDSOPs528x.svg" alt="at,i  " class="math";align="absmiddle"> in <span 
class="ectt-1200">aVec_eee</span>, numerically calculate the values of <img 
src="SolvingMicroDSOPs529x.svg" alt="ct(at,i)  " class="math";align="absmiddle"> and
      <img 
src="SolvingMicroDSOPs530x.svg" alt="ca(a  )
 t  t,i  " class="math";align="absmiddle">,
      <table 
class="equation"><tr><td><a 
 id="x1-24003r60"></a>
<div class="math-display" >
<img 
src="SolvingMicroDSOPs531x.svg" alt="     (        )
ct,i = v+‚Ä≤t(at,i) ‚àí1‚àïœÅ,
     (     [   ‚àíœÅ                        ])‚àí1‚àïœÅ
   =  Œ≤ ùîºt  Rùí¢t+1(`ct+1(‚Ñõt+1at,i + ùúÉùúÉùúÉt+1))‚àíœÅ     ,
 a           ( ‚Ä≤     )‚àí 1‚àí 1‚àïœÅ  ‚Ä≤‚Ä≤
ct,i = ‚àí (1‚àïœÅ) v+t(at,i)        v+t(at,i),
" class="math-display" ></div>
      </td><td class="equation-label">(60)</td></tr></table>
      <!--l. 5--><p class="nopar" >
      <!--l. 1824--><p class="noindent" >generating vectors of values <img 
src="SolvingMicroDSOPs532x.svg" alt="‚Éóc
  t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs533x.svg" alt="‚Éóca
 t  " class="math";align="absmiddle">.
                                                                                     
                                                                                     
      </li>
      <li 
  class="enumerate" id="x1-24005x2">Construct a corresponding vector of values of <img 
src="SolvingMicroDSOPs534x.svg" alt="‚Éómt =  ‚Éóct + ‚Éóat  " class="math";align="absmiddle">; similarly construct a
      corresponding list of MPC‚Äôs <img 
src="SolvingMicroDSOPs535x.svg" alt="‚ÉóŒ∫t  " class="math";align="absmiddle"> using equation (<a 
href="#x1-18005r45">45<!--tex4ht:ref: eq:MPCfromMPTHC --></a>).
      </li>
      <li 
  class="enumerate" id="x1-24007x3">Construct a corresponding vector <img 
src="SolvingMicroDSOPs536x.svg" alt="‚ÉóŒºt  " class="math";align="absmiddle">, the levels and Ô¨Årst derivatives of <img 
src="SolvingMicroDSOPs537x.svg" alt="‚Éóœôt  " class="math";align="absmiddle">, and the
      levels and Ô¨Årst derivatives of <img 
src="SolvingMicroDSOPs538x.svg" alt="œá‚Éót  " class="math";align="absmiddle">.
      </li>
      <li 
  class="enumerate" id="x1-24009x4">Construct an interpolating approximation <img 
src="SolvingMicroDSOPs539x.svg" alt="œá`t  " class="math";align="absmiddle"> that smoothly matches both the level and
      the slope at those points.
      </li>
      <li 
  class="enumerate" id="x1-24011x5">If we are to approximate the value function, construct a corresponding list of values of
      <img 
src="SolvingMicroDSOPs540x.svg" alt="‚Éóvt  " class="math";align="absmiddle">, the levels and Ô¨Årst derivatives of <img 
src="SolvingMicroDSOPs541x.svg" alt="‚Éóœòt  " class="math";align="absmiddle">, and the levels and Ô¨Årst derivatives of <img 
src="SolvingMicroDSOPs542x.svg" alt="ÀÜ
‚ÉóXt  " class="math";align="absmiddle">;
      and construct an interpolating approximation function <img 
src="SolvingMicroDSOPs543x.svg" alt="XÀÜt  " class="math";align="absmiddle"> that matches those
      points.</li></ol>
<!--l. 1835--><p class="indent" >  With <img 
src="SolvingMicroDSOPs544x.svg" alt="œá`
  t  " class="math";align="absmiddle"> in hand, our approximate consumption function is computed directly from the
appropriate substitutions in (<a 
href="#x1-17007r40">40<!--tex4ht:ref: eq:cFuncHi --></a>) and related equations. With this consumption rule in hand,
we can continue the backwards recursion to period <img 
src="SolvingMicroDSOPs545x.svg" alt="t ‚àí 1  " class="math";align="absmiddle"> and so on back to the beginning of
life.
<!--l. 1841--><p class="indent" >  Note that this loop does not contain an item for constructing <img 
src="SolvingMicroDSOPs546x.svg" alt="ÀÜv‚Ä≤t(mt)  " class="math";align="absmiddle">. This is because with
<img 
src="SolvingMicroDSOPs547x.svg" alt="`ÀÜc (m )
 t   t  " class="math";align="absmiddle"> in hand, we simply <span 
class="ecti-1200">deÔ¨Åne</span> <img 
src="SolvingMicroDSOPs548x.svg" alt="ÀÜvm (m  ) = uc(`ÀÜc (m  ))
  t   t       t   t  " class="math";align="absmiddle"> so there is no need to construct
interpolating approximations - the function arises ‚Äòfree‚Äô (or nearly so) from our constructed
<img 
src="SolvingMicroDSOPs549x.svg" alt="`ÀÜct(mt)  " class="math";align="absmiddle"> via the usual envelope result (cf.¬†(<a 
href="#x1-4002r11">11<!--tex4ht:ref: eq:envelope --></a>)).
<!--l. 1843--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">6.2  </span> <a 
 id="x1-250006.2"></a>Program Structure</h4>
<!--l. 1845--><p class="noindent" >In section ‚ÄúSolve for <img 
src="SolvingMicroDSOPs550x.svg" alt="ct(mt )  " class="math";align="absmiddle"> in Multiple Periods‚Äù, the natural and artiÔ¨Åcial borrowing
constraints are combined with the endogenous gridpoints method to approximate the optimal
consumption function for a speciÔ¨Åc period. Then, this function is used to compute the
approximated consumption in the previous period, and this process is repeated for the number
of periods speciÔ¨Åed by <span 
class="ectt-1200">T</span>, as explained earlier.
<!--l. 1847--><p class="indent" >  The essential structure of the program is a loop that iteratively solves for consumption
functions by working backward from an assumed Ô¨Ånal period, using the dictionary
<span 
class="ectt-1200">cFunc_life </span>to store the interpolated consumption functions up to the beginning period.
Consumption in a given period is utilized to determine the endogenous gridpoints for the
preceding period. This is the sense in which the computation of optimal consumption is done
recursively.
<!--l. 1849--><p class="indent" >  For a realistic life cycle problem, it would also be necessary at a minimum to calibrate a
nonconstant path of expected income growth over the lifetime that matches the empirical
                                                                                     
                                                                                     
proÔ¨Åle; allowing for such a calibration is the reason we have included the <img 
src="SolvingMicroDSOPs551x.svg" alt="    T
{ùí¢ }t  " class="math";align="absmiddle"> vector in our
computational speciÔ¨Åcation of the problem.
<!--l. 1855--><p class="indent" >  <a 
 id="Results"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.3  </span> <a 
 id="x1-260006.3"></a>Results</h4>
<!--l. 1858--><p class="noindent" >As suggested, the code creates the relevant <img 
src="SolvingMicroDSOPs552x.svg" alt="`ct(mt )  " class="math";align="absmiddle"> functions for any period in the horizon
speciÔ¨Åed by the variable <span 
class="ectt-1200">T</span>, at the given values of <img 
src="SolvingMicroDSOPs553x.svg" alt="m  " class="math";align="absmiddle">. Figure <a 
href="#x1-2600119">19<!--tex4ht:ref: fig:PlotCFuncsConverge --></a> shows <img 
src="SolvingMicroDSOPs554x.svg" alt="`cT ‚àín(m )  " class="math";align="absmiddle"> for
<img 
src="SolvingMicroDSOPs555x.svg" alt="n =  {20,15,10,5, 1} " class="math";align="absmiddle">. At least one feature of this Ô¨Ågure is encouraging: the consumption
functions converge as the horizon extends, something that <span 
class="ecbx-1200">? </span>shows must be true under certain
parametric conditions that are satisÔ¨Åed by the baseline parameter values being used
here.
<!--l. 1868--><p class="indent" >  <a 
 id="PlotCFuncsConverge"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-2600119"></a>
                                                                                     
                                                                                     
<!--l. 1870--><p class="noindent" > <img 
src="./Figures/PlotCFuncsConverge.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†19:</span><span  
class="content">Converging <img 
src="SolvingMicroDSOPs556x.svg" alt="`cT ‚àín(m )  " class="math";align="absmiddle"> Functions as <img 
src="SolvingMicroDSOPs557x.svg" alt="n  " class="math";align="absmiddle"> Increases</span></figcaption><!--tex4ht:label?: x1-2600119 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2387--><p class="indent" >  <a 
 id="Multiple-Control-Variables"></a>
  <h3 class="sectionHead"><span class="titlemark">7  </span> <a 
 id="x1-270007"></a>Multiple Control Variables</h3>
<!--l. 2390--><p class="noindent" >We now consider how to solve problems with multiple control variables. (To reduce notational
complexity, in this section we set <img 
src="SolvingMicroDSOPs558x.svg" alt="ùí¢t = 1 ‚àÄ t  " class="math";align="absmiddle">.)
<!--l. 2393--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">7.1  </span> <a 
 id="x1-280007.1"></a>Theory</h4>
<!--l. 2394--><p class="noindent" >The new control variable that the consumer can now choose is the portion of the
portfolio to invest in risky assets. Designating the gross return on the risky asset
as <img 
src="SolvingMicroDSOPs559x.svg" alt="R
  t+1   " class="math";align="absmiddle">, and using <img 
src="SolvingMicroDSOPs560x.svg" alt="œÇ
 t  " class="math";align="absmiddle"> to represent the proportion of the portfolio invested in
this asset before the return is realized after the beginning of <img 
src="SolvingMicroDSOPs561x.svg" alt="t + 1  " class="math";align="absmiddle">, corresponding
to an assumption that the consumer cannot be ‚Äònet short‚Äô and cannot issue net
equity), the overall return on the consumer‚Äôs portfolio between <img 
src="SolvingMicroDSOPs562x.svg" alt="t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs563x.svg" alt="t + 1  " class="math";align="absmiddle"> will be:
  <table 
class="equation"><tr><td><a 
 id="x1-28001r61"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs564x.svg" alt="‚Ñút+1 =  R(1 ‚àí œÇt) + Rt+1 œÇt
     =  R + (R    ‚àí R )œÇ
               t+1      t
" class="math-display" ></div>
  </td><td class="equation-label">(61)</td></tr></table>
<!--l. 4--><p class="nopar" >
and the maximization problem is
  <table 
class="equation-star"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs565x.svg" alt="v (m  ) = max   u(c ) + Œ≤ ùîº [v  (m   )]
 t   t   {ct,œÇt}     t       t t+1   t+1

      s.t.
  ‚Ñút+1 = R +  (Rt+1  ‚àí R)œÇt
  m    = (m  ‚àí  c)‚Ñú    +  ùúÉùúÉùúÉ
    t+1      t    t  t+1    t+1
   0 ‚â§œÇt ‚â§ 1,
" class="math-display" ><a 
 id="x1-280007.1"></a></div>
  </td></tr></table>
<!--l. 8--><p class="nopar" >
or, more compactly,
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs566x.svg" alt="vt(mt ) = max   u (ct) + ùîºt[Œ≤vt+1((mt ‚àí ct)‚Ñút+1 + ùúÉùúÉùúÉt+1)]
         {ct,œÇt}
      s.t.

  0 ‚â§ œÇt ‚â§ 1.
" class="math-display" ></div>
  </td></tr></table>
<!--l. 2420--><p class="nopar" >
The Ô¨Årst order condition with respect to <img 
src="SolvingMicroDSOPs567x.svg" alt="ct  " class="math";align="absmiddle"> is almost identical to that in the single-control
problem, equation (<a 
href="#x1-4001r10">10<!--tex4ht:ref: eq:upceqEvtp1 --></a>), with the only diÔ¨Äerence being that the nonstochastic interest factor
<img 
src="SolvingMicroDSOPs568x.svg" alt="R  " class="math";align="absmiddle"> is now replaced by <img 
src="SolvingMicroDSOPs569x.svg" alt="‚Ñú
  t+1   " class="math";align="absmiddle">,
  <table 
class="equation"><tr><td><a 
 id="x1-28002r62"></a>
  <div class="math-display" >
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs570x.svg" alt=" c                 m
u (ct) = Œ≤ ùîºt[‚Ñút+1v t+1 (mt+1 )],
" class="math-display" ></div>
  </td><td class="equation-label">(62)</td></tr></table>
<!--l. 3--><p class="nopar" >
and the Envelope theorem derivation remains the same, yielding the Euler equation for
consumption
  <table 
class="equation"><tr><td><a 
 id="x1-28003r63"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs571x.svg" alt=" c                c
u (ct) = ùîºt[Œ≤‚Ñút+1u  (ct+1)].
" class="math-display" ></div>
  </td><td class="equation-label">(63)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 2440--><p class="indent" >  The Ô¨Årst order condition with respect to the risky portfolio share is
  <table 
class="equation"><tr><td><a 
 id="x1-28004r64"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs572x.svg" alt="        m
0 = ùîºt [vt+1(mt+1 )(Rt+1  ‚àí R)at]
  = at ùîºt[uc(ct+1(mt+1)) (Rt+1  ‚àí R)].
" class="math-display" ><a 
 id="x1-28004r63"></a></div>
  </td></tr></table>
<!--l. 4--><p class="nopar" >
                                                                                     
                                                                                     
<!--l. 2449--><p class="indent" >  As before, it will be useful to deÔ¨Åne <img 
src="SolvingMicroDSOPs573x.svg" alt="v+t  " class="math";align="absmiddle"> as a function that yields the expected <img 
src="SolvingMicroDSOPs574x.svg" alt="t + 1  " class="math";align="absmiddle"> value
of ending period <img 
src="SolvingMicroDSOPs575x.svg" alt="t  " class="math";align="absmiddle"> in a given state. However, now that there are two control variables, the
expectation must be deÔ¨Åned as a function of the chosen values of both of those variables,
because expected end-of-period value will depend not just on how much the agent saves, but
also on how the saved assets are allocated between the risky and riskless assets. Thus we
deÔ¨Åne
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs576x.svg" alt="v+t(at,œÇt) = ùîºt[Œ≤vt+1(mt+1 )]
" class="math-display" ></div>
  </td></tr></table>
<!--l. 2458--><p class="nopar" >
which has derivatives
  <table 
class="equation"><tr><td><a 
 id="x1-28005r64"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs577x.svg" alt="  a              m                      c
v +t = ùîºt[Œ≤ ‚Ñút+1v t+1(mt+1 )] = ùîºt [Œ≤ ‚Ñút+1u t+1(ct+1(mt+1 ))]
v œÇ+t = ùîºt[Œ≤ (Rt+1 ‚àí R )vmt+1(mt+1 )]at = ùîºt [Œ≤ (Rt+1  ‚àí R)uct+1(ct+1(mt+1))]at
" class="math-display" ></div>
  </td></tr></table>
<!--l. 2463--><p class="nopar" >
implying that the Ô¨Årst order conditions (<a 
href="#x1-28003r63">63<!--tex4ht:ref: eq:EulercRiskyR --></a>) and (<a 
href="#x1-28004r63">64<!--tex4ht:ref: eq:FOCw --></a>) can be rewritten
  <table 
class="equation"><tr><td><a 
 id="x1-28006r64"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs578x.svg" alt="uc(ct) = va (mt ‚àí ct,œÇt)
          +œÇt
    0 =  vt(at,œÇt).
" class="math-display" ></div>
  </td><td class="equation-label">(64)</td></tr></table>
<!--l. 2469--><p class="nopar" >
<!--l. 2471--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">7.2  </span> <a 
 id="x1-290007.2"></a>Application</h4>
<!--l. 2473--><p class="noindent" >Our Ô¨Årst step is to specify the stochastic process for <img 
src="SolvingMicroDSOPs579x.svg" alt="Rt+1   " class="math";align="absmiddle">. We follow the common practice of
assuming that returns are lognormally distributed, <img 
src="SolvingMicroDSOPs580x.svg" alt="log R ‚àº ùí©  (œï + r ‚àí œÉ2œï ‚àï2,œÉ2œï)  " class="math";align="absmiddle">
where <img 
src="SolvingMicroDSOPs581x.svg" alt="œï  " class="math";align="absmiddle"> is the equity premium over the returns <img 
src="SolvingMicroDSOPs582x.svg" alt="r  " class="math";align="absmiddle"> available on the riskless
asset.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs18.html#fn17x0"><sup class="textsuperscript">17</sup></a></span><a 
 id="x1-29001f17"></a>  
<!--l. 2479--><p class="indent" >  As with labor income uncertainty, it is necessary to discretize the rate-of-return risk in order
to have a problem that is soluble in a reasonable amount of time. We follow the same
procedure as for labor income uncertainty, generating a set of <img 
src="SolvingMicroDSOPs585x.svg" alt="nr  " class="math";align="absmiddle"> equiprobable shocks to the
rate of return; in a slight abuse of notation, we will designate the portfolio-weighted return
(contingent on the chosen portfolio share in equity, and potentially contingent on any other
aspect of the consumer‚Äôs problem) simply as <img 
src="SolvingMicroDSOPs586x.svg" alt="‚Ñúi,j  " class="math";align="absmiddle"> (where dependence on <img 
src="SolvingMicroDSOPs587x.svg" alt="i  " class="math";align="absmiddle"> is allowed to
permit the possibility of nonzero correlation between the return on the risky asset and the
shock to labor income (for example, in recessions the stock market falls and labor income also
declines).
<!--l. 2491--><p class="indent" >  The direct expressions for the derivatives of <img 
src="SolvingMicroDSOPs588x.svg" alt="v
 +t  " class="math";align="absmiddle"> are
  <table 
class="equation"><tr><td><a 
 id="x1-29002r65"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs589x.svg" alt="              (      )  n   n
  a             --1--  ‚àë ùúÉùúÉùúÉ ‚àë r                      ‚àíœÅ
v +t(at,œÇt) = Œ≤  n  n          ‚Ñúi,j (ct+1(‚Ñúi,jat + ùúÉùúÉùúÉi))
                  r ùúÉùúÉùúÉ  i=1 j=1
              (   1  ) ‚àënùúÉùúÉùúÉ ‚àënr
v œÇ+t(at,œÇt) = Œ≤  -----         (Ri,j ‚àí R )(ct+1(‚Ñúi,jat + ùúÉùúÉùúÉi))‚àí œÅ.
                nrn ùúÉùúÉùúÉ  i=1 j=1
" class="math-display" ></div>
                                                                                     
                                                                                     
  </td><td class="equation-label">(65)</td></tr></table>
<!--l. 2495--><p class="nopar" >
<!--l. 2497--><p class="indent" >  Writing these equations out explicitly makes a problem very apparent: For every diÔ¨Äerent
combination of <img 
src="SolvingMicroDSOPs590x.svg" alt="{at,œÇt} " class="math";align="absmiddle"> that the routine wishes to consider, it must perform two
double-summations of <img 
src="SolvingMicroDSOPs591x.svg" alt="nr √ó n  " class="math";align="absmiddle"> terms. Once again, there is an ineÔ¨Éciency if it must perform
these same calculations many times for the same or nearby values of <img 
src="SolvingMicroDSOPs592x.svg" alt="{at,œÇt} " class="math";align="absmiddle">, and
again the solution is to construct an approximation to the derivatives of the <img 
src="SolvingMicroDSOPs593x.svg" alt="v+t  " class="math";align="absmiddle">
function.
<!--l. 2506--><p class="indent" >  Details of the construction of the interpolating approximation are given below; assume for
the moment that we have the approximations <img 
src="SolvingMicroDSOPs594x.svg" alt="vÀÜ+ta  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs595x.svg" alt="vÀÜ+t œÇ  " class="math";align="absmiddle"> in hand and we want to
proceed. As noted above, nonlinear equation solvers can Ô¨Ånd the solution to a set of
simultaneous equations. Thus we could ask Python to solve
  <table 
class="equation"><tr><td><a 
 id="x1-29003r66"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs596x.svg" alt=" ‚àíœÅ    a
ct  = ÀÜvt(mt ‚àí ct,œÇt)
  0 = ÀÜvœÇ(mt ‚àí ct,œÇt)
       t
" class="math-display" ></div>
  </td><td class="equation-label">(66)</td></tr></table>
<!--l. 2516--><p class="nopar" >
simultaneously for <img 
src="SolvingMicroDSOPs597x.svg" alt="c  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs598x.svg" alt="œÇ  " class="math";align="absmiddle"> at the set of potential <img 
src="SolvingMicroDSOPs599x.svg" alt="m
  t  " class="math";align="absmiddle"> values deÔ¨Åned in <span 
class="ectt-1200">mVec</span>. However,
multidimensional constrained maximization problems are diÔ¨Écult and sometimes quite slow to
solve. There is a better way. DeÔ¨Åne the problem
  <table 
class="equation"><tr><td><a 
 id="x1-29004r67"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs600x.svg" alt="Àúv-(a ) = max   v  (a ,œÇ )
 t  t     œÇt    +t  t  t
     s.t.

  0 ‚â§ œÇt ‚â§ 1
" class="math-display" ></div>
                                                                                     
                                                                                     
  </td></tr></table>
<!--l. 2529--><p class="nopar" >
where the tilde over <img 
src="SolvingMicroDSOPs601x.svg" alt="Àúv (a )  " class="math";align="absmiddle"> indicates that this is the <img 
src="SolvingMicroDSOPs602x.svg" alt="v  " class="math";align="absmiddle"> that has been optimized with respect
to all of the arguments other than the one still present (<img 
src="SolvingMicroDSOPs603x.svg" alt="a
 t  " class="math";align="absmiddle">). We solve this problem for the set
of gridpoints in <span 
class="ectt-1200">aVec </span>and use the results to construct the interpolating function
<img 
src="SolvingMicroDSOPs604x.svg" alt=" a
`Àúvt(at)  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs19.html#fn18x0"><sup class="textsuperscript">18</sup></a></span><a 
 id="x1-29005f18"></a>  
With this function in hand, we can use the Ô¨Årst order condition from the single-control
problem
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs607x.svg" alt="c‚àítœÅ = `Àúvat(mt ‚àí  ct)
" class="math-display" ></div>
  </td></tr></table>
<!--l. 2545--><p class="nopar" >
to solve for the optimal level of consumption as a function of <img 
src="SolvingMicroDSOPs608x.svg" alt="mt  " class="math";align="absmiddle"> using the endogenous
gridpoints method described above. Thus we have transformed the multidimensional
optimization problem into a sequence of two simple optimization problems.
<!--l. 2550--><p class="indent" >  Note the parallel between this trick and the fundamental insight of dynamic programming:
Dynamic programming techniques transform a multi-period (or inÔ¨Ånite-period) optimization
problem into a sequence of two-period optimization problems which are individually much
easier to solve; we have done the same thing here, but with multiple dimensions of controls
rather than multiple periods.
<!--l. 2557--><p class="indent" >  <a 
 id="Implementation"></a>
  <h4 class="subsectionHead"><span class="titlemark">7.3  </span> <a 
 id="x1-300007.3"></a>Implementation</h4>
<!--l. 2560--><p class="noindent" >Following the discussion from section <a 
href="#x1-280007.1">7.1<!--tex4ht:ref: subsec:MCTheory --></a>, to provide a numerical solution to the problem with
multiple control variables, we must deÔ¨Åne expressions that capture the expected marginal
value of end-of-period assets with respect to the level of assets and the share invested in risky
assets. This is addressed in ‚ÄúMultiple Control Variables‚Äù. Inheriting the structure of Python,
we establish a new subclass of <span 
class="ectt-1200">gothic_class </span>called <span 
class="ectt-1200">GothicMC</span>. This subclass preserves the
                                                                                     
                                                                                     
fundamental structure required to resolve the original problem while adding new methods that
capture the previously mentioned points. The essential functions in this new class are found in
the Ô¨Ånal four functions that account for the expected marginal value functions with
respect to each of the control variables, both for the terminal period and all earlier
periods.
<!--l. 2564--><p class="indent" >  Having the <span 
class="ectt-1200">GothicMC </span>subclass available, we can proceed with implementing the steps
laid out in section <a 
href="#x1-290007.2">7.2<!--tex4ht:ref: subsec:MCApplication --></a> to solve the problem at hand. Initially, the two distributions
that capture the uncertainty faced by consumers in this scenario are discretized.
Subsequently, the <span 
class="ectt-1200">GothicMC </span>class is invoked with the requisite arguments to create an
instance that includes the necessary functions to depict the Ô¨Årst-order conditions of the
consumer‚Äôs problem. Following that, an improved grid of end-of-period assets is
established.
<!--l. 2566--><p class="indent" >  Here is where we can see how the approach described in section <a 
href="#x1-290007.2">7.2<!--tex4ht:ref: subsec:MCApplication --></a> is reÔ¨Çected in the code.
For the terminal period, the optimal share of risky assets is determined for each point in
<span 
class="ectt-1200">aVec_eee</span>, and then the endogenous gridpoints method is employed to compute the optimal
consumption level given that the share in the risky asset has been chosen optimally.
It‚Äôs worth noting that this solution takes into account the possibility of a binding
artiÔ¨Åcial borrowing constraint. Lastly, the interpolation process is executed for both
the optimal consumption function and the optimal share of the portfolio in risky
assets. These values are stored in their respective dictionaries (<span 
class="ectt-1200">mGridPort_life</span>,
<span 
class="ectt-1200">cGridPort_life</span>, and <span 
class="ectt-1200">varsigmaGrid_life</span>) and utilized to conduct the recursive
process outlined in section <a 
href="#x1-230006">6<!--tex4ht:ref: sec:recursion --></a>, thus yielding the numerical solution for all earlier
periods.
<!--l. 2568--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">7.4  </span> <a 
 id="x1-310007.4"></a>Results</h4>
<!--l. 2570--><p class="noindent" >Figure¬†<a 
href="#x1-3100120">20<!--tex4ht:ref: fig:PlotctMultContr --></a> plots the Ô¨Årst-period consumption function generated by the program; qualitatively
it does not look much diÔ¨Äerent from the consumption functions generated by the program
without portfolio choice. Figure¬†<a 
href="#x1-3100221">21<!--tex4ht:ref: fig:PlotRiskySharetOfat --></a> plots the optimal portfolio share as a function of the level
of assets. This Ô¨Ågure exhibits several interesting features. First, even with a coeÔ¨Écient of
relative risk aversion of 6, an equity premium of only 4 percent, and an annual standard
deviation in equity returns of 15 percent, the optimal choice is for the agent to invest
a proportion 1 (100 percent) of the portfolio in stocks (instead of the safe bank
account with riskless return <img 
src="SolvingMicroDSOPs609x.svg" alt="R  " class="math";align="absmiddle">) is at values of <img 
src="SolvingMicroDSOPs610x.svg" alt="at  " class="math";align="absmiddle"> less than about 2. Second, the
proportion of the portfolio kept in stocks is <span 
class="ecti-1200">declining </span>in the level of wealth - i.e., the poor
should hold all of their meager assets in stocks, while the rich should be cautious,
holding more of their wealth in safe bank deposits and less in stocks. This seemingly
bizarre (and highly counterfactual) prediction reÔ¨Çects the nature of the risks the
consumer faces. Those consumers who are poor in measured Ô¨Ånancial wealth are
likely to derive a high proportion of future consumption from their labor income.
Since by assumption labor income risk is uncorrelated with rate-of-return risk, the
                                                                                     
                                                                                     
covariance between their future consumption and future stock returns is relatively
low. By contrast, persons with relatively large wealth will be paying for a large
proportion of future consumption out of that wealth, and hence if they invest too much
of it in stocks their consumption will have a high covariance with stock returns.
Consequently, they reduce that correlation by holding some of their wealth in the riskless
form.
<!--l. 2598--><p class="indent" >  <a 
 id="PlotctMultContr"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3100120"></a>
                                                                                     
                                                                                     
<!--l. 2600--><p class="noindent" > <img 
src="./Figures/PlotctMultContr.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†20:</span><span  
class="content"><img 
src="SolvingMicroDSOPs611x.svg" alt="c(m1 )  " class="math";align="absmiddle"> With Portfolio Choice</span></figcaption><!--tex4ht:label?: x1-3100120 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2605--><p class="indent" >  <a 
 id="PlotRiskySharetOfat"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3100221"></a>
                                                                                     
                                                                                     
<!--l. 2607--><p class="noindent" > <img 
src="./Figures/PlotRiskySharetOfat.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†21:</span><span  
class="content">Portfolio Share in Risky Assets in First Period <img 
src="SolvingMicroDSOPs612x.svg" alt="œÇ(a)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-3100221 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2612--><p class="indent" >  <a 
 id="The-Infinite-Horizon"></a>
  <h3 class="sectionHead"><span class="titlemark">8  </span> <a 
 id="x1-320008"></a>The-InÔ¨Ånite-Horizon</h3>
<!--l. 2615--><p class="noindent" >All of the solution methods presented so far have involved period-by-period iteration from an
assumed last period of life, as is appropriate for life cycle problems. However, if the parameter
values for the problem satisfy certain conditions (detailed in <span 
class="ecbx-1200">?</span>), the consumption rules (and
the rest of the problem) will converge to a Ô¨Åxed rule as the horizon (remaining lifetime) gets
large, as illustrated in Figure¬†<a 
href="#x1-2600119">19<!--tex4ht:ref: fig:PlotCFuncsConverge --></a>. Furthermore, Deaton¬†(<span 
class="ecbx-1200">?</span>), Carroll¬†(<span 
class="ecbx-1200">??</span>) and others have
argued that the ‚ÄòbuÔ¨Äer-stock‚Äô saving behavior that emerges under some further restrictions on
parameter values is a good approximation of the behavior of typical consumers over much of
the lifetime. Methods for Ô¨Ånding the converged functions are therefore of interest, and are
dealt with in this section.
<!--l. 2631--><p class="indent" >  Of course, the simplest such method is to solve the problem as speciÔ¨Åed above for a large
number of periods. This is feasible, but there are much faster methods.
<!--l. 2635--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">8.1  </span> <a 
 id="x1-330008.1"></a>Convergence</h4>
<!--l. 2637--><p class="noindent" >In solving an inÔ¨Ånite-horizon problem, it is necessary to have some metric that determines
when to stop because a solution that is ‚Äògood enough‚Äô has been found.
<!--l. 2641--><p class="indent" >  A natural metric is deÔ¨Åned by the unique ‚Äòtarget‚Äô level of wealth that <span 
class="ecbx-1200">? </span>proves will exist in
problems of this kind <a 
href="https://llorracc.github.io/BufferStockTheory#GICNrm" >under certain conditions</a>: The <img 
src="SolvingMicroDSOPs613x.svg" alt="ÀÜm  " class="math";align="absmiddle"> such that
  <table 
class="equation"><tr><td><a 
 id="x1-33001r67"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs614x.svg" alt="ùîºt [mt+1 ‚àïmt ] = 1 if mt = ÀÜm
" class="math-display" ></div>
  </td><td class="equation-label">(67)</td></tr></table>
<!--l. 2645--><p class="nopar" >
where the accent is meant to signify that this is the value that other <img 
src="SolvingMicroDSOPs615x.svg" alt="m  " class="math";align="absmiddle">‚Äôs ‚Äòpoint
to.‚Äô
                                                                                     
                                                                                     
<!--l. 2649--><p class="indent" >  Given a consumption rule <img 
src="SolvingMicroDSOPs616x.svg" alt="c(m )  " class="math";align="absmiddle"> it is straightforward to Ô¨Ånd the corresponding <img 
src="SolvingMicroDSOPs617x.svg" alt="ÀÜm  " class="math";align="absmiddle">. So for
our problem, a solution is declared to have converged if the following criterion is met:
<img 
src="SolvingMicroDSOPs618x.svg" alt="|mÀÜt+1 ‚àí  ÀÜmt| &#x003C; ùúñ  " class="math";align="absmiddle">, where <img 
src="SolvingMicroDSOPs619x.svg" alt="ùúñ  " class="math";align="absmiddle"> is a very small number and measures our degree of convergence
tolerance.
<!--l. 2655--><p class="indent" >  Similar criteria can obviously be speciÔ¨Åed for other problems. However, it is always wise to
plot successive function diÔ¨Äerences and to experiment a bit with convergence criteria to verify
that the function has converged for all practical purposes.
<!--l. 2730--><p class="indent" >  <a 
 id="StructuralEstimation"></a>
  <h3 class="sectionHead"><span class="titlemark">9  </span> <a 
 id="x1-340009"></a>Structural Estimation</h3>
<!--l. 2733--><p class="noindent" >This section describes how to use the methods developed above to structurally
estimate a life-cycle consumption model, following closely the work of
<a 
href="#XcagettiWprofiles">Cagetti</a>¬†(<a 
href="#XcagettiWprofiles">2003</a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs20.html#fn19x0"><sup class="textsuperscript">19</sup></a></span><a 
 id="x1-34001f19"></a>  
The key idea of structural estimation is to look for the parameter values (for the time
preference rate, relative risk aversion, or other parameters) which lead to the best possible
match between simulated and empirical moments.
<!--l. 2744--><p class="indent" >  <a 
 id="LifeCycleModel"></a>
  <h4 class="subsectionHead"><span class="titlemark">9.1  </span> <a 
 id="x1-350009.1"></a>Life Cycle Model</h4>
<!--l. 2748--><p class="noindent" >Realistic calibration of a life cycle model needs to take into account a few things that
we omitted from the bare-bones model described above. For example, the whole
point of the life cycle model is that life is Ô¨Ånite, so we need to include a realistic
treatment of life expectancy; this is done easily enough, by assuming that utility
accrues only if you live, so eÔ¨Äectively the rising mortality rate with age is treated as
an extra reason for discounting the future. Similarly, we may want to capture the
demographic evolution of the household (e.g., arrival and departure of kids). A common
way to handle that, too, is by modifying the discount factor (arrival of a kid might
increase the total utility of the household by, say, 0.2, so if the ‚Äòpure‚Äô rate of time
preference were <img 
src="SolvingMicroDSOPs620x.svg" alt="1.0  " class="math";align="absmiddle"> the ‚Äòhousehold-size-adjusted‚Äô discount factor might be 1.2. We
therefore modify the model presented above to allow age-varying discount factors that
capture both mortality and family-size changes (we just adopt the factors used by
<a 
href="#XcagettiWprofiles">Cagetti</a>¬†(<a 
href="#XcagettiWprofiles">2003</a>) directly), with the probability of remaining alive between <img 
src="SolvingMicroDSOPs621x.svg" alt="t  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs622x.svg" alt="t + n  " class="math";align="absmiddle"> captured by <img 
src="SolvingMicroDSOPs623x.svg" alt="‚Ñí " class="math";align="absmiddle"> and with <img 
src="SolvingMicroDSOPs624x.svg" alt="ÀÜŒ≤  " class="math";align="absmiddle"> now reÔ¨Çecting all the age-varying discount factor
adjustments (mortality, family-size, etc). Using <img 
src="SolvingMicroDSOPs625x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> (the Hebrew cognate of <img 
src="SolvingMicroDSOPs626x.svg" alt="Œ≤  " class="math";align="absmiddle">)
for the ‚Äòpure‚Äô time preference factor, the value function for the revised problem is
                                                                                     
                                                                                     
  <table 
class="equation"><tr><td><a 
 id="x1-35001r68"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs627x.svg" alt="                             [                      ]
                              T‚àë‚àít
vt(pt,mt) = max   u (ct) + ùîºt      ‚Ñ∂n‚Ñít+tn ÀÜŒ≤tt+nu(ct+n)
             {c}Tt              n=1
" class="math-display" ></div>
  </td><td class="equation-label">(68)</td></tr></table>
<!--l. 3--><p class="nopar" >
subject to the constraints
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs628x.svg" alt="   at = mt ‚àí  ct
 pt+1 = ùí¢t+1ptŒ®t+1

 yt+1 = pt+1ùúÉùúÉùúÉt+1
mt+1  = Rat + yt+1
" class="math-display" ></div>
  </td></tr></table>
<!--l. 6--><p class="nopar" >
where
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs629x.svg" alt="‚Ñít+n : probability to ‚Ñíive until age t + n given alive at age t
  t
Œ≤ÀÜtt+n : age -varying discount factor between ages t and t + n
  Œ®  : mean -one shock  to permanent   income
    t
   ‚Ñ∂ : time -invariant ‚Äòpure ‚Äô discount factor
" class="math-display" ></div>
  </td></tr></table>
<!--l. 6--><p class="nopar" >
and all the other variables are deÔ¨Åned as in section <a 
href="#x1-20002">2<!--tex4ht:ref: sec:the-problem --></a>.
<!--l. 2777--><p class="indent" >  Households start life at age <img 
src="SolvingMicroDSOPs630x.svg" alt="s = 25  " class="math";align="absmiddle"> and live with probability 1 until retirement (<img 
src="SolvingMicroDSOPs631x.svg" alt="s = 65  " class="math";align="absmiddle">).
Thereafter the survival probability shrinks every year and agents are dead by <img 
src="SolvingMicroDSOPs632x.svg" alt="s = 91  " class="math";align="absmiddle"> as
assumed by Cagetti.
<!--l. 1--><p class="indent" >  Transitory and permanent shocks are distributed as follows:
  <table 
class="equation"><tr><td><a 
 id="x1-35002r69"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs633x.svg" alt="         {
           0      with probability ‚Ñò &#x003E;  0
    Œûs =   ùúÉùúÉùúÉ ‚àï‚Ñò   with probability (1 ‚àí ‚Ñò), where logùúÉùúÉùúÉ  ‚àΩ ùí©  (‚àí œÉ2 ‚àï2,œÉ2)
            s                                         s        ùúÉùúÉùúÉ    ùúÉùúÉùúÉ
logŒ®s  ‚àΩ ùí© (‚àí œÉ2Œ® ‚àï2,œÉ2Œ® )
" class="math-display" ></div>
  </td><td class="equation-label">(69)</td></tr></table>
<!--l. 9--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs634x.svg" alt="‚Ñò  " class="math";align="absmiddle"> is the probability of unemployment (and unemployment shocks are turned oÔ¨Ä after
retirement).
<!--l. 2795--><p class="indent" >  The parameter values for the shocks are taken from Carroll¬†(<span 
class="ecbx-1200">?</span>), <img 
src="SolvingMicroDSOPs635x.svg" alt="‚Ñò = 0.5‚àï100  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs636x.svg" alt="œÉùúÉùúÉùúÉ = 0.1  " class="math";align="absmiddle">, and
<img 
src="SolvingMicroDSOPs637x.svg" alt="œÉ Œ® = 0.1  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs21.html#fn20x0"><sup class="textsuperscript">20</sup></a></span><a 
 id="x1-35003f20"></a>   The
income growth proÔ¨Åle <img 
src="SolvingMicroDSOPs641x.svg" alt="ùí¢t  " class="math";align="absmiddle"> is from Carroll¬†(<span 
class="ecbx-1200">?</span>) and the values of <img 
src="SolvingMicroDSOPs642x.svg" alt="‚Ñít  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs643x.svg" alt="Œ≤ÀÜt  " class="math";align="absmiddle"> are obtained from Cagetti¬†(<a 
href="#XcagettiWprofiles">2003</a>)
                                                                                     
                                                                                     
(Figure <a 
href="#x1-3500522">22<!--tex4ht:ref: fig:TimeVaryingParam --></a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs22.html#fn21x0"><sup class="textsuperscript">21</sup></a></span><a 
 id="x1-35004f21"></a>  
The interest rate is assumed to equal <img 
src="SolvingMicroDSOPs644x.svg" alt="1.03  " class="math";align="absmiddle">. The model parameters are included in Table
<a 
href="#x1-350061">1<!--tex4ht:ref: table:StrEstParams --></a>.
<!--l. 2798--><p class="indent" >  <a 
 id="PlotTimeVaryingParam"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3500522"></a>
                                                                                     
                                                                                     
<!--l. 2800--><p class="noindent" > <img 
src="./Figures/PlotTimeVaryingParam.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†22:</span><span  
class="content">Time Varying Parameters</span></figcaption><!--tex4ht:label?: x1-3500522 -->
                                                                                     
                                                                                     
  </div>
  <div class="table">
                                                                                     
                                                                                     
<!--l. 2805--><p class="indent" >  <a 
 id="x1-350061"></a><figure class="float" 
>
                                                                                     
                                                                                     
<figcaption class="caption" ><span class="id">Table¬†1:</span><span  
class="content">Parameter Values</span></figcaption><!--tex4ht:label?: x1-350061 -->
<div class="center" 
>
<!--l. 2807--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs645x.svg" alt="------------------------------------
   œÉùúÉùúÉùúÉ       0.1      Carroll (?)
  œÉ Œ®       0.1      Carroll (?)

   ‚Ñò       0.005     Carroll (?)
   ùí¢s    Ô¨Ågure 22   Carroll (?)
 ÀÜŒ≤s,‚Ñís   Ô¨Ågure 22   Cagetti (2003 )
   R       1.03     Cagetti (2003 )
------------------------------------
" ></div></div>
                                                                                     
                                                                                     
  </figure>
  </div>
<!--l. 2821--><p class="indent" >  The structural estimation of the parameters <img 
src="SolvingMicroDSOPs646x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs647x.svg" alt="œÅ  " class="math";align="absmiddle"> is carried out using the procedure
speciÔ¨Åed in the following section, which is then implemented in the <span 
class="ectt-1200">StructEstimation.py </span>Ô¨Åle.
This Ô¨Åle consists of two main components. The Ô¨Årst section deÔ¨Ånes the objects required to
execute the structural estimation procedure, while the second section executes the procedure
and various optional experiments with their corresponding commands. The next section
elaborates on the procedure and its accompanying code implementation in greater
detail.
  <h4 class="subsectionHead"><span class="titlemark">9.2  </span> <a 
 id="x1-360009.2"></a>Estimation</h4>
<!--l. 2831--><p class="noindent" >When economists say that they are performing ‚Äústructural estimation‚Äù of a model like this, they
mean that they have devised a formal procedure for searching for values for the parameters <img 
src="SolvingMicroDSOPs648x.svg" alt="‚Ñ∂  " class="math";align="absmiddle">
and <img 
src="SolvingMicroDSOPs649x.svg" alt="œÅ  " class="math";align="absmiddle"> at which some measure of the model‚Äôs outcome (like ‚Äúmedian wealth by age‚Äù) is as
close as possible to an empirical measure of the same thing. Here, we choose to match the
median of the wealth to permanent income ratio across 7 age groups, from age <img 
src="SolvingMicroDSOPs650x.svg" alt="26 ‚àí 30  " class="math";align="absmiddle"> up to
<img 
src="SolvingMicroDSOPs651x.svg" alt="56 ‚àí 60  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs23.html#fn22x0"><sup class="textsuperscript">22</sup></a></span><a 
 id="x1-36001f22"></a>  
The choice of matching the medians rather the means is motivated by the fact that the wealth
distribution is much more concentrated at the top than the model is capable of
explaining using a single set of parameter values. This means that in practice one
must pick some portion of the population who one wants to match well; since the
model has little hope of capturing the behavior of Bill Gates, but might conceivably
match the behavior of Homer Simpson, we choose to match medians rather than
means.
<!--l. 2853--><p class="indent" >  As explained in section <a 
href="#x1-30003">3<!--tex4ht:ref: sec:normalization --></a>, it is convenient to work with the normalized version of the model
which can be written in Bellman form as:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs652x.svg" alt="v (m ) = max    u(c ) + ‚Ñ∂ ‚Ñí  Œ≤ÀÜ   ùîº [(Œ®    ùí¢   )1‚àíœÅv   (m    )]
 t   t     ct       t       t+1  t+1  t   t+1 t+1     t+1   t+1
      s.t.

    at = mt ‚àí  ct
           (     R    )
  mt+1 = at  ---------   + ùúÉùúÉùúÉt+1
           ‚óü Œ®t+1‚óùùí¢‚óút+1-‚óû
               ‚â° ‚Ñõt+1
" class="math-display" ></div>
  </td></tr></table>
<!--l. 7--><p class="nopar" >
with the Ô¨Årst order condition:
  <table 
class="equation"><tr><td><a 
 id="x1-36002r70"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs653x.svg" alt=" c             ÀÜ         c
u (ct) = ‚Ñ∂‚Ñít+1Œ≤t+1R ùîºt [u  (Œ®t+1ùí¢t+1ct+1 (at‚Ñõt+1  + ùúÉùúÉùúÉt+1))].
" class="math-display" ></div>
  </td><td class="equation-label">(70)</td></tr></table>
<!--l. 4--><p class="nopar" >
<!--l. 2873--><p class="indent" >  The Ô¨Årst substantive step in this estimation procedure is to solve for the consumption
functions at each age. We need to discretize the shock distribution and solve for the policy
functions by backward induction using equation (<a 
href="#x1-36002r70">70<!--tex4ht:ref: eq:FOCLifeCycle --></a>) following the procedure in sections <a 
href="#x1-70005">5<!--tex4ht:ref: sec:NextToLast --></a> and
<a 
href="#x1-230006">6<!--tex4ht:ref: sec:recursion --></a>. The latter routine is slightly complicated by the fact that we are considering a life-cycle
model and therefore the growth rate of permanent income, the probability of death, the
time-varying discount factor and the distribution of shocks will be diÔ¨Äerent across the years.
We thus must ensure that at each backward iteration the right parameter values are
used.
<!--l. 2886--><p class="indent" >  Correspondingly, the Ô¨Årst part of the <span 
class="ectt-1200">StructEstimation.py </span>Ô¨Åle begins by deÔ¨Åning the
agent type by inheriting from the baseline agent type <span 
class="ectt-1200">IndShockConsumerType</span>, with the
modiÔ¨Åcation to include time-varying discount factors. Next, an instance of this ‚Äúlife-cycle‚Äù
consumer is created for the estimation procedure. The number of periods for the life cycle of a
given agent is set and, following Cagetti, ¬†(<a 
href="#XcagettiWprofiles">2003</a>), we initialize the wealth to income ratio of
agents at age <img 
src="SolvingMicroDSOPs654x.svg" alt="25  " class="math";align="absmiddle"> by randomly assigning the equal probability values to <img 
src="SolvingMicroDSOPs655x.svg" alt="0.17  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs656x.svg" alt="0.50  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs657x.svg" alt="0.83  " class="math";align="absmiddle">. In particular, we consider a population of agents at age 25 and follow their
                                                                                     
                                                                                     
consumption and wealth accumulation dynamics as they reach the age of <img 
src="SolvingMicroDSOPs658x.svg" alt="60  " class="math";align="absmiddle">, using the
appropriate age-speciÔ¨Åc consumption functions and the age-varying parameters. The simulated
medians are obtained by taking the medians of the wealth to income ratio of the <img 
src="SolvingMicroDSOPs659x.svg" alt="7  " class="math";align="absmiddle"> age
groups.
<!--l. 2901--><p class="indent" >  To complete the creation of the consumer type needed for the simulation, a history of shocks
is drawn for each agent across all periods by invoking the <span 
class="ectt-1200">make_shock_history </span>function. This
involves discretizing the shock distribution for as many points as the number of agents we
want to simulate and then randomly permuting this shock vector as many times as we need to
simulate the model for. In this way, we obtain a time varying shock for each agent. This is
much more time eÔ¨Écient than drawing at each time from the shock distribution a shock for
each agent, and also ensures a stable distribution of shocks across the simulation periods even
for a small number of agents. (Similarly, in order to speed up the process, at each backward
iteration we compute the consumption function and other variables as a vector at
once.)
<!--l. 2914--><p class="indent" >  With the age-varying consumption functions derived from the life-cycle agent, we can
proceed to generate simulated data and compute the corresponding medians. Estimating the
model involves comparing these simulated medians with empirical medians, measuring the
model‚Äôs success by calculating the diÔ¨Äerence between the two. However, before performing the
necessary steps of solving and simulating the model to generate simulated moments, it‚Äôs
important to note a diÔ¨Éculty in producing the target moments using the available
data.
<!--l. 2922--><p class="indent" >  SpeciÔ¨Åcally, deÔ¨Åning <img 
src="SolvingMicroDSOPs660x.svg" alt="Œæ  " class="math";align="absmiddle"> as the set of parameters to be estimated (in the current case
<img 
src="SolvingMicroDSOPs661x.svg" alt="Œæ = {œÅ, ‚Ñ∂} " class="math";align="absmiddle">), we could search for the parameter values which solve
  <table 
class="equation"><tr><td><a 
 id="x1-36003r71"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs662x.svg" alt="    ‚àë 7
min     |œÇœÑ ‚àí sœÑ(Œæ)|
  Œæ œÑ=1
" class="math-display" ></div>
  </td><td class="equation-label">(71)</td></tr></table>
<!--l. 7--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs663x.svg" alt="œÇœÑ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs664x.svg" alt="sœÑ  " class="math";align="absmiddle"> are respectively the empirical and simulated medians of the wealth to
permanent income ratio for age group <img 
src="SolvingMicroDSOPs665x.svg" alt="œÑ  " class="math";align="absmiddle">. A drawback of proceeding in this way is that it
treats the empirically estimated medians as though they reÔ¨Çected perfect measurements of the
truth. Imagine, however, that one of the age groups happened to have (in the consumer
survey) four times as many data observations as another age group; then we would expect the
                                                                                     
                                                                                     
median to be more precisely estimated for the age group with more observations; yet (<a 
href="#x1-36003r71">71<!--tex4ht:ref: eq:naivePowell --></a>)
assigns equal importance to a deviation between the model and the data for all age
groups.
<!--l. 2946--><p class="indent" >  We can get around this problem (and a variety of others) by instead minimizing a slightly
more complex object:
  <table 
class="equation"><tr><td><a 
 id="x1-36004r72"></a>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs666x.svg" alt="    ‚àëN
min     œâi|œÇœÑ‚àí  sœÑ(Œæ)|
 Œæ   i      i
" class="math-display" ></div>
  </td><td class="equation-label">(72)</td></tr></table>
<!--l. 3--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs667x.svg" alt="œâ
 i  " class="math";align="absmiddle">  is the weight of household <img 
src="SolvingMicroDSOPs668x.svg" alt="i  " class="math";align="absmiddle"> in the entire
population,<span class="footnote-mark"><a 
href="SolvingMicroDSOPs24.html#fn23x0"><sup class="textsuperscript">23</sup></a></span><a 
 id="x1-36005f23"></a>  
and <img 
src="SolvingMicroDSOPs669x.svg" alt=" œÑ
œÇi  " class="math";align="absmiddle"> is the empirical wealth to permanent income ratio of household <img 
src="SolvingMicroDSOPs670x.svg" alt="i  " class="math";align="absmiddle"> whose head
belongs to age group <img 
src="SolvingMicroDSOPs671x.svg" alt="œÑ  " class="math";align="absmiddle">. <img 
src="SolvingMicroDSOPs672x.svg" alt="œâi  " class="math";align="absmiddle"> is needed because unequal weight is assigned to each observation
in the Survey of Consumer Finances (SCF). The absolute value is used since the formula is
based on the fact that the median is the value that minimizes the sum of the absolute
deviations from itself.
<!--l. 2969--><p class="indent" >  With this in mind, we turn our attention to the computation of the weighted median
wealth target moments for each age cohort using this data from the 2004 Survery of
Consumer Finances on household wealth. The objects necessary to accomplish this
task are <span 
class="ectt-1200">weighted_median </span>and <span 
class="ectt-1200">get_targeted_moments</span>. The actual data are taken
from several waves of the SCF and the medians and means for each age category
are plotted in Ô¨Ågure <a 
href="#x1-3600623">23<!--tex4ht:ref: fig:MeanMedianSCF --></a>. More details on the SCF data are included in appendix
<a 
href="#x1-40000A">A<!--tex4ht:ref: app:SCFdata --></a>.
<!--l. 2977--><p class="indent" >  <a 
 id="PlotMeanMedianSCFcollegeGrads"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3600623"></a>
                                                                                     
                                                                                     
<!--l. 2980--><p class="noindent" > <img 
src="./Figures/PlotMeanMedianSCFcollegeGrads.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure¬†23:</span><span  
class="content">Wealth to Permanent Income Ratios from SCF (means (dashed) and medians
(solid))</span></figcaption><!--tex4ht:label?: x1-3600623 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2985--><p class="indent" >  We now turn our attention to the the two key functions in this section of the code Ô¨Åle. The
Ô¨Årst, <span 
class="ectt-1200">simulate_moments</span>, executes the solving (<span 
class="ectt-1200">solve</span>) and simulation (<span 
class="ectt-1200">simulation</span>)
steps for the deÔ¨Åned life-cycle agent. Subsequently, the function uses the agents‚Äô
tracked levels of wealth based on their optimal consumption behavior to compute
and store the simulated median wealth to income ratio for each age cohort. The
second function, <span 
class="ectt-1200">smmObjectiveFxn</span>, calls the <span 
class="ectt-1200">simulate_moments </span>function to create
the objective function described in (<a 
href="#x1-36004r72">72<!--tex4ht:ref: eq:StructEstim --></a>), which is necessary to perform the SMM
estimation.
<!--l. 3006--><p class="indent" >  Thus, for a given pair of the parameters to be estimated, the single call to the function
<span 
class="ectt-1200">smmObjectiveFxn </span>executes the following:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-36008x1">solves for the consumption functions for the life-cycle agent
      </li>
      <li 
  class="enumerate" id="x1-36010x2">simulates the data and computes the simulated medians
      </li>
      <li 
  class="enumerate" id="x1-36012x3">returns the value of equation (<a 
href="#x1-36004r72">72<!--tex4ht:ref: eq:StructEstim --></a>)</li></ol>
<!--l. 3014--><p class="indent" >  We delegate the task of Ô¨Ånding the coeÔ¨Écients that minimize the <span 
class="ectt-1200">smmObjectiveFxn</span>
function to the <span 
class="ectt-1200">minimize_nelder_mead </span>function, which is deÔ¨Åned elsewhere and called in the
second part of this Ô¨Åle. This task can be quite time demanding and rather problematic if the
<span 
class="ectt-1200">smmObjectiveFxn </span>function has very Ô¨Çat regions or sharp features. It is thus wise to verify the
accuracy of the solution, for example by experimenting with a variety of alternative starting
values for the parameter search.
<!--l. 3023--><p class="indent" >  The Ô¨Ånal object deÔ¨Åned in this Ô¨Årst part of the <span 
class="ectt-1200">StructEstimation.py</span>
Ô¨Åle is <span 
class="ectt-1200">calculateStandardErrorsByBootstrap</span>. As the name suggsts,
the purpose of this function is to compute the standard errors by
bootstrap.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs25.html#fn24x0"><sup class="textsuperscript">24</sup></a></span><a 
 id="x1-36013f24"></a>  
This involves:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-36015x1">drawing new shocks for the simulation
      </li>
      <li 
  class="enumerate" id="x1-36017x2">drawing a random sample (with replacement) of actual data from the SCF
      </li>
      <li 
  class="enumerate" id="x1-36019x3">obtaining new estimates for <img 
src="SolvingMicroDSOPs673x.svg" alt="œÅ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs674x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"></li></ol>
<!--l. 3033--><p class="noindent" >We repeat the above procedure several times (<span 
class="ectt-1200">Bootstrap</span>) and take the standard deviation for
each of the estimated parameters across the various bootstrap iterations.
                                                                                     
                                                                                     
  <h5 class="subsubsectionHead"><span class="titlemark">9.2.1  </span> <a 
 id="x1-370009.2.1"></a>An Aside to Computing Sensitivity Measures</h5>
<!--l. 3038--><p class="noindent" >A common drawback in commonly used structural estimation procedures is a lack of
transparency in its estimates. As <span 
class="ecbx-1200">? </span>notes, a researcher employing such structural empirical
methods may be interested in how alternative assumptions (such as misspeciÔ¨Åcation or
measurement bias in the data) would ‚Äúchange the moments of the data that the estimator uses
as inputs, and how changes in these moments aÔ¨Äect the estimates‚Äù. The authors provide a
measure of sensitivity for given estimator that makes it easy to map the eÔ¨Äects of diÔ¨Äerent
assumptions on the moments into predictable bias in the estimates for non-linear
models.
<!--l. 3045--><p class="indent" >  In the language of <span 
class="ecbx-1200">?</span>, section <a 
href="#x1-340009">9<!--tex4ht:ref: sec:StructEst --></a> is aimed at providing an estimator <img 
src="SolvingMicroDSOPs675x.svg" alt="Œæ = {œÅ,‚Ñ∂ } " class="math";align="absmiddle"> that has some
true value <img 
src="SolvingMicroDSOPs676x.svg" alt="Œæ0   " class="math";align="absmiddle"> by assumption. Under the assumption <img 
src="SolvingMicroDSOPs677x.svg" alt="a0   " class="math";align="absmiddle"> of the researcher, the empirical
targets computed from the SCF is measured accurately. These moments of the data are
precisely what determine our estimate <img 
src="SolvingMicroDSOPs678x.svg" alt="ÀÜ
Œæ " class="math";align="absmiddle">, which minimizes (<a 
href="#x1-36004r72">72<!--tex4ht:ref: eq:StructEstim --></a>). Under alternative
assumptions <img 
src="SolvingMicroDSOPs679x.svg" alt="a  " class="math";align="absmiddle">, such that a given cohort is mismeasured in the survey, a diÔ¨Äerent
estimate is computed. Using the plug-in estimate provided by the authors, we can see
quantitatively how our estimate changes under these alternative assumptions <img 
src="SolvingMicroDSOPs680x.svg" alt="a  " class="math";align="absmiddle"> which
correspond to mismeasurement in the median wealth to income ratio for a given age
cohort.
<!--l. 3053--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">9.3  </span> <a 
 id="x1-380009.3"></a>Results</h4>
<!--l. 3054--><p class="noindent" >The second part of the Ô¨Åle <span 
class="ectt-1200">StructEstimation.py </span>deÔ¨Ånes a function <span 
class="ectt-1200">main </span>which produces
our <img 
src="SolvingMicroDSOPs681x.svg" alt="œÅ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs682x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> estimates with standard errors using 10,000 simulated agents by
setting the positional arguments <span 
class="ectt-1200">estimate_model </span>and <span 
class="ectt-1200">compute_standard_errors </span>to
true.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs26.html#fn25x0"><sup class="textsuperscript">25</sup></a></span><a 
 id="x1-38001f25"></a>   Results are
reported in Table <a 
href="#x1-380032">2<!--tex4ht:ref: tab:EstResults --></a>.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs27.html#fn26x0"><sup class="textsuperscript">26</sup></a></span><a 
 id="x1-38002f26"></a>  
  <div class="table">
                                                                                     
                                                                                     
<!--l. 1--><p class="indent" >  <a 
 id="x1-380032"></a><figure class="float" 
>
                                                                                     
                                                                                     
<figcaption class="caption" ><span class="id">Table¬†2:</span><span  
class="content">Estimation Results</span></figcaption><!--tex4ht:label?: x1-380032 -->
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs685x.svg" alt="-------------------
----œÅ--------‚Ñ∂-----
  3.69      0.88
 (0.047)  (0.002)
-------------------
" ></div>
                                                                                     
                                                                                     
  </figure>
  </div>
<!--l. 3086--><p class="indent" >  The literature on consumption and savings behavior over the lifecycle in the presenece of labor income
uncertainty <span class="footnote-mark"><a 
href="SolvingMicroDSOPs28.html#fn27x0"><sup class="textsuperscript">27</sup></a></span><a 
 id="x1-38004f27"></a>  
warns us to be careful in disentangling the eÔ¨Äect of time preference and risk aversion when
describing the optimal behavior of households in this setting. Since the precautionary saving
motive dominates in the early stages of life, the coeÔ¨Écient of relative risk aversion (as well
as expected labor income growth) has a larger eÔ¨Äect on optimal consumption and
saving behavior through their magnitude relative to the interest rate. Over time,
life-cycle considerations (such as saving for retirement) become more important and the
time preference factor plays a larger role in determining optimal behavior for this
cohort.
<!--l. 3096--><p class="indent" >  Using the positional argument <span 
class="ectt-1200">compute_sensitivity</span>, Figure <a 
href="#x1-3800524">24<!--tex4ht:ref: fig:PlotSensitivityMeasure --></a> provides a plot of the
plug-in estimate of the sensitivity measure described in <a 
href="#x1-370009.2.1">9.2.1<!--tex4ht:ref: subsubsec:sensmeas --></a>. As you can see from the Ô¨Ågure
the inverse relationship between <img 
src="SolvingMicroDSOPs686x.svg" alt="œÅ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs687x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> over the life-cycle is retained by the sensitivity
measure. SpeciÔ¨Åcally, under the alternative assumption that <span 
class="ecti-1200">a particular cohort is</span>
<span 
class="ecti-1200">mismeasured in the SCF dataset</span>, we see that the y-axis suggests that our estimate of <img 
src="SolvingMicroDSOPs688x.svg" alt="œÅ  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs689x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> change in a predictable way.
<!--l. 3103--><p class="indent" >  Suppose that there are not enough observations of the oldest cohort of households in the
sample. Suppose further that the researcher predicts that adding more observations of these
households to correct this mismeasurement would correspond to a higher median wealth to
income ratio for this cohort. In this case, our estimate of the time preference factor should
increase: the behavior of these older households is driven by their time preference, so a
higher value of <img 
src="SolvingMicroDSOPs690x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> is required to match the aÔ¨Äected wealth to income targets under
this alternative assumption. Since risk aversion is less important in explaining the
behavior of this cohort, a lower value of <img 
src="SolvingMicroDSOPs691x.svg" alt="œÅ  " class="math";align="absmiddle"> is required to match the aÔ¨Äected empirical
moments.
<!--l. 3112--><p class="indent" >  To recap, the sensitivity measure not only matches our intuition about the inverse
relationship between <img 
src="SolvingMicroDSOPs692x.svg" alt="œÅ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs693x.svg" alt="‚Ñ∂  " class="math";align="absmiddle"> over the life-cycle, but provides a quantitative estimate of
what would happen to our estimates of these parameters under the alternative assumption
that the data is mismeasured in some way.
<!--l. 3116--><p class="indent" >  <a 
 id="PlotSensitivityMeasure"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3800524"></a>
                                                                                     
                                                                                     
<!--l. 3118--><p class="noindent" > <img 
src="./Figures/Sensitivity-.svg" alt="PIC"  
style="width:96.76%">
<figcaption class="caption" ><span class="id">Figure¬†24:</span><span  
class="content">Sensitivty  of  Estimates  <img 
src="SolvingMicroDSOPs694x.svg" alt="{œÅ,‚Ñ∂} " class="math";align="absmiddle"> regarding  Alternative  Mismeasurement
Assumptions.</span></figcaption><!--tex4ht:label?: x1-3800524 -->
                                                                                     
                                                                                     
  </div>
<!--l. 3123--><p class="indent" >  By setting the positional argument <span 
class="ectt-1200">make_contour_plot </span>to true, Figure <a 
href="#x1-3900125">25<!--tex4ht:ref: fig:PlotContourMedianStrEst --></a> shows the
contour plot of the <span 
class="ectt-1200">smmObjectiveFxn </span>function and the parameter estimates. The contour plot
shows equally spaced isoquants of the <span 
class="ectt-1200">smmObjectiveFxn </span>function, i.e.¬†the pairs of <img 
src="SolvingMicroDSOPs695x.svg" alt="œÅ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs696x.svg" alt="‚Ñ∂  " class="math";align="absmiddle">
which lead to the same deviations between simulated and empirical medians (equivalent
values of equation (<a 
href="#x1-36004r72">72<!--tex4ht:ref: eq:StructEstim --></a>)). Interestingly, there is a large rather Ô¨Çat region; or, more
formally speaking, there exists a broad set of parameter pairs which leads to similar
simulated wealth to income ratios. Intuitively, the Ô¨Çatter and larger is this region,
the harder it is for the structural estimation procedure to precisely identify the
parameters.
  <h3 class="sectionHead"><span class="titlemark">10  </span> <a 
 id="x1-3900010"></a>Conclusion</h3>
<!--l. 3138--><p class="noindent" >There are many choices that can be made for solving microeconomic dynamic stochastic
optimization problems. The set of techniques, and associated programs, described in these
notes represents an approach that I have found to be powerful, Ô¨Çexible, and eÔ¨Écient, but other
problems may require other techniques. For a much broader treatment of many of the issues
considered here, see Judd¬†(<span 
class="ecbx-1200">?</span>).
<!--l. 3141--><p class="indent" >  <a 
 id="PlotContourMedianStrEst"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3900125"></a>
                                                                                     
                                                                                     
<!--l. 3143--><p class="noindent" > <img 
src="./Figures/SMMcontour-.svg" alt="PIC"  
style="width:96.76%">
<figcaption class="caption" ><span class="id">Figure¬†25:</span><span  
class="content">Contour Plot (larger values are shown lighter) with <img 
src="SolvingMicroDSOPs697x.svg" alt="{œÅ,‚Ñ∂ } " class="math";align="absmiddle"> Estimates (red
dot).</span></figcaption><!--tex4ht:label?: x1-3900125 -->
                                                                                     
                                                                                     
  </div>
                                                                                     
                                                                                     
  <div  
class="centerline">                                             <span 
class="ecrm-2074">Appendices</span>                            </div>
  <h3 class="sectionHead"><span class="titlemark">A  </span> <a 
 id="x1-40000A"></a>Further Details on SCF Data</h3>
<!--l. 3156--><p class="noindent" >Data used in the estimation is constructed using the SCF 1992, 1995, 1998,
2001 and 2004 waves. The deÔ¨Ånition of wealth is net worth including housing
wealth, but excluding pensions and social securities. The data set contains
only households whose heads are aged 26-60 and excludes singles, following
Cagetti¬†(<a 
href="#XcagettiWprofiles">2003</a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs29.html#fn28x0"><sup class="textsuperscript">28</sup></a></span><a 
 id="x1-40001f28"></a>  
Furthermore, the data set contains only households whose heads are college graduates. The
total sample size is 4,774.
<!--l. 3158--><p class="indent" >  In the waves between 1995 and 2004 of the SCF, levels of <span 
class="ecti-1200">normal </span>income are reported. The
question in the questionnaire is &#x0022;About what would your income have been if it had been a
normal year?&#x0022; We consider the level of normal income as corresponding to the model‚Äôs
theoretical object <img 
src="SolvingMicroDSOPs698x.svg" alt="P  " class="math";align="absmiddle">, permanent noncapital income. Levels of normal income are not
reported in the 1992 wave. Instead, in this wave there is a variable which reports whether
the level of income is normal or not. Regarding the 1992 wave, only observations
which report that the level of income is normal are used, and the levels of income of
remaining observations in the 1992 wave are interpreted as the levels of permanent
income.
<!--l. 3170--><p class="indent" >  Normal income levels in the SCF are before-tax Ô¨Ågures. These before-tax permanent income
Ô¨Ågures must be rescaled so that the median of the rescaled permanent income of each age
group matches the median of each age group‚Äôs income which is assumed in the simulation.
This rescaled permanent income is interpreted as after-tax permanent income. This rescaling
is crucial since in the estimation empirical proÔ¨Åles are matched with simulated ones which are
generated using after-tax permanent income (remember the income process assumed in the
main text). Wealth / permanent income ratio is computed by dividing the level of
wealth by the level of (after-tax) permanent income, and this ratio is used for the
estimation.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs30.html#fn29x0"><sup class="textsuperscript">29</sup></a></span><a 
 id="x1-40002f29"></a>  
                                                                                     
                                                                                     
  <h3 class="likesectionHead"><a 
 id="x1-41000A"></a>References</h3>
<!--l. 5--><p class="noindent" >
  <div class="thebibliography">
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XcagettiWprofiles"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">g</span><span 
class="small-caps">e</span><span 
class="small-caps">t</span><span 
class="small-caps">t</span><span 
class="small-caps">i</span><span 
class="small-caps">,</span>  <span 
class="small-caps">M</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">c</span><span 
class="small-caps">o</span>  </span>(2003):  ‚ÄúWealth  Accumulation  Over  the  Life  Cycle  and
  Precautionary Savings,‚Äù <span 
class="ecti-1200">Journal of Business and Economic Statistics</span>, 21(3), 339‚Äì353.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XcarrollEGM"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">,</span> <span 
class="small-caps">C</span><span 
class="small-caps">h</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">D</span><span 
class="small-caps">.</span> </span>(2006): ‚ÄúThe Method of Endogenous Gridpoints for
  Solving
  Dynamic  Stochastic  Optimization  Problems,‚Äù  <span 
class="ecti-1200">Economics  Letters</span>,  91(3),  312‚Äì320,
  <a 
href="https://www.econ2.jhu.edu/people/ccarroll/EndogenousGridpoints.pdf" class="url" ><span 
class="ectt-1200">https://www.econ2.jhu.edu/people/ccarroll/EndogenousGridpoints.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XSolvingMicroDSOPs"></a><span class="bibsp">¬†¬†¬†</span></span>__________<span 
class="eccc1200-">¬†  </span>(2023):   ‚ÄúSolving   Microeconomic   Dynamic   Stochastic   Optimization
  Problems,‚Äù <span 
class="ecti-1200">Econ-ARK REMARK</span>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XgpLifecycle"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">G</span><span 
class="small-caps">o</span><span 
class="small-caps">u</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">n</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">s</span><span 
class="small-caps">,</span> <span 
class="small-caps">P</span><span 
class="small-caps">i</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">-</span><span 
class="small-caps">O</span><span 
class="small-caps">l</span><span 
class="small-caps">i</span><span 
class="small-caps">v</span><span 
class="small-caps">i</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">,</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> <span 
class="small-caps">J</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span> <span 
class="small-caps">P</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">k</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span> </span>(2002): ‚ÄúConsumption
  Over the Life Cycle,‚Äù <span 
class="ecti-1200">Econometrica</span>, 70(1), 47‚Äì89.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xmerton:restat"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">M</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span> <span 
class="small-caps">R</span><span 
class="small-caps">o</span><span 
class="small-caps">b</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">C</span><span 
class="small-caps">.</span> </span>(1969): ‚ÄúLifetime Portfolio Selection under Uncertainty: The
  Continuous Time Case,‚Äù <span 
class="ecti-1200">Review of Economics and Statistics</span>, 51, 247‚Äì257.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xsamuelson:portfolio"></a><span class="bibsp">¬†¬†¬†</span></span><span 
class="eccc1200-"><span 
class="small-caps">S</span><span 
class="small-caps">a</span><span 
class="small-caps">m</span><span 
class="small-caps">u</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span><span 
class="small-caps">s</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span> <span 
class="small-caps">P</span><span 
class="small-caps">a</span><span 
class="small-caps">u</span><span 
class="small-caps">l</span></span><span 
class="eccc1200-">¬†<span 
class="small-caps">A</span><span 
class="small-caps">.</span> </span>(1969): ‚ÄúLifetime Portfolio Selection by Dynamic Stochastic
  Programming,‚Äù <span 
class="ecti-1200">Review of Economics and Statistics</span>, 51, 239‚Äì46.
</p>
  </div>
   
</body> 
</html>
                                                                                     


